---
phase: v3.0-02-compaction-engine
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/main/services/session-manager.ts
  - src/main/ipc/session-handlers.ts
  - src/preload/index.ts
  - src/preload/index.d.ts
autonomous: true

must_haves:
  truths:
    - "Compaction events are emitted to renderer process"
    - "UI can subscribe to compaction events"
    - "Compaction metrics are tracked (total compactions, messages compacted, tokens saved)"
    - "Manual compaction can be triggered via IPC"
  artifacts:
    - path: "src/main/services/session-manager.ts"
      provides: "Event emission for compaction lifecycle"
      contains: "EventEmitter"
    - path: "src/main/ipc/session-handlers.ts"
      provides: "IPC handlers for compaction operations"
      exports: ["session:compact", "session:getMetrics"]
    - path: "src/preload/index.ts"
      provides: "Preload API for compaction"
      contains: "onCompaction"
  key_links:
    - from: "SessionManager.compact"
      to: "BrowserWindow.send"
      via: "event emission to renderer"
      pattern: "webContents\\.send.*compaction"
    - from: "session-handlers"
      to: "SessionManager.compact"
      via: "manual compaction trigger"
      pattern: "ipcMain\\.handle.*session:compact"
---

<objective>
Add monitoring, events, and manual control for the compaction system.

Purpose: Enable UI visibility into compaction operations and provide manual trigger capability for debugging and user control.

Output: Event system, IPC handlers, and preload API for compaction monitoring and control.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v3.0-session-checkpoint-ROADMAP.md
@.planning/STATE.md

# Completed work from previous plan:
@.planning/phases/v3.0-02-compaction-engine/02-01-SUMMARY.md

# Relevant code:
@src/main/services/session-manager.ts
@src/main/ipc/session-handlers.ts
@src/preload/index.ts
@src/preload/index.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add compaction events and metrics to SessionManager</name>
  <files>src/main/services/session-manager.ts</files>
  <action>
Extend SessionManager to emit events and track metrics:

1. **Add event emission in compact() method:**

   At start of compact():
   ```typescript
   // Emit start event
   const windows = BrowserWindow.getAllWindows()
   for (const win of windows) {
     if (!win.isDestroyed()) {
       win.webContents.send('session:compaction-start', {
         sessionId,
         featureId: session.featureId,
         taskId: session.taskId,
         messagesCount: messages.length,
         estimatedTokens: this.estimateMessagesTokens(messages)
       })
     }
   }
   ```

   On successful compaction:
   ```typescript
   // Emit complete event
   for (const win of windows) {
     if (!win.isDestroyed()) {
       win.webContents.send('session:compaction-complete', {
         sessionId,
         featureId: session.featureId,
         taskId: session.taskId,
         messagesCompacted: messages.length,
         tokensReclaimed: estimatedTokens,
         newCheckpointVersion: newCheckpoint.version,
         compactedAt: new Date().toISOString()
       })
     }
   }
   ```

   On error:
   ```typescript
   catch (error) {
     console.error(`[SessionManager] Compaction failed for ${sessionId}:`, error)
     for (const win of windows) {
       if (!win.isDestroyed()) {
         win.webContents.send('session:compaction-error', {
           sessionId,
           error: error.message
         })
       }
     }
     // Don't throw - allow session to continue
   }
   ```

2. **Add metrics getter:**
   ```typescript
   /**
    * Get compaction metrics for a session.
    */
   async getCompactionMetrics(sessionId: string, featureId: string): Promise<{
     totalCompactions: number
     totalMessagesCompacted: number
     totalTokens: number
     lastCompactionAt?: string
   } | null> {
     const session = await this.getSessionById(sessionId, featureId)
     if (!session) return null

     const checkpoint = await this.loadCheckpoint(session)
     if (!checkpoint) return null

     return {
       totalCompactions: checkpoint.stats.totalCompactions,
       totalMessagesCompacted: checkpoint.stats.totalMessages,
       totalTokens: checkpoint.stats.totalTokens,
       lastCompactionAt: checkpoint.compactionInfo.compactedAt
     }
   }
   ```

3. **Add manual compaction trigger:**
   ```typescript
   /**
    * Manually trigger compaction for a session.
    * Useful for testing or user-initiated compaction.
    */
   async forceCompact(sessionId: string, featureId: string): Promise<void> {
     const session = await this.getSessionById(sessionId, featureId)
     if (!session) {
       throw new Error(`Session not found: ${sessionId}`)
     }

     await this.compact(sessionId)
   }
   ```

Import BrowserWindow from 'electron' at top of file.
  </action>
  <verify>
- TypeScript compilation succeeds
- Events emitted during compaction (start, complete, error)
- getCompactionMetrics returns correct data
- forceCompact successfully triggers compaction
  </verify>
  <done>
- Compaction lifecycle events broadcast to renderer
- Metrics accessible via public method
- Manual compaction works
  </done>
</task>

<task type="auto">
  <name>Task 2: Add IPC handlers and preload API for compaction</name>
  <files>src/main/ipc/session-handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Add compaction-related IPC handlers and preload API:

**1. In session-handlers.ts, add new handlers:**

```typescript
/**
 * Get compaction metrics for a session.
 */
ipcMain.handle(
  'session:getMetrics',
  async (
    _event,
    projectRoot: string,
    sessionId: string,
    featureId: string
  ): Promise<any> => {
    const manager = getSessionManager(projectRoot)
    return await manager.getCompactionMetrics(sessionId, featureId)
  }
)

/**
 * Manually trigger compaction for a session.
 */
ipcMain.handle(
  'session:forceCompact',
  async (
    _event,
    projectRoot: string,
    sessionId: string,
    featureId: string
  ): Promise<void> => {
    const manager = getSessionManager(projectRoot)
    await manager.forceCompact(sessionId, featureId)
  }
)
```

**2. In preload/index.d.ts, extend SessionAPI interface:**

```typescript
export interface SessionAPI {
  // ... existing methods ...

  /**
   * Get compaction metrics for a session
   */
  getMetrics: (
    projectRoot: string,
    sessionId: string,
    featureId: string
  ) => Promise<{
    totalCompactions: number
    totalMessagesCompacted: number
    totalTokens: number
    lastCompactionAt?: string
  } | null>

  /**
   * Manually trigger compaction for a session
   */
  forceCompact: (
    projectRoot: string,
    sessionId: string,
    featureId: string
  ) => Promise<void>

  /**
   * Subscribe to compaction start events
   */
  onCompactionStart: (callback: (data: {
    sessionId: string
    featureId: string
    taskId?: string
    messagesCount: number
    estimatedTokens: number
  }) => void) => () => void

  /**
   * Subscribe to compaction complete events
   */
  onCompactionComplete: (callback: (data: {
    sessionId: string
    featureId: string
    taskId?: string
    messagesCompacted: number
    tokensReclaimed: number
    newCheckpointVersion: number
    compactedAt: string
  }) => void) => () => void

  /**
   * Subscribe to compaction error events
   */
  onCompactionError: (callback: (data: {
    sessionId: string
    error: string
  }) => void) => () => void
}
```

**3. In preload/index.ts, add implementations in session object:**

```typescript
session: {
  // ... existing methods ...

  getMetrics: (projectRoot: string, sessionId: string, featureId: string): Promise<any> =>
    ipcRenderer.invoke('session:getMetrics', projectRoot, sessionId, featureId),

  forceCompact: (projectRoot: string, sessionId: string, featureId: string): Promise<void> =>
    ipcRenderer.invoke('session:forceCompact', projectRoot, sessionId, featureId),

  onCompactionStart: (callback: (data: any) => void): (() => void) => {
    const handler = (_event: Electron.IpcRendererEvent, data: any): void => callback(data)
    ipcRenderer.on('session:compaction-start', handler)
    return () => ipcRenderer.removeListener('session:compaction-start', handler)
  },

  onCompactionComplete: (callback: (data: any) => void): (() => void) => {
    const handler = (_event: Electron.IpcRendererEvent, data: any): void => callback(data)
    ipcRenderer.on('session:compaction-complete', handler)
    return () => ipcRenderer.removeListener('session:compaction-complete', handler)
  },

  onCompactionError: (callback: (data: any) => void): (() => void) => {
    const handler = (_event: Electron.IpcRendererEvent, data: any): void => callback(data)
    ipcRenderer.on('session:compaction-error', handler)
    return () => ipcRenderer.removeListener('session:compaction-error', handler)
  }
}
```

Ensure proper TypeScript types and error handling throughout.
  </action>
  <verify>
- TypeScript compilation succeeds
- All IPC handlers registered correctly
- Preload API exposes all new methods and events
- Type definitions match implementations
  </verify>
  <done>
- IPC handlers work for getMetrics and forceCompact
- Preload API provides type-safe access to compaction features
- Event listeners can be registered and unregistered
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript builds without errors
- [ ] All IPC handlers registered in session-handlers.ts
- [ ] Preload API fully typed and implemented
- [ ] Event system works (start, complete, error events)
- [ ] Manual test: Subscribe to events in renderer, trigger compaction, verify events received
- [ ] Manual test: Call getMetrics, verify correct data returned
</verification>

<success_criteria>
- All tasks completed
- Compaction events broadcast successfully
- Metrics tracking accurate
- Manual compaction works via IPC
- UI can monitor compaction operations
- No breaking changes to Phase 1 functionality
</success_criteria>

<output>
After completion, create `.planning/phases/v3.0-02-compaction-engine/02-02-SUMMARY.md`
</output>
