---
phase: v3.0-02-compaction-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/services/session-manager.ts
  - src/main/services/compaction-prompts.ts
autonomous: true

must_haves:
  truths:
    - "Session automatically compacts when total tokens exceed 90k"
    - "Compaction creates updated checkpoint from old checkpoint + messages"
    - "Messages are cleared after successful compaction"
    - "Compaction preserves key information (completed, pending, decisions, blockers)"
  artifacts:
    - path: "src/main/services/compaction-prompts.ts"
      provides: "Compaction prompt generation for Claude"
      exports: ["buildCompactionPrompt", "parseCompactionResult"]
    - path: "src/main/services/session-manager.ts"
      provides: "Compaction logic in SessionManager"
      contains: "private async compact"
  key_links:
    - from: "SessionManager.addMessage"
      to: "SessionManager.checkAndCompact"
      via: "automatic check after adding message"
      pattern: "await.*checkAndCompact"
    - from: "SessionManager.compact"
      to: "buildCompactionPrompt"
      via: "generates prompt for Claude"
      pattern: "buildCompactionPrompt"
---

<objective>
Implement automatic checkpoint compaction engine that prevents token limit overflow.

Purpose: Enable unlimited conversation length by automatically compressing old messages into checkpoint summaries when approaching the 100k token limit.

Output: Working compaction system integrated into SessionManager with prompt generation and execution logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v3.0-session-checkpoint-ROADMAP.md
@.planning/STATE.md

# Relevant code from Phase 1:
@src/main/services/session-manager.ts
@src/main/services/token-estimator.ts
@src/shared/types/session.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compaction prompt builder</name>
  <files>src/main/services/compaction-prompts.ts</files>
  <action>
Create a new file for compaction prompt generation with two main functions:

1. `buildCompactionPrompt(checkpoint: Checkpoint | null, messages: ChatMessage[]): string`
   - Takes existing checkpoint (or null for first compaction) and message history
   - Returns a clear system prompt for Claude to compact the conversation
   - Prompt structure:
     ```
     You are compacting a conversation history into a checkpoint summary.

     Current Checkpoint (if exists):
     - Completed: [list]
     - In Progress: [list]
     - Pending: [list]
     - Blockers: [list]
     - Decisions: [list]

     New Messages to Incorporate:
     [message 1]
     [message 2]
     ...

     Task: Create updated checkpoint summary that:
     1. Merges new information from messages into existing checkpoint
     2. Updates completed/pending/in_progress lists
     3. Captures new decisions and blockers
     4. Removes obsolete/resolved items
     5. Maintains chronological order

     Output format: JSON matching Checkpoint.summary structure
     ```

2. `parseCompactionResult(response: string): Checkpoint['summary']`
   - Parses Claude's response (JSON)
   - Validates structure matches Checkpoint.summary interface
   - Handles malformed responses with helpful error messages
   - Returns validated summary object

Include comprehensive error handling for:
- Empty messages array
- Null checkpoint on first compaction
- Malformed JSON responses
- Missing required fields

Export both functions.
  </action>
  <verify>
- TypeScript compilation succeeds
- Functions exported from module
- JSDoc comments present for both functions
- Error handling covers edge cases
  </verify>
  <done>
- buildCompactionPrompt generates clear, structured prompts
- parseCompactionResult handles valid and invalid inputs
- All exports available for import
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement compaction logic in SessionManager</name>
  <files>src/main/services/session-manager.ts</files>
  <action>
Add compaction methods to SessionManager class (after existing methods):

1. `private async compact(sessionId: string): Promise<void>`
   - Loads current session, chat, and checkpoint
   - Calls buildCompactionPrompt() with checkpoint + messages
   - Uses AgentService to send compaction request to Claude
   - Parses response with parseCompactionResult()
   - Creates new Checkpoint with updated summary
   - Updates checkpoint metadata:
     - version++
     - updatedAt = now
     - compactionInfo.messagesCompacted = messages.length
     - compactionInfo.oldestMessageTimestamp = messages[0].timestamp
     - compactionInfo.newestMessageTimestamp = messages[last].timestamp
     - compactionInfo.compactedAt = now
     - stats.totalCompactions++
     - stats.totalMessages += messages.length
   - Clears all messages from ChatSession (messages = [])
   - Saves updated checkpoint and empty chat session
   - Logs success: `[SessionManager] Compacted ${messagesCompacted} messages for session ${sessionId}`

2. `private async checkAndCompact(sessionId: string): Promise<void>`
   - Estimates total request size using estimateRequest()
   - If total > 90,000 tokens (90% of 100k limit):
     - Calls compact(sessionId)
   - Otherwise does nothing
   - Add guard: if currently compacting this session, skip (prevent recursion)

3. Update `addMessage()` to call checkAndCompact after saving:
   ```typescript
   await this.saveSession(session)
   await this.saveChatSession(session, chatSession)

   // Check if compaction needed
   await this.checkAndCompact(sessionId)

   return fullMessage
   ```

Error handling:
- Wrap compaction in try-catch
- On failure, log error but don't throw (allow app to continue)
- Consider: Set flag to retry compaction on next message?
- Prevent infinite compaction loops (compaction_in_progress flag)

Import buildCompactionPrompt and parseCompactionResult from compaction-prompts.ts
  </action>
  <verify>
- TypeScript compilation succeeds
- compact() method creates valid checkpoints
- checkAndCompact() triggers at 90k tokens
- addMessage() calls checkAndCompact()
- Error handling prevents crashes
- No infinite loops possible
  </verify>
  <done>
- Compaction automatically triggers when approaching token limit
- Messages successfully cleared after compaction
- Checkpoint contains merged summary
- Session continues working after compaction
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript builds without errors
- [ ] No import errors for compaction-prompts
- [ ] SessionManager has compact, checkAndCompact, and updated addMessage methods
- [ ] Code review: compaction logic is sound
- [ ] Manual test: Add 100+ messages to a session, verify compaction triggers
</verification>

<success_criteria>
- All tasks completed
- Compaction system integrated into SessionManager
- Automatic triggering works at 90k token threshold
- No breaking changes to existing Phase 1 functionality
- Code is well-documented with clear comments
</success_criteria>

<output>
After completion, create `.planning/phases/v3.0-02-compaction-engine/02-01-SUMMARY.md`
</output>
