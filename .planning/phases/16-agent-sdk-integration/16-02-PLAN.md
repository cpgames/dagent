# Phase 16 Plan 02: Replace ChatService with Agent SDK

**Objective**: Wire IPC handlers to use AgentService for chat, stream responses to renderer

## Context

### Current State
- AgentService wrapper exists (from 16-01)
- `chat:send` IPC handler calls `ChatService.sendMessage()`
- ChatService uses raw Anthropic SDK with manual auth
- Response is returned as single complete message (non-streaming)

### Required Changes
1. Add new IPC handler for agent streaming (`agent:query`)
2. Update preload bridge with agent API
3. Modify chat-store to use streaming responses
4. Update FeatureChat UI to show streaming progress

## Dependencies

- Requires: 16-01 (AgentService exists)
- Provides: Streaming agent chat integration

## Tasks

### Task 1: Add IPC handlers for agent service

Create handlers for starting agent query and receiving stream events.

**Files to create:**
- `src/main/ipc/agent-handlers.ts`

**Files to modify:**
- `src/main/ipc/handlers.ts` - Register agent handlers

**Implementation:**
```typescript
// src/main/ipc/agent-handlers.ts
import { ipcMain, type BrowserWindow } from 'electron'
import { getAgentService, type AgentQueryOptions, type AgentStreamEvent } from '../agent'

export function registerAgentHandlers(mainWindow: BrowserWindow): void {
  // Start a streaming agent query
  ipcMain.handle('agent:query', async (_event, options: AgentQueryOptions): Promise<void> => {
    const service = getAgentService()

    try {
      for await (const event of service.streamQuery(options)) {
        // Send each event to renderer
        mainWindow.webContents.send('agent:stream', event)
      }
    } catch (error) {
      mainWindow.webContents.send('agent:stream', {
        type: 'error',
        error: error instanceof Error ? error.message : 'Agent query failed'
      } as AgentStreamEvent)
    }
  })

  // Abort current agent query
  ipcMain.handle('agent:abort', async (): Promise<void> => {
    const service = getAgentService()
    service.abort()
  })
}
```

**In handlers.ts:**
```typescript
import { registerAgentHandlers } from './agent-handlers'

export function registerHandlers(mainWindow: BrowserWindow): void {
  // ... existing handlers
  registerAgentHandlers(mainWindow)
}
```

**Verification:**
- `agent:query` starts streaming to renderer
- `agent:abort` cancels active query
- Events sent via `agent:stream` channel

### Task 2: Update preload bridge with agent API

Expose agent IPC methods to renderer process.

**Files to modify:**
- `src/preload/index.ts` - Add agent methods
- `src/preload/index.d.ts` - Add AgentAPI types

**Implementation:**
```typescript
// In index.d.ts
import type { AgentQueryOptions, AgentStreamEvent } from '../main/agent'

export interface AgentAPI {
  query: (options: AgentQueryOptions) => Promise<void>
  abort: () => Promise<void>
  onStream: (callback: (event: AgentStreamEvent) => void) => () => void
}

// Add to ElectronAPI interface
agent: AgentAPI

// In index.ts
agent: {
  query: (options) => ipcRenderer.invoke('agent:query', options),
  abort: () => ipcRenderer.invoke('agent:abort'),
  onStream: (callback) => {
    const handler = (_event, data) => callback(data)
    ipcRenderer.on('agent:stream', handler)
    return () => ipcRenderer.removeListener('agent:stream', handler)
  }
}
```

**Verification:**
- `window.electronAPI.agent.query()` starts query
- `window.electronAPI.agent.onStream()` receives events
- `window.electronAPI.agent.abort()` cancels query

### Task 3: Add agent types to shared types

Export agent types for renderer access.

**Files to modify:**
- `src/shared/types/index.ts`

**Implementation:**
```typescript
// Add to shared types or re-export
export type AgentMessageType = 'assistant' | 'user' | 'result' | 'system'

export interface AgentMessage {
  type: AgentMessageType
  content: string
  timestamp: string
  toolName?: string
  toolInput?: unknown
}

export interface AgentQueryOptions {
  prompt: string
  systemPrompt?: string
  allowedTools?: string[]
  permissionMode?: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan'
  cwd?: string
}

export interface AgentStreamEvent {
  type: 'message' | 'tool_use' | 'tool_result' | 'done' | 'error'
  message?: AgentMessage
  error?: string
}
```

**Verification:**
- Types importable from `@shared/types`
- Renderer can use types without path issues

### Task 4: Update chat-store to use agent streaming

Replace sendToAI with streaming agent query.

**Files to modify:**
- `src/renderer/src/stores/chat-store.ts`

**Changes:**
1. Add `streamingContent` state for partial response
2. Replace `sendToAI()` with `sendToAgent()`
3. Subscribe to stream events and build response
4. Handle tool usage display

**Implementation:**
```typescript
interface ChatState {
  messages: ChatMessage[]
  isLoading: boolean
  isResponding: boolean
  streamingContent: string  // Partial response being built
  currentFeatureId: string | null

  loadChat: (featureId: string) => Promise<void>
  addMessage: (message: Omit<ChatMessage, 'id' | 'timestamp'>) => void
  sendToAgent: () => Promise<void>  // Replaces sendToAI
  abortAgent: () => void
  clearChat: () => void
}

// In the store:
sendToAgent: async () => {
  const { messages, currentFeatureId } = get()
  if (!currentFeatureId || messages.length === 0) return

  set({ isResponding: true, streamingContent: '' })

  // Build prompt from message history
  const prompt = messages.map(m =>
    `${m.role === 'user' ? 'User' : 'Assistant'}: ${m.content}`
  ).join('\n\n')

  // Subscribe to stream events
  const unsubscribe = window.electronAPI.agent.onStream((event) => {
    if (event.type === 'message' && event.message) {
      // Accumulate content
      set((state) => ({
        streamingContent: state.streamingContent + event.message!.content
      }))
    } else if (event.type === 'tool_use' && event.message) {
      // Show tool usage in chat
      set((state) => ({
        streamingContent: state.streamingContent + `\n[Using ${event.message!.toolName}...]\n`
      }))
    } else if (event.type === 'done') {
      // Finalize response
      const { streamingContent, currentFeatureId: featId } = get()
      if (streamingContent && featId) {
        const assistantMessage: ChatMessage = {
          id: crypto.randomUUID(),
          role: 'assistant',
          content: streamingContent,
          timestamp: new Date().toISOString()
        }
        set((state) => ({
          messages: [...state.messages, assistantMessage],
          isResponding: false,
          streamingContent: ''
        }))

        // Persist
        const { messages: updated } = get()
        window.electronAPI.storage.saveChat(featId, {
          entries: updated.map(m => ({
            role: m.role,
            content: m.content,
            timestamp: m.timestamp
          }))
        })
      }
      unsubscribe()
    } else if (event.type === 'error') {
      set({ isResponding: false, streamingContent: '' })
      console.error('Agent error:', event.error)
      unsubscribe()
    }
  })

  // Start agent query
  try {
    await window.electronAPI.agent.query({
      prompt,
      allowedTools: [],  // No tools for basic chat
      permissionMode: 'default'
    })
  } catch (error) {
    set({ isResponding: false, streamingContent: '' })
    unsubscribe()
  }
},

abortAgent: () => {
  window.electronAPI.agent.abort()
  set({ isResponding: false, streamingContent: '' })
}
```

**Verification:**
- Streaming content accumulates during response
- Final message added when done
- Abort cancels and clears state
- Errors handled gracefully

### Task 5: Update FeatureChat UI for streaming

Show streaming response and abort button.

**Files to modify:**
- `src/renderer/src/components/Chat/FeatureChat.tsx`

**Changes:**
1. Display `streamingContent` as it builds
2. Add abort button during response
3. Update handleSend to call `sendToAgent()`

**Implementation:**
```tsx
const {
  messages,
  loadChat,
  addMessage,
  sendToAgent,
  abortAgent,
  isLoading,
  isResponding,
  streamingContent
} = useChatStore()

const handleSend = useCallback(async () => {
  const trimmedValue = inputValue.trim()
  if (!trimmedValue) return

  addMessage({
    role: 'user',
    content: trimmedValue
  })
  setInputValue('')

  await sendToAgent()
}, [inputValue, addMessage, sendToAgent])

// In JSX - show streaming content
{streamingContent && (
  <div className="bg-gray-800 rounded-lg p-3">
    <div className="text-sm text-gray-400 mb-1">Assistant</div>
    <div className="text-gray-200 whitespace-pre-wrap">{streamingContent}</div>
    <span className="animate-pulse">â–Œ</span>
  </div>
)}

{isResponding && (
  <button
    onClick={abortAgent}
    className="text-red-400 text-sm hover:text-red-300"
  >
    Stop generating
  </button>
)}
```

**Verification:**
- Streaming content shows with cursor
- Stop button visible during response
- Final message replaces streaming content
- UI responsive during streaming

## Verification Checklist

- [ ] `agent:query` IPC handler starts streaming
- [ ] `agent:stream` events received in renderer
- [ ] `agent:abort` cancels active query
- [ ] Preload bridge exposes all agent methods
- [ ] Chat store handles streaming events
- [ ] FeatureChat shows streaming response
- [ ] Stop button aborts generation
- [ ] Final response persisted to storage

## Files Summary

| File | Action | Purpose |
|------|--------|---------|
| `src/main/ipc/agent-handlers.ts` | Create | IPC handlers for agent |
| `src/main/ipc/handlers.ts` | Modify | Register agent handlers |
| `src/preload/index.ts` | Modify | Add agent bridge methods |
| `src/preload/index.d.ts` | Modify | AgentAPI types |
| `src/shared/types/index.ts` | Modify | Export agent types |
| `src/renderer/src/stores/chat-store.ts` | Modify | Streaming agent integration |
| `src/renderer/src/components/Chat/FeatureChat.tsx` | Modify | Streaming UI |

## Estimated Tasks: 5

## Notes

- ChatService remains available as fallback
- Agent SDK handles authentication automatically
- No API key required if Claude Code is authenticated
- Tool usage shown inline in chat

---
*Phase: 16-agent-sdk-integration*
*Plan: 02 of 03*
