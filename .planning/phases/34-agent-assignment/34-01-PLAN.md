---
phase: 34-agent-assignment
plan: 01
type: execute
---

<objective>
Implement automatic agent assignment to ready tasks during execution loop.

Purpose: When the execution loop identifies ready tasks, automatically spawn task agents and assign them to work on those tasks.
Output: Working agent assignment that starts task agents for available work.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v1.8-ROADMAP.md

# Prior phase context:
@.planning/phases/33-execution-orchestration/33-01-SUMMARY.md
@.planning/phases/05-agent-system/05-03-SUMMARY.md

# Key source files:
@src/main/dag-engine/orchestrator.ts
@src/main/dag-engine/orchestrator-types.ts
@src/main/agents/task-agent.ts
@src/main/agents/agent-pool.ts
@src/main/ipc/task-agent-handlers.ts

**Tech stack available:** Electron, TypeScript, existing TaskAgent, AgentPool
**Established patterns:** Singleton orchestrator, task agent creation via createTaskAgent()

**Constraining decisions:**
- Phase 33-01: Execution loop runs 1-second ticks, calls getNextTasks() which returns { available, canAssign }
- Phase 05-03: TaskAgent.initialize() handles pool registration, harness registration, worktree creation
- DAGENT_SPEC 6.3: "Assign available agents (random if more tasks than agents)"

**Key insight from existing code:**
- `tick()` already calls `getNextTasks()` but doesn't assign agents
- `createTaskAgent()` exists in agents/index.ts and handles full initialization
- Need to: create agents for available tasks up to canAssign limit
- Task status transitions ready → running when assigned via `assignTask()`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add agent assignment to execution tick loop</name>
  <files>src/main/dag-engine/orchestrator.ts</files>
  <action>
Modify the `tick()` method to automatically assign agents to available tasks:

1. After getting `{ available, canAssign }` from `getNextTasks()`, add assignment logic:
   ```typescript
   // Assign agents to available tasks
   if (available.length > 0 && canAssign > 0) {
     const tasksToAssign = available.slice(0, canAssign)
     for (const task of tasksToAssign) {
       await this.assignAgentToTask(task)
     }
   }
   ```

2. Add new async method `private async assignAgentToTask(task: Task): Promise<void>`:
   - Import required dependencies at top of file:
     ```typescript
     import { createTaskAgent, registerTaskAgent } from '../agents'
     import { loadClaudeMd } from '../storage'
     import { loadFeature } from '../storage'
     ```
   - Get feature goal from feature storage
   - Load CLAUDE.md content if available
   - Create task agent: `const agent = createTaskAgent(this.state.featureId!, task.id)`
   - Initialize agent: `await agent.initialize(task, this.state.graph!, claudeMd, featureGoal)`
   - Register agent: `registerTaskAgent(agent)`
   - Call existing `assignTask(task.id, agent.getState().agentId)` to update orchestrator state
   - Log assignment: `console.log('[Orchestrator] Assigned agent to task:', task.id)`
   - Add 'agent_assigned' event

3. Make `tick()` async since it now awaits assignAgentToTask

4. Update the setInterval call in `startLoop()` to handle async tick:
   ```typescript
   this.loopInterval = setInterval(() => {
     this.tick().catch(err => console.error('[Orchestrator] tick error:', err))
   }, this.TICK_INTERVAL_MS)
   ```

5. Add 'agent_assigned' to ExecutionEvent type in orchestrator-types.ts:
   - Add to type union: `| 'agent_assigned'`
   - Add to data: `agentId?: string`

IMPORTANT: Do NOT start task execution yet - that's Phase 35. This plan just assigns agents.
  </action>
  <verify>
npm run typecheck passes. Start execution on a feature with ready tasks - see agent assignment logs.
  </verify>
  <done>
- tick() identifies available tasks and assigns agents up to canAssign limit
- TaskAgent instances created and registered for each assignment
- Task status transitions ready → running
- 'agent_assigned' events emitted
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add feature/CLAUDE.md loading for agent context</name>
  <files>src/main/dag-engine/orchestrator.ts, src/main/storage/index.ts</files>
  <action>
Ensure agent context loading is robust:

1. In orchestrator.ts `assignAgentToTask()`, handle missing feature/claudeMd gracefully:
   ```typescript
   private async assignAgentToTask(task: Task): Promise<void> {
     if (!this.state.featureId || !this.state.graph) {
       console.error('[Orchestrator] Cannot assign: no feature/graph')
       return
     }

     try {
       // Load feature for goal
       const feature = await loadFeature(this.state.featureId)
       const featureGoal = feature?.name || 'Complete tasks'

       // Load CLAUDE.md (may not exist)
       let claudeMd: string | undefined
       try {
         claudeMd = await loadClaudeMd()
       } catch {
         // CLAUDE.md not found - that's OK
       }

       // Create and initialize task agent
       const agent = createTaskAgent(this.state.featureId, task.id)
       const initialized = await agent.initialize(task, this.state.graph, claudeMd, featureGoal)

       if (!initialized) {
         console.error('[Orchestrator] Failed to initialize agent for task:', task.id)
         return
       }

       registerTaskAgent(agent)

       // Update orchestrator state
       const result = this.assignTask(task.id, agent.getState().agentId)
       if (result.success) {
         console.log('[Orchestrator] Assigned agent to task:', task.id, 'agent:', agent.getState().agentId)
         this.addEvent('agent_assigned', { taskId: task.id, agentId: agent.getState().agentId })
       } else {
         console.error('[Orchestrator] Failed to assign task:', result.error)
       }
     } catch (error) {
       console.error('[Orchestrator] Error assigning agent:', error)
     }
   }
   ```

2. Check if `loadClaudeMd` exists in storage/index.ts. If not, add it:
   ```typescript
   export async function loadClaudeMd(): Promise<string | undefined> {
     const projectRoot = getProjectRoot()
     const claudePath = path.join(projectRoot, 'CLAUDE.md')
     try {
       return await fs.readFile(claudePath, 'utf-8')
     } catch {
       return undefined
     }
   }
   ```

3. Ensure loadFeature is exported from storage/index.ts (likely already is)
  </action>
  <verify>
npm run typecheck passes. Execution with a project that has CLAUDE.md uses it; projects without CLAUDE.md work fine.
  </verify>
  <done>
- Agent context loading handles missing CLAUDE.md gracefully
- Feature goal extracted from feature name
- Errors during assignment are logged but don't crash the loop
- No TypeScript errors
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] `npm run build` completes successfully
- [ ] Start execution on a feature with ready tasks
- [ ] See "[Orchestrator] Assigned agent to task:" logs for each ready task
- [ ] Task status changes from 'ready' to 'running' after assignment
- [ ] Agent appears in agent pool (check via getSnapshot)
- [ ] Stop execution works (loop stops, no more assignments)
</verification>

<success_criteria>
- Execution loop automatically assigns agents to ready tasks
- Task agents created with proper context (feature, graph, CLAUDE.md)
- Task status transitions ready → running on assignment
- Respects maxConcurrentTasks limit (canAssign)
- No errors when CLAUDE.md is missing
- No TypeScript errors or runtime errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-agent-assignment/34-01-SUMMARY.md`
</output>
