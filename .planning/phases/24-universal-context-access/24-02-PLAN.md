---
phase: 24-universal-context-access
plan: 02
type: execute
---

<objective>
Integrate ContextService into all agent system prompts so every agent has automatic codebase/project awareness.

Purpose: All agents (PM, Harness, Developer/Task, Merge) receive comprehensive context automatically without manual context refresh.
Output: Enhanced system prompts for all agent presets with project context baked in.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-universal-context-access/24-01-SUMMARY.md (will exist)

**Key files:**
@src/main/context/context-service.ts - ContextService from Plan 24-01
@src/main/agent/agent-service.ts - AgentService.streamQuery() accepts systemPrompt
@src/main/agent/tool-config.ts - Tool presets (pmAgent, taskAgent, harnessAgent, mergeAgent)
@src/main/chat/context-builder.ts - Current buildSystemPrompt() for feature chat
@src/main/ipc/chat-handlers.ts - chat:getContext handler
@src/main/ipc/sdk-agent-handlers.ts - sdk-agent:query handler
@src/renderer/src/stores/chat-store.ts - sendToAgent() builds prompt from messages

**Established patterns:**
- Tool presets define allowed tools per agent type
- System prompts built per-context and passed to AgentService
- PM tool instructions added via getPMToolInstructions()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance chat:getContext to use ContextService</name>
  <files>src/main/ipc/chat-handlers.ts</files>
  <action>
Update chat:getContext to use the new ContextService for richer context:

1. Import { getContextService } from './context-handlers'

2. In `chat:getContext` handler:
   - Get ContextService instance
   - Call `contextService.buildFullContext({ featureId, includeGitHistory: true, includeClaudeMd: true })`
   - Call `contextService.formatContextAsPrompt(fullContext)` to get enhanced system prompt
   - Return both the structured context and the formatted prompt

3. Fall back to existing buildSystemPrompt() if ContextService not initialized (e.g., no project open).

This automatically upgrades Feature Chat with project context.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>chat:getContext returns enhanced context with project/codebase information</done>
</task>

<task type="auto">
  <name>Task 2: Create agent-specific prompt builders</name>
  <files>src/main/agent/prompt-builders.ts (new)</files>
  <action>
Create prompt builder functions for each agent type:

1. Create `src/main/agent/prompt-builders.ts`:
   ```typescript
   import { getContextService } from '../ipc/context-handlers'
   import { getPMToolInstructions } from './pm-tool-handlers'

   export interface AgentPromptOptions {
     featureId?: string
     taskId?: string
     agentType: 'pm' | 'harness' | 'task' | 'merge'
   }

   export async function buildAgentPrompt(options: AgentPromptOptions): Promise<string> {
     const contextService = getContextService()
     if (!contextService) {
       return getBasicPrompt(options.agentType)
     }

     const fullContext = await contextService.buildFullContext({
       featureId: options.featureId,
       taskId: options.taskId,
       includeGitHistory: true,
       includeClaudeMd: true
     })

     const contextSection = contextService.formatContextAsPrompt(fullContext)
     const roleSection = getAgentRoleInstructions(options.agentType)
     const toolSection = options.agentType === 'pm' ? getPMToolInstructions() : ''

     return `${roleSection}\n\n${contextSection}\n\n${toolSection}`.trim()
   }

   function getAgentRoleInstructions(agentType: string): string {
     switch (agentType) {
       case 'pm':
         return `You are a PM Agent helping manage tasks for a software feature.
Your role is to create, update, and organize tasks based on user requests.
Use the tools available to manage the task DAG (Directed Acyclic Graph).
Always list existing tasks before creating new ones to understand dependencies.`

       case 'harness':
         return `You are a Harness Agent reviewing task intentions before execution.
Your role is to evaluate if a task's planned approach is sound and approve or suggest changes.
Consider dependencies, potential conflicts, and best practices.`

       case 'task':
         return `You are a Task Agent executing implementation work.
Your role is to complete the assigned task by writing code, running commands, and making changes.
Work within your assigned worktree and commit your changes when complete.`

       case 'merge':
         return `You are a Merge Agent handling branch integration.
Your role is to merge completed task branches, resolve conflicts, and ensure clean integration.
Analyze conflicts carefully and preserve intended changes from both sides.`

       default:
         return 'You are an AI assistant helping with software development.'
     }
   }

   function getBasicPrompt(agentType: string): string {
     return getAgentRoleInstructions(agentType)
   }
   ```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>prompt-builders.ts exports buildAgentPrompt() with role-specific instructions + context</done>
</task>

<task type="auto">
  <name>Task 3: Add context-aware query method to AgentService</name>
  <files>src/main/agent/agent-service.ts, src/main/agent/types.ts</files>
  <action>
Add a higher-level query method that auto-injects context:

1. Update `types.ts` - extend AgentQueryOptions:
   ```typescript
   export interface AgentQueryOptions {
     prompt: string
     systemPrompt?: string
     allowedTools?: string[]
     toolPreset?: ToolPreset
     permissionMode?: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan'
     cwd?: string
     // New context options
     featureId?: string
     taskId?: string
     agentType?: 'pm' | 'harness' | 'task' | 'merge'
     autoContext?: boolean  // If true, auto-build context prompt
   }
   ```

2. Update `agent-service.ts` streamQuery():
   - At the start, if options.autoContext is true and options.agentType is set:
     - Import { buildAgentPrompt } from './prompt-builders'
     - Call `await buildAgentPrompt({ featureId: options.featureId, taskId: options.taskId, agentType: options.agentType })`
     - Use result as systemPrompt (override any provided systemPrompt)
   - Otherwise, use options.systemPrompt as before
  </action>
  <verify>npm run typecheck passes</verify>
  <done>AgentService.streamQuery supports autoContext option for automatic context injection</done>
</task>

<task type="auto">
  <name>Task 4: Update chat store to use autoContext</name>
  <files>src/renderer/src/stores/chat-store.ts</files>
  <action>
Update sendToAgent() to use the new autoContext feature:

1. In sendToAgent(), update the query call:
   ```typescript
   await window.electronAPI.sdkAgent.query({
     prompt,
     // Remove systemPrompt - let autoContext handle it
     toolPreset: 'pmAgent',
     permissionMode: 'acceptEdits',
     cwd: projectRoot,
     // Add new context options
     featureId: currentFeatureId,
     agentType: 'pm',
     autoContext: true
   })
   ```

2. Remove the manual systemPrompt from the options since context is now auto-generated.

3. Keep the local systemPrompt state for backward compatibility but don't send it when autoContext is enabled.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Feature Chat uses autoContext for automatic context injection</done>
</task>

<task type="auto">
  <name>Task 5: Update SDK agent handler for context options</name>
  <files>src/main/ipc/sdk-agent-handlers.ts, src/preload/index.d.ts</files>
  <action>
1. Update `sdk-agent-handlers.ts`:
   - The handler already passes options directly to AgentService
   - No changes needed to handler itself
   - But verify the options are correctly typed

2. Update `preload/index.d.ts` - extend AgentQueryOptions type:
   ```typescript
   export interface AgentQueryOptions {
     prompt: string
     systemPrompt?: string
     allowedTools?: string[]
     toolPreset?: 'featureChat' | 'taskAgent' | 'harnessAgent' | 'mergeAgent' | 'pmAgent' | 'none'
     permissionMode?: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan'
     cwd?: string
     // Context options
     featureId?: string
     taskId?: string
     agentType?: 'pm' | 'harness' | 'task' | 'merge'
     autoContext?: boolean
   }
   ```

3. Ensure types are exported and available to renderer.
  </action>
  <verify>npm run build succeeds</verify>
  <done>AgentQueryOptions includes context fields, types exported to renderer</done>
</task>

<task type="auto">
  <name>Task 6: Verify and test full context flow</name>
  <files>None (verification only)</files>
  <action>
Run full build and verify the context flow works:

1. Run `npm run build` to ensure no TypeScript errors

2. Verify the flow:
   - User opens project → ContextService initialized
   - User selects feature → Feature context available
   - User sends chat message → sendToAgent() called with autoContext: true
   - AgentService calls buildAgentPrompt() → Full context assembled
   - Agent receives rich system prompt with project structure, CLAUDE.md, git history, feature/task info

3. Check that all agent types can receive context:
   - PM Agent (via Feature Chat)
   - Harness Agent (via task execution flow)
   - Task Agent (via task execution)
   - Merge Agent (via merge operations)
  </action>
  <verify>npm run build succeeds, application starts without errors</verify>
  <done>Full context flow verified end-to-end</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] chat:getContext returns enhanced context with project info
- [ ] buildAgentPrompt() generates role-specific prompts with context
- [ ] AgentService.streamQuery() supports autoContext option
- [ ] Feature Chat sends autoContext: true in agent queries
- [ ] PM Agent receives full project context in system prompt
- [ ] Types correctly exported in preload
- [ ] Application runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- All agents automatically receive project/codebase context
- Context includes: project structure, CLAUDE.md, git history, feature/task info
- No manual "refresh context" needed
- Phase 24 complete - v1.4 milestone achieved
</success_criteria>

<output>
After completion, create `.planning/phases/24-universal-context-access/24-02-SUMMARY.md` with:
- Phase 24 Plan 02 summary
- Accomplishments (context integration, agent prompts, autoContext)
- Files created/modified
- Decisions made
- Issues encountered
- v1.4 Milestone Summary (all phases complete)
</output>
