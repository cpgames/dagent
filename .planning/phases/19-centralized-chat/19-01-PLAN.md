---
phase: 19-centralized-chat
plan: 01
type: execute
---

<objective>
Create a reusable ChatPanel component that can be used across feature chat, task chat, and agent intercommunication.

Purpose: Centralize chat UI into a single, configurable component with consistent behavior across all agent contexts.
Output: ChatPanel component with agent name header, clear button, and automatic context loading.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v1.4-ROADMAP.md

**Prior summaries:**
@.planning/phases/13-feature-chat/13-01-SUMMARY.md
@.planning/phases/17-agent-tools-permissions/17-02-SUMMARY.md

**Relevant source files:**
@src/renderer/src/components/Chat/FeatureChat.tsx
@src/renderer/src/components/Chat/ChatMessage.tsx
@src/renderer/src/components/Chat/ToolUsageDisplay.tsx
@src/renderer/src/stores/chat-store.ts

**Tech stack available:**
- React with TypeScript, JSX.Element return types
- Zustand for state management
- Tailwind CSS v4 for styling
- Claude Agent SDK for AI interactions

**Established patterns:**
- Components use `interface {Name}Props` for props typing
- Stores use create<StateType>((set, get) => ...) pattern
- Event handlers prefixed with `handle*`
- Async operations with toast notifications for errors

**Constraining decisions:**
- Phase 17: Tool usage display integrated into chat
- Phase 13: Chat persistence uses optimistic updates
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChatPanel component</name>
  <files>src/renderer/src/components/Chat/ChatPanel.tsx</files>
  <action>
Create a new ChatPanel component that extracts the reusable chat UI from FeatureChat:

**Props interface:**
```typescript
interface ChatPanelProps {
  agentName: string           // Display name in header (e.g., "Feature Chat", "PM Agent")
  contextId: string           // Feature or task ID for persistence
  contextType: 'feature' | 'task' | 'agent'  // Determines storage/context behavior
  onClear?: () => void        // Optional clear callback (uses store clearChat if not provided)
  className?: string          // Optional container class overrides
}
```

**Component structure:**
1. Header with agent name and clear button
2. Messages area with ChatMessage components
3. Tool usage display (ToolUsageDisplay)
4. Streaming content display with cursor
5. Stop button during responding
6. Input area with textarea and send button

**Key differences from FeatureChat:**
- Remove "Context loaded" indicator and "Refresh" button - context loads automatically
- Add agentName display in header (left side)
- Add "Clear" button in header (right side) - calls clearChat from store
- Accept contextId and contextType props instead of featureId
- Pass contextType to loadChat for different storage paths (future)

**Styling:** Keep existing dark theme (bg-gray-900, border-gray-700, etc.) but make container fill available space via flex-1.
  </action>
  <verify>File exists at src/renderer/src/components/Chat/ChatPanel.tsx with all required props and structure</verify>
  <done>ChatPanel component created with agentName, contextId, contextType, onClear, className props</done>
</task>

<task type="auto">
  <name>Task 2: Update chat-store for context types</name>
  <files>src/renderer/src/stores/chat-store.ts</files>
  <action>
Modify chat-store to support different context types and automatic context loading:

1. **Update loadChat signature:**
   - Change from `loadChat(featureId: string)` to `loadChat(contextId: string, contextType?: 'feature' | 'task' | 'agent')`
   - Default contextType to 'feature' for backward compatibility
   - Store contextType in state for persistence routing

2. **Add contextType to state:**
   - Add `contextType: 'feature' | 'task' | 'agent' | null` to ChatState interface
   - Initialize to null in default state

3. **Automatic context loading:**
   - In loadChat, automatically call getContext after loading messages
   - Remove need for separate refreshContext calls from UI
   - Keep refreshContext available but make it internal/optional

4. **Update clearChat:**
   - Also clear contextType
   - Provide a clearMessages() action that only clears messages but keeps context (for "Clear" button)

5. **Add clearMessages action:**
   - New action: `clearMessages: () => void`
   - Clears messages array but keeps currentFeatureId, contextType, systemPrompt
   - Also persists empty chat to storage
  </action>
  <verify>npm run typecheck passes, loadChat accepts contextType parameter</verify>
  <done>chat-store updated with contextType support, automatic context loading, and clearMessages action</done>
</task>

<task type="auto">
  <name>Task 3: Refactor FeatureChat to use ChatPanel</name>
  <files>src/renderer/src/components/Chat/FeatureChat.tsx</files>
  <action>
Refactor FeatureChat to be a thin wrapper around ChatPanel:

1. **Import ChatPanel:**
   - Import ChatPanel from './ChatPanel'

2. **Simplify FeatureChat:**
   - Remove all internal UI code (messages, input, etc.)
   - Keep only the featureId prop
   - Render ChatPanel with:
     - agentName="Feature Chat"
     - contextId={featureId}
     - contextType="feature"
     - className="w-80" (maintain current width)

3. **Remove unused imports:**
   - Remove direct chat-store usage (ChatPanel handles it)
   - Remove ChatMessage, ToolUsageDisplay imports (moved to ChatPanel)
   - Remove useState, useCallback, useRef, useEffect if no longer needed

4. **Keep the interface:**
   - FeatureChatProps remains { featureId: string }
   - Component signature unchanged for backward compatibility

**Result:** FeatureChat becomes ~15-20 lines, delegating all UI to ChatPanel.
  </action>
  <verify>npm run typecheck passes, FeatureChat renders ChatPanel with correct props</verify>
  <done>FeatureChat refactored to use ChatPanel, context refresh removed from UI</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run typecheck` passes without errors
- [ ] ChatPanel component exists with all required props
- [ ] FeatureChat uses ChatPanel internally
- [ ] Chat loads and displays messages correctly
- [ ] Clear button clears messages but maintains context
- [ ] Context loads automatically without refresh button
- [ ] Tool usage still displays during agent operations
</verification>

<success_criteria>
- ChatPanel is a standalone, reusable component
- FeatureChat is a thin wrapper (~20 lines)
- No context refresh button in UI
- Clear button works correctly
- Agent name displays in header
- All existing chat functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/19-centralized-chat/19-01-SUMMARY.md`:

# Phase 19 Plan 01: Centralized Chat Component Summary

**[One-liner describing what shipped]**

## Accomplishments

- Created ChatPanel reusable component
- Added agent name header and clear button
- Removed context refresh (automatic loading)
- Refactored FeatureChat as thin wrapper

## Files Created/Modified

- `src/renderer/src/components/Chat/ChatPanel.tsx` - New reusable chat component
- `src/renderer/src/stores/chat-store.ts` - Added contextType, clearMessages
- `src/renderer/src/components/Chat/FeatureChat.tsx` - Refactored to use ChatPanel

## Decisions Made

[Any decisions during implementation]

## Issues Encountered

[Problems and resolutions]

## Next Step

Ready for Phase 19-02 (if needed) or Phase 20 (Agents View)
</output>
