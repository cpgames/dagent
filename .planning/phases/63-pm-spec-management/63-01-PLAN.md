---
phase: 63-pm-spec-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/agents/feature-spec-types.ts
  - src/main/ipc/pm-spec-handlers.ts
  - src/main/ipc/handlers.ts
  - src/preload/index.ts
  - src/preload/index.d.ts
  - src/main/agent/pm-mcp-server.ts
  - src/main/agent/tool-config.ts
  - src/main/agent/prompt-builders.ts
autonomous: true
must_haves:
  truths:
    - "PM agent can create a feature spec when given a feature description"
    - "PM agent can update spec sections (goals, requirements, constraints, acceptance criteria)"
    - "PM agent can read current spec to summarize it to user"
    - "Spec changes are persisted to feature-spec.md"
  artifacts:
    - path: "src/main/ipc/pm-spec-handlers.ts"
      provides: "IPC handlers for spec CRUD operations"
      exports: ["registerPMSpecHandlers"]
    - path: "src/main/agent/pm-mcp-server.ts"
      provides: "MCP tools for spec management"
      contains: "CreateSpec|UpdateSpec|GetSpec"
  key_links:
    - from: "pm-mcp-server.ts"
      to: "pm-spec-handlers.ts"
      via: "direct function calls"
      pattern: "pmCreateSpec|pmUpdateSpec|pmGetSpec"
    - from: "pm-spec-handlers.ts"
      to: "feature-spec-store.ts"
      via: "store CRUD operations"
      pattern: "getFeatureSpecStore"
---

<objective>
Enable PM agent to create and manage feature specifications through chat.

Purpose: PM maintains a living spec that captures user intent and requirements, serving as the single source of truth for all agents.

Output: PM agent tools for spec CRUD operations, integrated via MCP server pattern.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-feature-spec-infrastructure/62-01-SUMMARY.md

# Existing patterns to follow:
@src/main/ipc/pm-tools-handlers.ts - PM tool IPC pattern
@src/main/agent/pm-mcp-server.ts - MCP server pattern for PM tools
@src/main/agents/feature-spec-store.ts - FeatureSpecStore CRUD operations
@src/main/agents/feature-spec-types.ts - FeatureSpec type definitions
@src/main/agent/tool-config.ts - Tool preset configuration
@src/main/agent/prompt-builders.ts - PM agent prompt building
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add spec update types to feature-spec-types.ts</name>
  <files>src/main/agents/feature-spec-types.ts</files>
  <action>
Add input/result types for spec operations following pm-tools-handlers.ts pattern:

```typescript
// Input/Result types for PM spec operations
export interface CreateSpecInput {
  featureId: string
  featureName: string
  initialGoals?: string[]
  initialRequirements?: string[]
  initialConstraints?: string[]
  initialAcceptanceCriteria?: string[]
}

export interface CreateSpecResult {
  success: boolean
  error?: string
}

export interface UpdateSpecInput {
  featureId: string
  addGoals?: string[]
  addRequirements?: string[]
  addConstraints?: string[]
  addAcceptanceCriteria?: string[]
  historyNote?: string
}

export interface UpdateSpecResult {
  success: boolean
  error?: string
  addedRequirementIds?: string[]
  addedCriterionIds?: string[]
}

export interface GetSpecInput {
  featureId: string
}

export interface GetSpecResult {
  spec: FeatureSpec | null
  error?: string
}
```

Export all new types from the file.
  </action>
  <verify>npm run build succeeds, types are exported</verify>
  <done>Spec operation types defined and exported</done>
</task>

<task type="auto">
  <name>Task 2: Create pm-spec-handlers.ts with IPC and direct function exports</name>
  <files>src/main/ipc/pm-spec-handlers.ts</files>
  <action>
Create new file following pm-tools-handlers.ts pattern exactly:

1. Import ipcMain from electron
2. Import getFeatureSpecStore from agents
3. Import spec types from feature-spec-types
4. Track currentFeatureId like pm-tools-handlers.ts does (reuse via import from pm-tools-handlers)

Implement both IPC handlers AND direct function exports (for MCP server):

**setPMSpecFeatureContext(featureId)** - Set context (reuse currentFeatureId from pm-tools-handlers via import)

**pmCreateSpec(input: CreateSpecInput): Promise<CreateSpecResult>**
- Get store via getFeatureSpecStore(projectRoot) - get projectRoot from storage-handlers like pm-tools-handlers does
- Call store.createSpec(featureId, featureName)
- If initialGoals/requirements/etc provided, add them via store methods
- Add history entry: "Initial spec from user: [featureName]"
- Return {success: true} or {success: false, error}

**pmUpdateSpec(input: UpdateSpecInput): Promise<UpdateSpecResult>**
- Load existing spec, error if not found
- For each addGoals item: store.addGoal(featureId, goal)
- For each addRequirements item: store.addRequirement(featureId, req) - collect returned IDs
- For each addConstraints item: store.addConstraint(featureId, constraint)
- For each addAcceptanceCriteria item: store.addAcceptanceCriterion(featureId, ac) - collect returned IDs
- If historyNote: store.addHistoryEntry(featureId, historyNote)
- Return {success: true, addedRequirementIds, addedCriterionIds}

**pmGetSpec(input: GetSpecInput): Promise<GetSpecResult>**
- Load spec via store.loadSpec(featureId)
- Return {spec} or {spec: null, error}

**registerPMSpecHandlers()** - Register IPC handlers for each operation

Export: registerPMSpecHandlers, pmCreateSpec, pmUpdateSpec, pmGetSpec
  </action>
  <verify>npm run build succeeds, file compiles</verify>
  <done>PM spec IPC handlers implemented</done>
</task>

<task type="auto">
  <name>Task 3: Register pm-spec-handlers in handlers.ts and update preload</name>
  <files>src/main/ipc/handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
**handlers.ts:**
- Import registerPMSpecHandlers from './pm-spec-handlers'
- Call registerPMSpecHandlers() in registerHandlers() function

**preload/index.ts:**
- Add to contextBridge.exposeInMainWorld('api', {...}):
  - pmSpecSetContext: (featureId: string | null) => ipcRenderer.invoke('pm-spec:setContext', featureId)
  - pmSpecCreate: (input) => ipcRenderer.invoke('pm-spec:createSpec', input)
  - pmSpecUpdate: (input) => ipcRenderer.invoke('pm-spec:updateSpec', input)
  - pmSpecGet: (input) => ipcRenderer.invoke('pm-spec:getSpec', input)

**preload/index.d.ts:**
- Import spec types: CreateSpecInput, CreateSpecResult, UpdateSpecInput, UpdateSpecResult, GetSpecInput, GetSpecResult
- Add method signatures to ElectronAPI interface:
  - pmSpecSetContext: (featureId: string | null) => Promise<void>
  - pmSpecCreate: (input: CreateSpecInput) => Promise<CreateSpecResult>
  - pmSpecUpdate: (input: UpdateSpecInput) => Promise<UpdateSpecResult>
  - pmSpecGet: (input: GetSpecInput) => Promise<GetSpecResult>
  </action>
  <verify>npm run build succeeds, preload types compile</verify>
  <done>IPC handlers registered and preload API exposed</done>
</task>

<task type="auto">
  <name>Task 4: Add spec tools to PM MCP server</name>
  <files>src/main/agent/pm-mcp-server.ts, src/main/agent/tool-config.ts</files>
  <action>
**pm-mcp-server.ts:**
Add three new MCP tools following existing pattern (CreateTask, etc.):

1. **CreateSpec tool:**
```typescript
{
  name: 'CreateSpec',
  description: 'Create a new feature specification. Call this when user describes a new feature to capture goals, requirements, and acceptance criteria.',
  inputSchema: {
    type: 'object',
    properties: {
      featureId: { type: 'string', description: 'Feature ID (from current context)' },
      featureName: { type: 'string', description: 'Human-readable name for the feature' },
      initialGoals: { type: 'array', items: { type: 'string' }, description: 'Initial goals' },
      initialRequirements: { type: 'array', items: { type: 'string' }, description: 'Initial requirements' },
      initialConstraints: { type: 'array', items: { type: 'string' }, description: 'Any constraints/limitations' },
      initialAcceptanceCriteria: { type: 'array', items: { type: 'string' }, description: 'How to verify done' }
    },
    required: ['featureId', 'featureName']
  }
}
```

2. **UpdateSpec tool:**
```typescript
{
  name: 'UpdateSpec',
  description: 'Update an existing feature specification. Use when user refines requirements in conversation.',
  inputSchema: {
    type: 'object',
    properties: {
      featureId: { type: 'string' },
      addGoals: { type: 'array', items: { type: 'string' } },
      addRequirements: { type: 'array', items: { type: 'string' } },
      addConstraints: { type: 'array', items: { type: 'string' } },
      addAcceptanceCriteria: { type: 'array', items: { type: 'string' } },
      historyNote: { type: 'string', description: 'Note about what changed' }
    },
    required: ['featureId']
  }
}
```

3. **GetSpec tool:**
```typescript
{
  name: 'GetSpec',
  description: 'Get the current feature specification to understand requirements.',
  inputSchema: {
    type: 'object',
    properties: {
      featureId: { type: 'string' }
    },
    required: ['featureId']
  }
}
```

Add handler cases in the call_tool handler - import pmCreateSpec, pmUpdateSpec, pmGetSpec from '../ipc/pm-spec-handlers'

Add to getPMToolNamesForAllowedTools() array: 'mcp__pm-tools__CreateSpec', 'mcp__pm-tools__UpdateSpec', 'mcp__pm-tools__GetSpec'

**tool-config.ts:**
Add to pmAgent tools array: 'CreateSpec', 'UpdateSpec', 'GetSpec'
  </action>
  <verify>npm run build succeeds, MCP tools added</verify>
  <done>PM agent has spec management tools via MCP</done>
</task>

<task type="auto">
  <name>Task 5: Update PM agent prompt with spec management instructions</name>
  <files>src/main/agent/prompt-builders.ts</files>
  <action>
Update the PM agent role instructions in getAgentRoleInstructions('pm') to include spec management:

```typescript
case 'pm':
  return `You are a PM (Project Manager) Agent. You manage feature specifications and tasks.

## Spec Management
When a user describes what they want to build:
1. First, call GetSpec to check if a spec exists
2. If no spec exists: call CreateSpec with goals, requirements, constraints, and acceptance criteria extracted from user's description
3. If spec exists: call UpdateSpec to add new items when user refines requirements
4. Summarize spec changes briefly: "Added requirement: [description]"

## Task Management
- When user asks to DO something â†’ CREATE A TASK for it (don't do it yourself)
- Always call ListTasks first to see existing tasks
- Be CONCISE: just confirm actions taken, don't explain systems

## Selected Task Context
If a "Current Task" section appears in the context below, the user has selected that task in the UI.
- When user says "this task" or "the task" without specifying, they mean the selected task
- When creating a related task, consider adding it as a dependency or dependent of the selected task

## Response Style
- After spec operations: "Created spec with N goals, M requirements" or "Added requirement: [brief]"
- After task operations: "Created task: [title]"
- Don't explain systems, don't show tables, don't be verbose
- All details go IN the spec/task, not in your response`
```

The key change: PM now thinks "spec first, then tasks" instead of just creating tasks.
  </action>
  <verify>npm run build succeeds</verify>
  <done>PM agent instructions updated for spec-first workflow</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] All new types exported from feature-spec-types.ts
- [ ] IPC handlers registered and callable
- [ ] Preload API includes pm-spec methods
- [ ] MCP server includes CreateSpec, UpdateSpec, GetSpec tools
- [ ] PM agent prompt includes spec management instructions
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- PM agent can be asked "I want to build X" and it creates a spec
- PM agent can be asked "also add Y requirement" and it updates the spec
- Spec changes persist to feature-spec.md file
</success_criteria>

<output>
After completion, create `.planning/phases/63-pm-spec-management/63-01-SUMMARY.md`
</output>
