---
phase: 03-dag-engine
plan: 02
type: execute
---

<objective>
Implement task state machine with valid transitions per DAGENT_SPEC section 6.4.

Purpose: Enforce valid task state transitions (blocked → ready → running → merging → completed/failed).
Output: State machine module in src/main/dag-engine/ with transition validation and event handling.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./03-02-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dag-engine/03-01-SUMMARY.md
@DAGENT_SPEC.md (section 6.4 for task state transitions)

**Tech stack available:** Electron, React, TypeScript, Zustand
**Established patterns:** IPC via contextBridge, DAG engine in src/main/dag-engine/
**Types available:** Task, TaskStatus, DAGGraph, DAGAnalysis
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define state machine types and transitions</name>
  <files>src/main/dag-engine/state-machine.ts</files>
  <action>
Create state-machine.ts with state transition definitions:
```typescript
import type { TaskStatus } from '@shared/types';

/**
 * Valid state transitions per DAGENT_SPEC section 6.4:
 *
 * blocked → ready     (all dependencies completed)
 * ready → running     (agent assigned)
 * running → merging   (code complete)
 * merging → completed (merge success)
 * merging → failed    (merge failure)
 * running → failed    (task failure)
 *
 * Additionally:
 * any → blocked       (reset on retry or dependency change)
 * failed → ready      (retry after fix)
 */

export type StateTransitionEvent =
  | 'DEPENDENCIES_MET'      // blocked → ready
  | 'AGENT_ASSIGNED'        // ready → running
  | 'CODE_COMPLETE'         // running → merging
  | 'MERGE_SUCCESS'         // merging → completed
  | 'MERGE_FAILED'          // merging → failed
  | 'TASK_FAILED'           // running → failed
  | 'RETRY'                 // failed → ready (if dependencies met)
  | 'DEPENDENCY_CHANGED'    // any incomplete → blocked
  | 'RESET';                // any → blocked (manual reset)

export interface StateTransition {
  from: TaskStatus;
  to: TaskStatus;
  event: StateTransitionEvent;
}

// All valid transitions
export const VALID_TRANSITIONS: StateTransition[] = [
  { from: 'blocked', to: 'ready', event: 'DEPENDENCIES_MET' },
  { from: 'ready', to: 'running', event: 'AGENT_ASSIGNED' },
  { from: 'running', to: 'merging', event: 'CODE_COMPLETE' },
  { from: 'merging', to: 'completed', event: 'MERGE_SUCCESS' },
  { from: 'merging', to: 'failed', event: 'MERGE_FAILED' },
  { from: 'running', to: 'failed', event: 'TASK_FAILED' },
  { from: 'failed', to: 'ready', event: 'RETRY' },
  { from: 'failed', to: 'blocked', event: 'DEPENDENCY_CHANGED' },
  { from: 'ready', to: 'blocked', event: 'DEPENDENCY_CHANGED' },
  { from: 'blocked', to: 'blocked', event: 'RESET' },
  { from: 'ready', to: 'blocked', event: 'RESET' },
  { from: 'running', to: 'blocked', event: 'RESET' },
  { from: 'merging', to: 'blocked', event: 'RESET' },
  { from: 'failed', to: 'blocked', event: 'RESET' },
  { from: 'completed', to: 'blocked', event: 'RESET' },
];

export interface TransitionResult {
  success: boolean;
  previousStatus: TaskStatus;
  newStatus: TaskStatus;
  error?: string;
}

/**
 * Checks if a state transition is valid.
 */
export function isValidTransition(from: TaskStatus, to: TaskStatus, event: StateTransitionEvent): boolean {
  return VALID_TRANSITIONS.some(
    t => t.from === from && t.to === to && t.event === event
  );
}

/**
 * Gets the target status for a given event from a current status.
 * Returns null if no valid transition exists.
 */
export function getNextStatus(currentStatus: TaskStatus, event: StateTransitionEvent): TaskStatus | null {
  const transition = VALID_TRANSITIONS.find(
    t => t.from === currentStatus && t.event === event
  );
  return transition?.to ?? null;
}

/**
 * Gets all valid events that can be triggered from a given status.
 */
export function getValidEvents(currentStatus: TaskStatus): StateTransitionEvent[] {
  return VALID_TRANSITIONS
    .filter(t => t.from === currentStatus)
    .map(t => t.event);
}
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>State machine types and transition rules defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement task status controller</name>
  <files>src/main/dag-engine/task-controller.ts</files>
  <action>
Create task-controller.ts with status management:
```typescript
import type { Task, DAGGraph, TaskStatus } from '@shared/types';
import type { TransitionResult, StateTransitionEvent } from './state-machine';
import { isValidTransition, getNextStatus } from './state-machine';
import { getTaskDependencies } from './topological-sort';

export interface TaskStateChange {
  taskId: string;
  previousStatus: TaskStatus;
  newStatus: TaskStatus;
  event: StateTransitionEvent;
  timestamp: string;
}

/**
 * Attempts to transition a task to a new status.
 * Returns the result of the transition attempt.
 */
export function transitionTask(
  task: Task,
  event: StateTransitionEvent,
  graph?: DAGGraph
): TransitionResult {
  const previousStatus = task.status;
  const nextStatus = getNextStatus(previousStatus, event);

  if (nextStatus === null) {
    return {
      success: false,
      previousStatus,
      newStatus: previousStatus,
      error: `Invalid transition: cannot trigger '${event}' from '${previousStatus}'`,
    };
  }

  // Special validation for RETRY event
  if (event === 'RETRY' && graph) {
    const dependencies = getTaskDependencies(task.id, graph.connections);
    const allDependenciesMet = dependencies.every(depId => {
      const depTask = graph.nodes.find(n => n.id === depId);
      return depTask?.status === 'completed';
    });

    if (!allDependenciesMet) {
      return {
        success: false,
        previousStatus,
        newStatus: previousStatus,
        error: 'Cannot retry: not all dependencies are completed',
      };
    }
  }

  // Apply the transition
  task.status = nextStatus;

  return {
    success: true,
    previousStatus,
    newStatus: nextStatus,
  };
}

/**
 * Batch transition: applies an event to multiple tasks.
 * Returns results for each task.
 */
export function transitionTasks(
  tasks: Task[],
  event: StateTransitionEvent,
  graph?: DAGGraph
): Map<string, TransitionResult> {
  const results = new Map<string, TransitionResult>();

  for (const task of tasks) {
    results.set(task.id, transitionTask(task, event, graph));
  }

  return results;
}

/**
 * Gets all tasks that can receive a specific event.
 */
export function getTasksForEvent(
  graph: DAGGraph,
  event: StateTransitionEvent
): Task[] {
  return graph.nodes.filter(task => {
    const nextStatus = getNextStatus(task.status, event);
    return nextStatus !== null;
  });
}

/**
 * Initializes task statuses based on dependencies.
 * Tasks with no dependencies start as 'ready', others as 'blocked'.
 */
export function initializeTaskStatuses(graph: DAGGraph): void {
  for (const task of graph.nodes) {
    // Skip already completed/running tasks
    if (['completed', 'running', 'merging'].includes(task.status)) {
      continue;
    }

    const dependencies = getTaskDependencies(task.id, graph.connections);

    if (dependencies.length === 0) {
      task.status = 'ready';
    } else {
      const allDependenciesMet = dependencies.every(depId => {
        const depTask = graph.nodes.find(n => n.id === depId);
        return depTask?.status === 'completed';
      });

      task.status = allDependenciesMet ? 'ready' : 'blocked';
    }
  }
}

/**
 * Creates a state change record for logging.
 */
export function createStateChangeRecord(
  taskId: string,
  previousStatus: TaskStatus,
  newStatus: TaskStatus,
  event: StateTransitionEvent
): TaskStateChange {
  return {
    taskId,
    previousStatus,
    newStatus,
    event,
    timestamp: new Date().toISOString(),
  };
}
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Task controller implemented with transition validation</done>
</task>

<task type="auto">
  <name>Task 3: Implement cascading status updates</name>
  <files>src/main/dag-engine/cascade.ts, src/main/dag-engine/index.ts</files>
  <action>
Create cascade.ts for handling status changes that affect dependent tasks:
```typescript
import type { DAGGraph, Task, TaskStatus } from '@shared/types';
import type { TaskStateChange, TransitionResult } from './task-controller';
import { getTaskDependents, getTaskDependencies } from './topological-sort';
import { transitionTask, createStateChangeRecord } from './task-controller';

export interface CascadeResult {
  changes: TaskStateChange[];
  errors: Array<{ taskId: string; error: string }>;
}

/**
 * When a task completes, check and update dependent tasks.
 * Dependents may transition from 'blocked' to 'ready'.
 */
export function cascadeTaskCompletion(
  completedTaskId: string,
  graph: DAGGraph
): CascadeResult {
  const changes: TaskStateChange[] = [];
  const errors: Array<{ taskId: string; error: string }> = [];

  // Get tasks that depend on the completed task
  const dependentIds = getTaskDependents(completedTaskId, graph.connections);

  for (const depId of dependentIds) {
    const depTask = graph.nodes.find(n => n.id === depId);
    if (!depTask || depTask.status !== 'blocked') continue;

    // Check if ALL dependencies are now completed
    const allDependencies = getTaskDependencies(depId, graph.connections);
    const allMet = allDependencies.every(id => {
      const task = graph.nodes.find(n => n.id === id);
      return task?.status === 'completed';
    });

    if (allMet) {
      const result = transitionTask(depTask, 'DEPENDENCIES_MET');
      if (result.success) {
        changes.push(createStateChangeRecord(
          depId,
          result.previousStatus,
          result.newStatus,
          'DEPENDENCIES_MET'
        ));
      } else if (result.error) {
        errors.push({ taskId: depId, error: result.error });
      }
    }
  }

  return { changes, errors };
}

/**
 * When a task fails, optionally cascade failure status to dependents.
 * This is useful for showing which tasks are blocked by failures.
 * Does NOT actually change their status, just identifies affected tasks.
 */
export function getAffectedByFailure(
  failedTaskId: string,
  graph: DAGGraph
): string[] {
  const affected: string[] = [];
  const visited = new Set<string>();
  const queue = [failedTaskId];

  while (queue.length > 0) {
    const current = queue.shift()!;
    if (visited.has(current)) continue;
    visited.add(current);

    const dependents = getTaskDependents(current, graph.connections);
    for (const depId of dependents) {
      if (!visited.has(depId)) {
        affected.push(depId);
        queue.push(depId);
      }
    }
  }

  return affected;
}

/**
 * Resets a task and all its dependents to blocked status.
 * Used when a task needs to be re-run.
 */
export function resetTaskAndDependents(
  taskId: string,
  graph: DAGGraph
): CascadeResult {
  const changes: TaskStateChange[] = [];
  const errors: Array<{ taskId: string; error: string }> = [];

  // Get task and all downstream dependents
  const toReset = [taskId, ...getAffectedByFailure(taskId, graph)];

  for (const id of toReset) {
    const task = graph.nodes.find(n => n.id === id);
    if (!task) continue;

    // Skip already blocked tasks
    if (task.status === 'blocked') continue;

    const previousStatus = task.status;
    const result = transitionTask(task, 'RESET');

    if (result.success) {
      changes.push(createStateChangeRecord(
        id,
        previousStatus,
        result.newStatus,
        'RESET'
      ));
    } else if (result.error) {
      errors.push({ taskId: id, error: result.error });
    }
  }

  return { changes, errors };
}

/**
 * Recalculates all task statuses based on current dependency state.
 * Useful after loading a graph or making structural changes.
 */
export function recalculateAllStatuses(graph: DAGGraph): CascadeResult {
  const changes: TaskStateChange[] = [];
  const errors: Array<{ taskId: string; error: string }> = [];

  for (const task of graph.nodes) {
    // Skip terminal states
    if (['running', 'merging', 'completed'].includes(task.status)) {
      continue;
    }

    const dependencies = getTaskDependencies(task.id, graph.connections);

    // Check if all dependencies are completed
    const allMet = dependencies.length === 0 || dependencies.every(depId => {
      const depTask = graph.nodes.find(n => n.id === depId);
      return depTask?.status === 'completed';
    });

    const targetStatus: TaskStatus = allMet ? 'ready' : 'blocked';

    if (task.status !== targetStatus && task.status !== 'failed') {
      const previousStatus = task.status;
      task.status = targetStatus;

      changes.push(createStateChangeRecord(
        task.id,
        previousStatus,
        targetStatus,
        allMet ? 'DEPENDENCIES_MET' : 'DEPENDENCY_CHANGED'
      ));
    }
  }

  return { changes, errors };
}
```

Update index.ts to export all modules:
```typescript
export * from './types';
export * from './topological-sort';
export * from './analyzer';
export * from './state-machine';
export * from './task-controller';
export * from './cascade';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Cascading status updates implemented for dependency changes</done>
</task>

<task type="auto">
  <name>Task 4: Add state machine IPC handlers</name>
  <files>src/main/ipc/dag-handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Update src/main/ipc/dag-handlers.ts to include state machine handlers:
```typescript
import { ipcMain } from 'electron';
import type { DAGGraph, Task } from '@shared/types';
import type { StateTransitionEvent } from '../dag-engine/state-machine';
import {
  topologicalSort,
  analyzeDAG,
  getReadyTasks,
  isTaskReady,
  isValidTransition,
  getNextStatus,
  getValidEvents,
  transitionTask,
  initializeTaskStatuses,
  cascadeTaskCompletion,
  resetTaskAndDependents,
  recalculateAllStatuses,
} from '../dag-engine';

export function registerDagHandlers(): void {
  // Existing handlers...
  ipcMain.handle('dag:topological-sort', async (_event, graph: DAGGraph) => {
    return topologicalSort(graph);
  });

  ipcMain.handle('dag:analyze', async (_event, graph: DAGGraph) => {
    const analysis = analyzeDAG(graph);
    return {
      ...analysis,
      taskDependencies: Object.fromEntries(analysis.taskDependencies),
    };
  });

  ipcMain.handle('dag:get-ready-tasks', async (_event, graph: DAGGraph) => {
    return getReadyTasks(graph);
  });

  ipcMain.handle('dag:is-task-ready', async (_event, taskId: string, graph: DAGGraph) => {
    return isTaskReady(taskId, graph);
  });

  // State machine handlers
  ipcMain.handle('dag:is-valid-transition', async (_event, from: string, to: string, transitionEvent: string) => {
    return isValidTransition(from as any, to as any, transitionEvent as StateTransitionEvent);
  });

  ipcMain.handle('dag:get-next-status', async (_event, currentStatus: string, transitionEvent: string) => {
    return getNextStatus(currentStatus as any, transitionEvent as StateTransitionEvent);
  });

  ipcMain.handle('dag:get-valid-events', async (_event, currentStatus: string) => {
    return getValidEvents(currentStatus as any);
  });

  ipcMain.handle('dag:transition-task', async (_event, task: Task, transitionEvent: string, graph?: DAGGraph) => {
    return transitionTask(task, transitionEvent as StateTransitionEvent, graph);
  });

  ipcMain.handle('dag:initialize-statuses', async (_event, graph: DAGGraph) => {
    initializeTaskStatuses(graph);
    return graph;
  });

  ipcMain.handle('dag:cascade-completion', async (_event, completedTaskId: string, graph: DAGGraph) => {
    return cascadeTaskCompletion(completedTaskId, graph);
  });

  ipcMain.handle('dag:reset-task', async (_event, taskId: string, graph: DAGGraph) => {
    return resetTaskAndDependents(taskId, graph);
  });

  ipcMain.handle('dag:recalculate-statuses', async (_event, graph: DAGGraph) => {
    return recalculateAllStatuses(graph);
  });
}
```

Update src/preload/index.ts to expose new methods:
```typescript
const dagAPI = {
  // Existing methods...
  topologicalSort: (graph: DAGGraph) => ipcRenderer.invoke('dag:topological-sort', graph),
  analyze: (graph: DAGGraph) => ipcRenderer.invoke('dag:analyze', graph),
  getReadyTasks: (graph: DAGGraph) => ipcRenderer.invoke('dag:get-ready-tasks', graph),
  isTaskReady: (taskId: string, graph: DAGGraph) => ipcRenderer.invoke('dag:is-task-ready', taskId, graph),

  // State machine methods
  isValidTransition: (from: string, to: string, event: string) =>
    ipcRenderer.invoke('dag:is-valid-transition', from, to, event),
  getNextStatus: (currentStatus: string, event: string) =>
    ipcRenderer.invoke('dag:get-next-status', currentStatus, event),
  getValidEvents: (currentStatus: string) =>
    ipcRenderer.invoke('dag:get-valid-events', currentStatus),
  transitionTask: (task: Task, event: string, graph?: DAGGraph) =>
    ipcRenderer.invoke('dag:transition-task', task, event, graph),
  initializeStatuses: (graph: DAGGraph) =>
    ipcRenderer.invoke('dag:initialize-statuses', graph),
  cascadeCompletion: (completedTaskId: string, graph: DAGGraph) =>
    ipcRenderer.invoke('dag:cascade-completion', completedTaskId, graph),
  resetTask: (taskId: string, graph: DAGGraph) =>
    ipcRenderer.invoke('dag:reset-task', taskId, graph),
  recalculateStatuses: (graph: DAGGraph) =>
    ipcRenderer.invoke('dag:recalculate-statuses', graph),
};
```

Update src/preload/index.d.ts with types:
```typescript
interface DagAPI {
  // Existing
  topologicalSort: (graph: DAGGraph) => Promise<TopologicalResult>;
  analyze: (graph: DAGGraph) => Promise<DAGAnalysisSerialized>;
  getReadyTasks: (graph: DAGGraph) => Promise<Task[]>;
  isTaskReady: (taskId: string, graph: DAGGraph) => Promise<boolean>;

  // State machine
  isValidTransition: (from: string, to: string, event: string) => Promise<boolean>;
  getNextStatus: (currentStatus: string, event: string) => Promise<string | null>;
  getValidEvents: (currentStatus: string) => Promise<string[]>;
  transitionTask: (task: Task, event: string, graph?: DAGGraph) => Promise<TransitionResult>;
  initializeStatuses: (graph: DAGGraph) => Promise<DAGGraph>;
  cascadeCompletion: (completedTaskId: string, graph: DAGGraph) => Promise<CascadeResult>;
  resetTask: (taskId: string, graph: DAGGraph) => Promise<CascadeResult>;
  recalculateStatuses: (graph: DAGGraph) => Promise<CascadeResult>;
}
```
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>State machine IPC handlers complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] State machine types and transitions defined
- [ ] Task controller validates state transitions
- [ ] Cascading updates work correctly
- [ ] IPC handlers expose state machine to renderer
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- State machine ready for execution orchestration (Plan 03-03)
</success_criteria>

<output>
After completion, create `.planning/phases/03-dag-engine/03-02-SUMMARY.md` with:
- State machine implementation
- Valid transitions per DAGENT_SPEC
- Task controller with validation
- Cascading status updates
- Ready for Plan 03-03 (execution orchestration)
</output>
