---
phase: 03-dag-engine
plan: 01
type: execute
---

<objective>
Implement topological sort and dependency resolution for DAG graphs.

Purpose: Enable correct execution ordering - tasks must execute only after their dependencies complete.
Output: DAG engine module in src/main/dag-engine/ with topological sort and dependency analysis.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./03-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-model/02-03-SUMMARY.md
@DAGENT_SPEC.md (sections 5.1-5.4, 6.3-6.4 for DAG behavior and execution)

**Tech stack available:** Electron, React, TypeScript, Zustand
**Established patterns:** IPC via contextBridge, @shared/types for cross-process types
**Types available:** Task, TaskStatus, Connection, DAGGraph (from Phase 2)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DAG engine types and module structure</name>
  <files>src/main/dag-engine/types.ts, src/main/dag-engine/index.ts</files>
  <action>
Create src/main/dag-engine/ directory and types.ts with:
```typescript
import type { Task, Connection, DAGGraph, TaskStatus } from '@shared/types';

// Result of topological sort
export interface TopologicalResult {
  sorted: string[];           // Task IDs in execution order
  hasCycle: boolean;          // True if cycle detected
  cycleNodes?: string[];      // Nodes involved in cycle (if any)
}

// Dependency information for a task
export interface TaskDependencies {
  taskId: string;
  dependsOn: string[];        // Task IDs this task depends on
  blockedBy: string[];        // Task IDs currently blocking (incomplete dependencies)
  dependents: string[];       // Task IDs that depend on this task
}

// Analysis of entire DAG
export interface DAGAnalysis {
  topologicalOrder: TopologicalResult;
  taskDependencies: Map<string, TaskDependencies>;
  readyTasks: string[];       // Tasks with all dependencies completed
  blockedTasks: string[];     // Tasks waiting on dependencies
  completedTasks: string[];   // Tasks already completed
  runningTasks: string[];     // Tasks currently running/merging
}
```

Create index.ts that will re-export all dag-engine modules:
```typescript
export * from './types';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>DAG engine types defined for topological sort and dependency analysis</done>
</task>

<task type="auto">
  <name>Task 2: Implement Kahn's algorithm for topological sort</name>
  <files>src/main/dag-engine/topological-sort.ts, src/main/dag-engine/index.ts</files>
  <action>
Create topological-sort.ts implementing Kahn's algorithm:
```typescript
import type { DAGGraph, Connection } from '@shared/types';
import type { TopologicalResult } from './types';

/**
 * Performs topological sort using Kahn's algorithm.
 * Returns tasks in execution order (dependencies before dependents).
 * Detects cycles in the graph.
 */
export function topologicalSort(graph: DAGGraph): TopologicalResult {
  const { nodes, connections } = graph;

  // Build adjacency list and in-degree count
  const inDegree = new Map<string, number>();
  const adjacency = new Map<string, string[]>();

  // Initialize all nodes
  for (const node of nodes) {
    inDegree.set(node.id, 0);
    adjacency.set(node.id, []);
  }

  // Build graph structure from connections
  // Connection: from → to means "to" depends on "from"
  // So "from" must execute before "to"
  for (const conn of connections) {
    const neighbors = adjacency.get(conn.from) || [];
    neighbors.push(conn.to);
    adjacency.set(conn.from, neighbors);

    const currentDegree = inDegree.get(conn.to) || 0;
    inDegree.set(conn.to, currentDegree + 1);
  }

  // Queue nodes with no incoming edges (no dependencies)
  const queue: string[] = [];
  for (const [nodeId, degree] of inDegree) {
    if (degree === 0) {
      queue.push(nodeId);
    }
  }

  // Process queue
  const sorted: string[] = [];
  while (queue.length > 0) {
    const current = queue.shift()!;
    sorted.push(current);

    // Reduce in-degree for neighbors
    const neighbors = adjacency.get(current) || [];
    for (const neighbor of neighbors) {
      const newDegree = (inDegree.get(neighbor) || 0) - 1;
      inDegree.set(neighbor, newDegree);

      if (newDegree === 0) {
        queue.push(neighbor);
      }
    }
  }

  // Check for cycle
  if (sorted.length !== nodes.length) {
    // Find nodes involved in cycle (remaining nodes with in-degree > 0)
    const cycleNodes = nodes
      .filter(n => !sorted.includes(n.id))
      .map(n => n.id);

    return {
      sorted,
      hasCycle: true,
      cycleNodes,
    };
  }

  return {
    sorted,
    hasCycle: false,
  };
}

/**
 * Gets direct dependencies for a task (tasks it depends on).
 */
export function getTaskDependencies(taskId: string, connections: Connection[]): string[] {
  // Connection from → to means "to" depends on "from"
  return connections
    .filter(c => c.to === taskId)
    .map(c => c.from);
}

/**
 * Gets direct dependents for a task (tasks that depend on it).
 */
export function getTaskDependents(taskId: string, connections: Connection[]): string[] {
  // Connection from → to means "to" depends on "from"
  return connections
    .filter(c => c.from === taskId)
    .map(c => c.to);
}
```

Update index.ts to export:
```typescript
export * from './types';
export * from './topological-sort';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Kahn's algorithm implemented for topological sort with cycle detection</done>
</task>

<task type="auto">
  <name>Task 3: Implement DAG analyzer for dependency resolution</name>
  <files>src/main/dag-engine/analyzer.ts, src/main/dag-engine/index.ts</files>
  <action>
Create analyzer.ts that analyzes a DAG and identifies ready/blocked tasks:
```typescript
import type { DAGGraph, Task, TaskStatus } from '@shared/types';
import type { DAGAnalysis, TaskDependencies } from './types';
import { topologicalSort, getTaskDependencies, getTaskDependents } from './topological-sort';

const COMPLETED_STATUSES: TaskStatus[] = ['completed'];
const RUNNING_STATUSES: TaskStatus[] = ['running', 'merging'];
const BLOCKED_STATUSES: TaskStatus[] = ['blocked'];

/**
 * Analyzes a DAG to determine task dependencies and ready/blocked states.
 */
export function analyzeDAG(graph: DAGGraph): DAGAnalysis {
  const { nodes, connections } = graph;

  // Perform topological sort
  const topologicalOrder = topologicalSort(graph);

  // Build dependency map for all tasks
  const taskDependencies = new Map<string, TaskDependencies>();

  for (const node of nodes) {
    const dependsOn = getTaskDependencies(node.id, connections);
    const dependents = getTaskDependents(node.id, connections);

    // Find which dependencies are not yet completed
    const blockedBy = dependsOn.filter(depId => {
      const depNode = nodes.find(n => n.id === depId);
      return depNode && !COMPLETED_STATUSES.includes(depNode.status);
    });

    taskDependencies.set(node.id, {
      taskId: node.id,
      dependsOn,
      blockedBy,
      dependents,
    });
  }

  // Categorize tasks by current state
  const readyTasks: string[] = [];
  const blockedTasks: string[] = [];
  const completedTasks: string[] = [];
  const runningTasks: string[] = [];

  for (const node of nodes) {
    if (COMPLETED_STATUSES.includes(node.status)) {
      completedTasks.push(node.id);
    } else if (RUNNING_STATUSES.includes(node.status)) {
      runningTasks.push(node.id);
    } else {
      // Check if all dependencies are completed
      const deps = taskDependencies.get(node.id);
      if (deps && deps.blockedBy.length === 0) {
        readyTasks.push(node.id);
      } else {
        blockedTasks.push(node.id);
      }
    }
  }

  return {
    topologicalOrder,
    taskDependencies,
    readyTasks,
    blockedTasks,
    completedTasks,
    runningTasks,
  };
}

/**
 * Gets tasks that are ready to execute (all dependencies completed, not running/completed).
 * Used by execution engine to find next tasks to assign agents.
 */
export function getReadyTasks(graph: DAGGraph): Task[] {
  const analysis = analyzeDAG(graph);
  return graph.nodes.filter(n =>
    analysis.readyTasks.includes(n.id) &&
    n.status === 'ready'
  );
}

/**
 * Checks if a specific task is ready to execute.
 */
export function isTaskReady(taskId: string, graph: DAGGraph): boolean {
  const task = graph.nodes.find(n => n.id === taskId);
  if (!task) return false;

  // Already running or completed
  if (['running', 'merging', 'completed'].includes(task.status)) {
    return false;
  }

  // Check all dependencies are completed
  const dependencies = getTaskDependencies(taskId, graph.connections);
  return dependencies.every(depId => {
    const depTask = graph.nodes.find(n => n.id === depId);
    return depTask?.status === 'completed';
  });
}

/**
 * Updates task statuses based on dependency state.
 * Returns tasks whose status changed from blocked to ready.
 */
export function updateTaskStatuses(graph: DAGGraph): string[] {
  const newlyReady: string[] = [];

  for (const node of graph.nodes) {
    // Only update blocked tasks
    if (node.status !== 'blocked') continue;

    // Check if all dependencies are now completed
    const dependencies = getTaskDependencies(node.id, graph.connections);
    const allCompleted = dependencies.every(depId => {
      const depTask = graph.nodes.find(n => n.id === depId);
      return depTask?.status === 'completed';
    });

    if (allCompleted) {
      node.status = 'ready';
      newlyReady.push(node.id);
    }
  }

  return newlyReady;
}
```

Update index.ts:
```typescript
export * from './types';
export * from './topological-sort';
export * from './analyzer';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>DAG analyzer implemented with ready task identification</done>
</task>

<task type="auto">
  <name>Task 4: Add IPC handlers for DAG engine operations</name>
  <files>src/main/ipc/dag-handlers.ts, src/main/ipc/handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Create src/main/ipc/dag-handlers.ts:
```typescript
import { ipcMain } from 'electron';
import type { DAGGraph } from '@shared/types';
import { topologicalSort, analyzeDAG, getReadyTasks, isTaskReady, updateTaskStatuses } from '../dag-engine';

export function registerDagHandlers(): void {
  ipcMain.handle('dag:topological-sort', async (_event, graph: DAGGraph) => {
    return topologicalSort(graph);
  });

  ipcMain.handle('dag:analyze', async (_event, graph: DAGGraph) => {
    const analysis = analyzeDAG(graph);
    // Convert Map to object for IPC serialization
    return {
      ...analysis,
      taskDependencies: Object.fromEntries(analysis.taskDependencies),
    };
  });

  ipcMain.handle('dag:get-ready-tasks', async (_event, graph: DAGGraph) => {
    return getReadyTasks(graph);
  });

  ipcMain.handle('dag:is-task-ready', async (_event, taskId: string, graph: DAGGraph) => {
    return isTaskReady(taskId, graph);
  });

  ipcMain.handle('dag:update-statuses', async (_event, graph: DAGGraph) => {
    return updateTaskStatuses(graph);
  });
}
```

Update src/main/ipc/handlers.ts to include dag handlers:
```typescript
import { registerDagHandlers } from './dag-handlers';

export function registerAllHandlers(): void {
  // ... existing handlers
  registerDagHandlers();
}
```

Update src/preload/index.ts to expose DAG API:
```typescript
const dagAPI = {
  topologicalSort: (graph: DAGGraph) => ipcRenderer.invoke('dag:topological-sort', graph),
  analyze: (graph: DAGGraph) => ipcRenderer.invoke('dag:analyze', graph),
  getReadyTasks: (graph: DAGGraph) => ipcRenderer.invoke('dag:get-ready-tasks', graph),
  isTaskReady: (taskId: string, graph: DAGGraph) => ipcRenderer.invoke('dag:is-task-ready', taskId, graph),
  updateStatuses: (graph: DAGGraph) => ipcRenderer.invoke('dag:update-statuses', graph),
};

// Add to contextBridge exposure
contextBridge.exposeInMainWorld('electronAPI', {
  // ... existing APIs
  dag: dagAPI,
});
```

Update src/preload/index.d.ts with types:
```typescript
interface DagAPI {
  topologicalSort: (graph: DAGGraph) => Promise<TopologicalResult>;
  analyze: (graph: DAGGraph) => Promise<DAGAnalysisSerialized>;
  getReadyTasks: (graph: DAGGraph) => Promise<Task[]>;
  isTaskReady: (taskId: string, graph: DAGGraph) => Promise<boolean>;
  updateStatuses: (graph: DAGGraph) => Promise<string[]>;
}

interface ElectronAPI {
  // ... existing
  dag: DagAPI;
}
```
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>IPC handlers expose DAG engine to renderer process</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] DAG engine module created in src/main/dag-engine/
- [ ] Topological sort correctly orders tasks by dependencies
- [ ] Analyzer identifies ready/blocked/completed tasks
- [ ] IPC handlers expose DAG operations to renderer
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- DAG engine ready for state machine (Plan 03-02)
</success_criteria>

<output>
After completion, create `.planning/phases/03-dag-engine/03-01-SUMMARY.md` with:
- DAG engine module structure
- Topological sort algorithm (Kahn's)
- Dependency analysis functions
- IPC integration
- Ready for Plan 03-02 (state machine)
</output>
