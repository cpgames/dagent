---
phase: 03-dag-engine
plan: 03
type: execute
---

<objective>
Implement execution orchestration with ready task identification and execution queue.

Purpose: Coordinate task execution - identify next tasks to run, manage execution state, handle play/stop.
Output: Execution orchestrator in src/main/dag-engine/ ready for agent integration (Phase 5).
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./03-03-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dag-engine/03-01-SUMMARY.md
@.planning/phases/03-dag-engine/03-02-SUMMARY.md
@DAGENT_SPEC.md (sections 6.1-6.5 for execution engine)

**Tech stack available:** Electron, React, TypeScript, Zustand
**Established patterns:** IPC via contextBridge, DAG engine with state machine
**DAG engine available:** Topological sort, analyzer, state machine, task controller, cascade
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define execution orchestrator types</name>
  <files>src/main/dag-engine/orchestrator-types.ts</files>
  <action>
Create orchestrator-types.ts with execution management types:
```typescript
import type { Task, DAGGraph, TaskStatus } from '@shared/types';
import type { TaskStateChange } from './task-controller';

export type ExecutionStatus = 'idle' | 'running' | 'paused' | 'completed' | 'failed';

export interface ExecutionState {
  status: ExecutionStatus;
  featureId: string | null;
  graph: DAGGraph | null;
  startedAt: string | null;
  stoppedAt: string | null;
  error: string | null;
}

export interface ExecutionConfig {
  maxConcurrentTasks: number;  // Max tasks running simultaneously
  maxConcurrentMerges: number; // Max merge operations simultaneously
}

export const DEFAULT_EXECUTION_CONFIG: ExecutionConfig = {
  maxConcurrentTasks: 3,
  maxConcurrentMerges: 1,
};

export interface TaskAssignment {
  taskId: string;
  assignedAt: string;
  agentId?: string;  // Will be populated when agents are implemented
}

export interface ExecutionEvent {
  type: 'started' | 'paused' | 'resumed' | 'stopped' | 'completed' | 'task_started' | 'task_completed' | 'task_failed' | 'error';
  timestamp: string;
  data?: {
    taskId?: string;
    previousStatus?: TaskStatus;
    newStatus?: TaskStatus;
    error?: string;
  };
}

export interface ExecutionSnapshot {
  state: ExecutionState;
  assignments: TaskAssignment[];
  history: TaskStateChange[];
  events: ExecutionEvent[];
}

export interface NextTasksResult {
  ready: Task[];
  available: Task[];  // Ready tasks not yet assigned
  canAssign: number;  // How many more tasks can be assigned
}
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Execution orchestrator types defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement execution orchestrator class</name>
  <files>src/main/dag-engine/orchestrator.ts</files>
  <action>
Create orchestrator.ts with the main execution controller:
```typescript
import type { DAGGraph, Task, TaskStatus } from '@shared/types';
import type {
  ExecutionState,
  ExecutionConfig,
  ExecutionStatus,
  TaskAssignment,
  ExecutionEvent,
  ExecutionSnapshot,
  NextTasksResult,
} from './orchestrator-types';
import { DEFAULT_EXECUTION_CONFIG } from './orchestrator-types';
import type { TaskStateChange } from './task-controller';
import { transitionTask, createStateChangeRecord } from './task-controller';
import { cascadeTaskCompletion, recalculateAllStatuses } from './cascade';
import { getReadyTasks } from './analyzer';

export class ExecutionOrchestrator {
  private state: ExecutionState;
  private config: ExecutionConfig;
  private assignments: Map<string, TaskAssignment>;
  private history: TaskStateChange[];
  private events: ExecutionEvent[];

  constructor(config: Partial<ExecutionConfig> = {}) {
    this.config = { ...DEFAULT_EXECUTION_CONFIG, ...config };
    this.state = {
      status: 'idle',
      featureId: null,
      graph: null,
      startedAt: null,
      stoppedAt: null,
      error: null,
    };
    this.assignments = new Map();
    this.history = [];
    this.events = [];
  }

  /**
   * Initialize orchestrator with a feature's DAG graph.
   */
  initialize(featureId: string, graph: DAGGraph): void {
    this.state.featureId = featureId;
    this.state.graph = graph;
    this.state.status = 'idle';
    this.state.error = null;
    this.assignments.clear();
    this.history = [];
    this.events = [];

    // Recalculate all task statuses based on dependencies
    const { changes } = recalculateAllStatuses(graph);
    this.history.push(...changes);
  }

  /**
   * Start execution (Play button pressed).
   */
  start(): { success: boolean; error?: string } {
    if (!this.state.graph || !this.state.featureId) {
      return { success: false, error: 'No graph loaded' };
    }

    if (this.state.status === 'running') {
      return { success: false, error: 'Execution already running' };
    }

    this.state.status = 'running';
    this.state.startedAt = new Date().toISOString();
    this.state.stoppedAt = null;
    this.state.error = null;

    this.addEvent('started');
    return { success: true };
  }

  /**
   * Pause execution (Stop button pressed).
   * Running tasks will complete their current operation.
   */
  pause(): { success: boolean; error?: string } {
    if (this.state.status !== 'running') {
      return { success: false, error: 'Execution not running' };
    }

    this.state.status = 'paused';
    this.state.stoppedAt = new Date().toISOString();

    this.addEvent('paused');
    return { success: true };
  }

  /**
   * Resume execution after pause.
   */
  resume(): { success: boolean; error?: string } {
    if (this.state.status !== 'paused') {
      return { success: false, error: 'Execution not paused' };
    }

    this.state.status = 'running';
    this.state.stoppedAt = null;

    this.addEvent('resumed');
    return { success: true };
  }

  /**
   * Stop execution and reset state.
   */
  stop(): { success: boolean; error?: string } {
    if (this.state.status === 'idle') {
      return { success: false, error: 'Execution not started' };
    }

    this.state.status = 'idle';
    this.state.stoppedAt = new Date().toISOString();
    this.assignments.clear();

    this.addEvent('stopped');
    return { success: true };
  }

  /**
   * Get tasks that are ready for execution and can be assigned.
   */
  getNextTasks(): NextTasksResult {
    if (!this.state.graph) {
      return { ready: [], available: [], canAssign: 0 };
    }

    // Get all ready tasks
    const ready = getReadyTasks(this.state.graph);

    // Filter out already assigned tasks
    const assignedIds = new Set(this.assignments.keys());
    const available = ready.filter(t => !assignedIds.has(t.id));

    // Calculate how many more can be assigned
    const currentRunning = this.state.graph.nodes.filter(
      n => n.status === 'running'
    ).length;
    const currentMerging = this.state.graph.nodes.filter(
      n => n.status === 'merging'
    ).length;

    const canAssignTasks = this.config.maxConcurrentTasks - currentRunning;
    const canAssign = Math.max(0, canAssignTasks);

    return { ready, available, canAssign };
  }

  /**
   * Assign a task to an agent (marks as running).
   */
  assignTask(taskId: string, agentId?: string): { success: boolean; error?: string } {
    if (!this.state.graph) {
      return { success: false, error: 'No graph loaded' };
    }

    if (this.state.status !== 'running') {
      return { success: false, error: 'Execution not running' };
    }

    const task = this.state.graph.nodes.find(n => n.id === taskId);
    if (!task) {
      return { success: false, error: 'Task not found' };
    }

    if (task.status !== 'ready') {
      return { success: false, error: `Task not ready (status: ${task.status})` };
    }

    // Check concurrent limit
    const { canAssign } = this.getNextTasks();
    if (canAssign <= 0) {
      return { success: false, error: 'Maximum concurrent tasks reached' };
    }

    // Transition to running
    const result = transitionTask(task, 'AGENT_ASSIGNED');
    if (!result.success) {
      return { success: false, error: result.error };
    }

    // Record assignment
    this.assignments.set(taskId, {
      taskId,
      assignedAt: new Date().toISOString(),
      agentId,
    });

    this.history.push(createStateChangeRecord(
      taskId,
      result.previousStatus,
      result.newStatus,
      'AGENT_ASSIGNED'
    ));

    this.addEvent('task_started', { taskId });
    return { success: true };
  }

  /**
   * Mark a task as having completed its code (ready for merge).
   */
  completeTaskCode(taskId: string): { success: boolean; error?: string } {
    if (!this.state.graph) {
      return { success: false, error: 'No graph loaded' };
    }

    const task = this.state.graph.nodes.find(n => n.id === taskId);
    if (!task) {
      return { success: false, error: 'Task not found' };
    }

    if (task.status !== 'running') {
      return { success: false, error: `Task not running (status: ${task.status})` };
    }

    const result = transitionTask(task, 'CODE_COMPLETE');
    if (!result.success) {
      return { success: false, error: result.error };
    }

    this.history.push(createStateChangeRecord(
      taskId,
      result.previousStatus,
      result.newStatus,
      'CODE_COMPLETE'
    ));

    return { success: true };
  }

  /**
   * Mark a task's merge as successful.
   * Triggers cascade to unblock dependent tasks.
   */
  completeMerge(taskId: string): { success: boolean; unblocked: string[]; error?: string } {
    if (!this.state.graph) {
      return { success: false, unblocked: [], error: 'No graph loaded' };
    }

    const task = this.state.graph.nodes.find(n => n.id === taskId);
    if (!task) {
      return { success: false, unblocked: [], error: 'Task not found' };
    }

    if (task.status !== 'merging') {
      return { success: false, unblocked: [], error: `Task not merging (status: ${task.status})` };
    }

    const result = transitionTask(task, 'MERGE_SUCCESS');
    if (!result.success) {
      return { success: false, unblocked: [], error: result.error };
    }

    this.history.push(createStateChangeRecord(
      taskId,
      result.previousStatus,
      result.newStatus,
      'MERGE_SUCCESS'
    ));

    // Remove assignment
    this.assignments.delete(taskId);

    // Cascade to unblock dependents
    const cascade = cascadeTaskCompletion(taskId, this.state.graph);
    this.history.push(...cascade.changes);

    const unblocked = cascade.changes.map(c => c.taskId);

    this.addEvent('task_completed', {
      taskId,
      previousStatus: result.previousStatus,
      newStatus: result.newStatus,
    });

    // Check if all tasks complete
    this.checkCompletion();

    return { success: true, unblocked };
  }

  /**
   * Mark a task as failed.
   */
  failTask(taskId: string, error?: string): { success: boolean; error?: string } {
    if (!this.state.graph) {
      return { success: false, error: 'No graph loaded' };
    }

    const task = this.state.graph.nodes.find(n => n.id === taskId);
    if (!task) {
      return { success: false, error: 'Task not found' };
    }

    const event = task.status === 'merging' ? 'MERGE_FAILED' : 'TASK_FAILED';
    const result = transitionTask(task, event);
    if (!result.success) {
      return { success: false, error: result.error };
    }

    this.history.push(createStateChangeRecord(
      taskId,
      result.previousStatus,
      result.newStatus,
      event
    ));

    // Remove assignment
    this.assignments.delete(taskId);

    this.addEvent('task_failed', {
      taskId,
      error,
    });

    return { success: true };
  }

  /**
   * Check if execution is complete (all tasks completed).
   */
  private checkCompletion(): void {
    if (!this.state.graph) return;

    const allCompleted = this.state.graph.nodes.every(
      n => n.status === 'completed'
    );

    if (allCompleted) {
      this.state.status = 'completed';
      this.state.stoppedAt = new Date().toISOString();
      this.addEvent('completed');
    }
  }

  /**
   * Get current execution state.
   */
  getState(): ExecutionState {
    return { ...this.state };
  }

  /**
   * Get current configuration.
   */
  getConfig(): ExecutionConfig {
    return { ...this.config };
  }

  /**
   * Update configuration.
   */
  updateConfig(config: Partial<ExecutionConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Get full execution snapshot.
   */
  getSnapshot(): ExecutionSnapshot {
    return {
      state: this.getState(),
      assignments: Array.from(this.assignments.values()),
      history: [...this.history],
      events: [...this.events],
    };
  }

  /**
   * Add an execution event.
   */
  private addEvent(
    type: ExecutionEvent['type'],
    data?: ExecutionEvent['data']
  ): void {
    this.events.push({
      type,
      timestamp: new Date().toISOString(),
      data,
    });
  }
}

// Singleton instance for global access
let orchestratorInstance: ExecutionOrchestrator | null = null;

export function getOrchestrator(): ExecutionOrchestrator {
  if (!orchestratorInstance) {
    orchestratorInstance = new ExecutionOrchestrator();
  }
  return orchestratorInstance;
}

export function resetOrchestrator(): void {
  orchestratorInstance = null;
}
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Execution orchestrator class implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add orchestrator IPC handlers</name>
  <files>src/main/ipc/execution-handlers.ts, src/main/ipc/handlers.ts</files>
  <action>
Create src/main/ipc/execution-handlers.ts:
```typescript
import { ipcMain } from 'electron';
import type { DAGGraph } from '@shared/types';
import type { ExecutionConfig } from '../dag-engine/orchestrator-types';
import { getOrchestrator, resetOrchestrator } from '../dag-engine/orchestrator';

export function registerExecutionHandlers(): void {
  ipcMain.handle('execution:initialize', async (_event, featureId: string, graph: DAGGraph) => {
    const orchestrator = getOrchestrator();
    orchestrator.initialize(featureId, graph);
    return orchestrator.getSnapshot();
  });

  ipcMain.handle('execution:start', async () => {
    const orchestrator = getOrchestrator();
    return orchestrator.start();
  });

  ipcMain.handle('execution:pause', async () => {
    const orchestrator = getOrchestrator();
    return orchestrator.pause();
  });

  ipcMain.handle('execution:resume', async () => {
    const orchestrator = getOrchestrator();
    return orchestrator.resume();
  });

  ipcMain.handle('execution:stop', async () => {
    const orchestrator = getOrchestrator();
    return orchestrator.stop();
  });

  ipcMain.handle('execution:get-state', async () => {
    const orchestrator = getOrchestrator();
    return orchestrator.getState();
  });

  ipcMain.handle('execution:get-next-tasks', async () => {
    const orchestrator = getOrchestrator();
    return orchestrator.getNextTasks();
  });

  ipcMain.handle('execution:assign-task', async (_event, taskId: string, agentId?: string) => {
    const orchestrator = getOrchestrator();
    return orchestrator.assignTask(taskId, agentId);
  });

  ipcMain.handle('execution:complete-task-code', async (_event, taskId: string) => {
    const orchestrator = getOrchestrator();
    return orchestrator.completeTaskCode(taskId);
  });

  ipcMain.handle('execution:complete-merge', async (_event, taskId: string) => {
    const orchestrator = getOrchestrator();
    return orchestrator.completeMerge(taskId);
  });

  ipcMain.handle('execution:fail-task', async (_event, taskId: string, error?: string) => {
    const orchestrator = getOrchestrator();
    return orchestrator.failTask(taskId, error);
  });

  ipcMain.handle('execution:get-snapshot', async () => {
    const orchestrator = getOrchestrator();
    return orchestrator.getSnapshot();
  });

  ipcMain.handle('execution:update-config', async (_event, config: Partial<ExecutionConfig>) => {
    const orchestrator = getOrchestrator();
    orchestrator.updateConfig(config);
    return orchestrator.getConfig();
  });

  ipcMain.handle('execution:reset', async () => {
    resetOrchestrator();
    return { success: true };
  });
}
```

Update src/main/ipc/handlers.ts to include execution handlers:
```typescript
import { registerExecutionHandlers } from './execution-handlers';

export function registerAllHandlers(): void {
  // ... existing handlers
  registerDagHandlers();
  registerExecutionHandlers();
}
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Orchestrator IPC handlers registered</done>
</task>

<task type="auto">
  <name>Task 4: Expose execution API to renderer and update index exports</name>
  <files>src/preload/index.ts, src/preload/index.d.ts, src/main/dag-engine/index.ts</files>
  <action>
Update src/preload/index.ts to expose execution API:
```typescript
const executionAPI = {
  initialize: (featureId: string, graph: DAGGraph) =>
    ipcRenderer.invoke('execution:initialize', featureId, graph),
  start: () => ipcRenderer.invoke('execution:start'),
  pause: () => ipcRenderer.invoke('execution:pause'),
  resume: () => ipcRenderer.invoke('execution:resume'),
  stop: () => ipcRenderer.invoke('execution:stop'),
  getState: () => ipcRenderer.invoke('execution:get-state'),
  getNextTasks: () => ipcRenderer.invoke('execution:get-next-tasks'),
  assignTask: (taskId: string, agentId?: string) =>
    ipcRenderer.invoke('execution:assign-task', taskId, agentId),
  completeTaskCode: (taskId: string) =>
    ipcRenderer.invoke('execution:complete-task-code', taskId),
  completeMerge: (taskId: string) =>
    ipcRenderer.invoke('execution:complete-merge', taskId),
  failTask: (taskId: string, error?: string) =>
    ipcRenderer.invoke('execution:fail-task', taskId, error),
  getSnapshot: () => ipcRenderer.invoke('execution:get-snapshot'),
  updateConfig: (config: Partial<ExecutionConfig>) =>
    ipcRenderer.invoke('execution:update-config', config),
  reset: () => ipcRenderer.invoke('execution:reset'),
};

// Add to contextBridge exposure
contextBridge.exposeInMainWorld('electronAPI', {
  // ... existing APIs
  dag: dagAPI,
  execution: executionAPI,
});
```

Update src/preload/index.d.ts with execution types:
```typescript
interface ExecutionAPI {
  initialize: (featureId: string, graph: DAGGraph) => Promise<ExecutionSnapshot>;
  start: () => Promise<{ success: boolean; error?: string }>;
  pause: () => Promise<{ success: boolean; error?: string }>;
  resume: () => Promise<{ success: boolean; error?: string }>;
  stop: () => Promise<{ success: boolean; error?: string }>;
  getState: () => Promise<ExecutionState>;
  getNextTasks: () => Promise<NextTasksResult>;
  assignTask: (taskId: string, agentId?: string) => Promise<{ success: boolean; error?: string }>;
  completeTaskCode: (taskId: string) => Promise<{ success: boolean; error?: string }>;
  completeMerge: (taskId: string) => Promise<{ success: boolean; unblocked: string[]; error?: string }>;
  failTask: (taskId: string, error?: string) => Promise<{ success: boolean; error?: string }>;
  getSnapshot: () => Promise<ExecutionSnapshot>;
  updateConfig: (config: Partial<ExecutionConfig>) => Promise<ExecutionConfig>;
  reset: () => Promise<{ success: boolean }>;
}

interface ElectronAPI {
  // ... existing
  dag: DagAPI;
  execution: ExecutionAPI;
}
```

Update src/main/dag-engine/index.ts to export all modules:
```typescript
export * from './types';
export * from './topological-sort';
export * from './analyzer';
export * from './state-machine';
export * from './task-controller';
export * from './cascade';
export * from './orchestrator-types';
export * from './orchestrator';
```
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>Execution API exposed to renderer, all exports complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] Execution orchestrator class implemented
- [ ] All execution lifecycle methods working (start/pause/resume/stop)
- [ ] Task assignment and completion flow working
- [ ] IPC handlers expose execution API to renderer
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Phase 3: DAG Engine complete
- Ready for Phase 4 (Git Integration) and Phase 5 (Agent System)
</success_criteria>

<output>
After completion, create `.planning/phases/03-dag-engine/03-03-SUMMARY.md` with:
- Execution orchestrator architecture
- Execution lifecycle (start/pause/resume/stop)
- Task assignment flow
- Integration with state machine and cascade
- Phase 3 complete, ready for Phase 4 (Git Integration)
</output>
