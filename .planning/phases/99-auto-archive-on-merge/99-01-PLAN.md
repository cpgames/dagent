---
phase: 99-auto-archive-on-merge
plan: 01
type: execute
wave: 4
depends_on: ["100-01"]
files_modified:
  - src/main/agents/merge-agent.ts
  - src/main/agents/feature-merge-agent.ts
  - src/main/dag-engine/orchestrator.ts
  - src/main/services/feature-status-manager.ts
autonomous: true

must_haves:
  truths:
    - "Features automatically move to archived when merged"
    - "Auto-merge completes and archives feature"
    - "Manual merge (PR creation) archives feature"
    - "Archived status is final state"
    - "All archive transitions use centralized status management"
  artifacts:
    - path: "src/main/agents/merge-agent.ts"
      provides: "Triggers archive after successful merge"
      contains: "updateFeatureStatus.*archived"
    - path: "src/main/agents/feature-merge-agent.ts"
      provides: "Archives feature after PR creation"
      contains: "updateFeatureStatus.*archived"
    - path: "src/main/dag-engine/orchestrator.ts"
      provides: "Detects merge completion and archives"
      contains: "archived"
  key_links:
    - from: "src/main/agents/merge-agent.ts"
      to: "FeatureStatusManager.updateFeatureStatus"
      via: "archives on successful merge"
      pattern: "updateFeatureStatus.*archived"
    - from: "src/main/agents/feature-merge-agent.ts"
      to: "FeatureStatusManager.updateFeatureStatus"
      via: "archives on PR creation"
      pattern: "updateFeatureStatus.*archived"
---

<objective>
Automatically archive features when merged.

Purpose: Complete the feature lifecycle by automatically moving features to Archived status when merge/PR is completed, eliminating manual archiving.
Output: Auto-archive logic in merge agents and orchestrator, using centralized status management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v2.9-create-feature-workflow.md
@.planning/phases/100-feature-status-system/100-01-SUMMARY.md
@src/main/agents/merge-agent.ts
@src/main/agents/feature-merge-agent.ts
@src/main/dag-engine/orchestrator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auto-archive on task merge completion</name>
  <files>src/main/agents/merge-agent.ts</files>
  <action>
    Update MergeAgent to archive feature when merge succeeds:

    **Locate merge completion logic**:
    - Find the method where merge succeeds (likely executeMerge or similar)
    - After successful merge to feature branch
    - Before emitting 'merge-agent:completed' event

    **Add archive logic**:
    ```typescript
    // After successful merge
    if (mergeSuccess) {
      // Check if all tasks are merged (feature complete)
      const allTasksMerged = await this.checkAllTasksMerged()

      if (allTasksMerged) {
        // Get FeatureStatusManager
        const statusManager = getFeatureStatusManager() // Assume this exists from Phase 100

        // Move feature to archived
        await statusManager.updateFeatureStatus(this.state.featureId, 'archived')

        this.emit('feature-archived', { featureId: this.state.featureId })
      }
    }
    ```

    **checkAllTasksMerged helper**:
    - Query DAG to check if all tasks are in 'completed' status
    - Return true if all tasks merged, false otherwise
    - Only archive when entire feature is done

    **Import FeatureStatusManager**:
    - Add import for FeatureStatusManager (from Phase 100)
    - Use centralized status management method

    Why: Task merges should trigger feature-level archive when all tasks complete.
    Avoid: Do not archive on partial completion - only when all tasks merged.
  </action>
  <verify>npm run build succeeds</verify>
  <done>MergeAgent archives feature when all tasks successfully merged</done>
</task>

<task type="auto">
  <name>Task 2: Auto-archive on feature merge (AI merge or PR creation)</name>
  <files>src/main/agents/feature-merge-agent.ts</files>
  <action>
    Update FeatureMergeAgent to archive feature after merge/PR:

    **Locate completion logic**:
    - Find where AI merge completes successfully
    - Find where PR creation succeeds

    **Add archive for AI merge**:
    ```typescript
    // After successful AI merge to main branch
    if (aiMergeSuccess) {
      const statusManager = getFeatureStatusManager()
      await statusManager.updateFeatureStatus(this.state.featureId, 'archived')

      this.emit('feature-archived', {
        featureId: this.state.featureId,
        mergeType: 'ai'
      })
    }
    ```

    **Add archive for PR creation**:
    ```typescript
    // After successful PR creation
    if (prCreated) {
      const statusManager = getFeatureStatusManager()
      await statusManager.updateFeatureStatus(this.state.featureId, 'archived')

      this.emit('feature-archived', {
        featureId: this.state.featureId,
        mergeType: 'pr',
        prUrl: prResponse.url
      })
    }
    ```

    **Error handling**:
    - If archive fails, log error but don't fail merge operation
    - Merge is already complete, archive is just status update
    - User can manually move to archived if auto-archive fails

    **Import FeatureStatusManager**:
    - Add import and use centralized status management

    Why: Feature-level merge (to main/PR) is the final step, triggers archive.
    Avoid: Do not archive before merge actually succeeds.
  </action>
  <verify>npm run build succeeds</verify>
  <done>FeatureMergeAgent archives feature after AI merge or PR creation</done>
</task>

<task type="auto">
  <name>Task 3: Update orchestrator to handle archived features</name>
  <files>src/main/dag-engine/orchestrator.ts</files>
  <action>
    Update Orchestrator to recognize and handle archived status:

    **Detection logic**:
    - Listen for 'feature-archived' events from merge agents
    - Update internal feature tracking when feature archived

    **Cleanup on archive**:
    - When feature archived, stop orchestrator for that feature
    - Release any held resources (agents, worktrees)
    - Update UI state to reflect archived status
    - Log completion to console: "Feature {name} archived"

    **Prevent re-execution**:
    - Do not allow starting execution on archived features
    - Add guard in start() method:
      ```typescript
      if (feature.status === 'archived') {
        throw new Error('Cannot start execution on archived feature')
      }
      ```

    **Event emission**:
    - Emit 'orchestrator:feature-archived' event for UI updates
    - Include feature ID and archive timestamp

    **Optional: Worktree cleanup**:
    - Consider cleaning up feature worktree on archive (optional)
    - Move to separate cleanup service if implemented
    - Not required for this phase

    Why: Orchestrator needs to handle archived state gracefully.
    Avoid: Do not auto-delete feature data on archive - just update status.
  </action>
  <verify>npm run build succeeds</verify>
  <done>Orchestrator handles archived features and prevents re-execution</done>
</task>

<task type="auto">
  <name>Task 4: Update FeatureStatusManager with archive validation</name>
  <files>src/main/services/feature-status-manager.ts</files>
  <action>
    Update FeatureStatusManager (from Phase 100) to handle archive transitions:

    **Update transition validation**:
    - Add archive transition rules:
      ```typescript
      const validTransitions = {
        planning: ['backlog'],
        backlog: ['in_progress'],
        in_progress: ['needs_attention', 'completed', 'backlog'],
        needs_attention: ['in_progress'],
        completed: ['archived'],  // <-- Only from completed
        archived: []  // <-- Final state, no transitions out
      }
      ```

    **Archive is final**:
    - archived status cannot transition to any other status
    - Attempting to change archived feature status should throw error
    - Exception: Manual admin override (not implemented in this phase)

    **Archive validation**:
    - Only allow completed → archived transition
    - Reject any other status → archived transitions
    - Error message: "Features can only be archived from completed status"

    **Why archived is final**:
    - Archived features represent merged/integrated work
    - Should not be reopened or modified
    - Clean separation between active and historical features

    Why: Enforce workflow integrity with validated archive transitions.
    Avoid: Do not allow arbitrary transitions to/from archived.
  </action>
  <verify>npm run build succeeds</verify>
  <done>FeatureStatusManager enforces completed → archived transition, archived is final</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds with no TypeScript errors
- [ ] MergeAgent archives feature when all tasks merged
- [ ] FeatureMergeAgent archives feature after AI merge or PR creation
- [ ] Orchestrator handles archived features gracefully
- [ ] FeatureStatusManager enforces completed → archived transition
- [ ] Archived status is final (no transitions out)
- [ ] All archive operations use centralized status management
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Automatic archiving completes feature lifecycle workflow
</success_criteria>

<output>
After completion, create `.planning/phases/99-auto-archive-on-merge/99-01-SUMMARY.md`
</output>
