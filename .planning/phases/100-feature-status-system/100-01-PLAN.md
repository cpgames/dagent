---
phase: 100-feature-status-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/types/feature.ts
  - src/main/services/feature-status-manager.ts
  - src/main/ipc/feature-handlers.ts
  - src/renderer/src/stores/feature-store.ts
autonomous: true

must_haves:
  truths:
    - "Feature status type includes planning, backlog, and archived statuses"
    - "not_started status is removed from type definition"
    - "Centralized status management validates status transitions"
    - "Status updates emit events for UI reactivity"
    - "All status changes persist to storage"
  artifacts:
    - path: "src/shared/types/feature.ts"
      provides: "Updated FeatureStatus type with new statuses"
      contains: "'planning' | 'backlog'"
      exports: ["FeatureStatus"]
    - path: "src/main/services/feature-status-manager.ts"
      provides: "Centralized feature status management service"
      min_lines: 80
      exports: ["FeatureStatusManager"]
    - path: "src/main/ipc/feature-handlers.ts"
      provides: "IPC handlers for status management"
      contains: "updateFeatureStatus"
  key_links:
    - from: "src/renderer/src/stores/feature-store.ts"
      to: "window.electronAPI.feature.updateStatus"
      via: "IPC call for status updates"
      pattern: "updateStatus"
    - from: "src/main/ipc/feature-handlers.ts"
      to: "FeatureStatusManager"
      via: "delegates to centralized manager"
      pattern: "FeatureStatusManager"
---

<objective>
Update feature status types and implement centralized status management.

Purpose: Lay foundation for new workflow (Planning → Backlog → In Progress → Needs Attention → Completed → Archived) with centralized, validated status transitions.
Output: Updated FeatureStatus type, FeatureStatusManager service, IPC handlers, and migration for existing features.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v2.9-create-feature-workflow.md
@src/shared/types/feature.ts
@src/main/storage/feature-store.ts
@src/renderer/src/stores/feature-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update FeatureStatus type with new statuses</name>
  <files>src/shared/types/feature.ts</files>
  <action>
    Update FeatureStatus type to include new statuses and remove not_started:
    - Add 'planning' | 'backlog' | 'archived' to the type union
    - Remove 'not_started' from the type union
    - Final type: 'planning' | 'backlog' | 'in_progress' | 'needs_attention' | 'completed' | 'archived'
    - Update Feature interface if needed (should not require changes)

    Why: This is the foundation for the new workflow. All other code will build on this type.
  </action>
  <verify>TypeScript compilation passes: npm run build</verify>
  <done>FeatureStatus type includes all 6 new statuses and excludes not_started</done>
</task>

<task type="auto">
  <name>Task 2: Create FeatureStatusManager service</name>
  <files>src/main/services/feature-status-manager.ts</files>
  <action>
    Create centralized FeatureStatusManager class with the following:

    **Status transition validation**:
    - Define valid transitions map (e.g., planning can only go to backlog)
    - Valid transitions:
      - planning → backlog
      - backlog → in_progress
      - in_progress → needs_attention | completed | backlog (stop)
      - needs_attention → in_progress
      - completed → archived
    - validateTransition(from, to) method that checks if transition is allowed

    **Core method**:
    - updateFeatureStatus(featureId: string, newStatus: FeatureStatus): Promise<void>
    - Loads current feature from storage
    - Validates transition using validateTransition
    - Updates feature.status and feature.updatedAt
    - Persists to storage via FeatureStore
    - Emits 'feature-status-changed' event via EventEmitter

    **Constructor**: Takes FeatureStore and EventEmitter instances

    Why: Centralized management ensures all status changes go through validation and emit events consistently.
    Avoid: Do not add auto-merge logic here (that's for Phase 99).
  </action>
  <verify>
    npm run build succeeds
    TypeScript types resolve correctly for FeatureStatusManager
  </verify>
  <done>FeatureStatusManager class exists with updateFeatureStatus method and transition validation</done>
</task>

<task type="auto">
  <name>Task 3: Add IPC handlers and integrate status manager</name>
  <files>src/main/ipc/feature-handlers.ts, src/renderer/src/stores/feature-store.ts</files>
  <action>
    **In feature-handlers.ts**:
    - Import FeatureStatusManager
    - Instantiate it with appropriate dependencies (FeatureStore, EventEmitter)
    - Add IPC handler: ipcMain.handle('feature:updateStatus', (event, featureId, newStatus) => ...)
    - Handler calls statusManager.updateFeatureStatus(featureId, newStatus)
    - Return success/error response

    **In feature-store.ts (renderer)**:
    - Add updateFeatureStatus method to FeatureState interface
    - Implement method that calls window.electronAPI.feature.updateStatus(featureId, newStatus)
    - On success, update local feature state
    - On error, show toast notification

    **Preload API** (check if needed):
    - Ensure window.electronAPI.feature.updateStatus is exposed in preload script
    - If not, add it to the feature IPC bridge

    Why: This connects the centralized manager to both UI and IPC layers.
    Avoid: Do not modify Kanban drag-and-drop yet (that's Phase 95).
  </action>
  <verify>
    npm run build succeeds
    No TypeScript errors in feature-store.ts or feature-handlers.ts
  </verify>
  <done>IPC handler for updateStatus exists and renderer store can call it</done>
</task>

<task type="auto">
  <name>Task 4: Migration for existing features</name>
  <files>src/main/services/feature-status-manager.ts</files>
  <action>
    Add migration logic to FeatureStatusManager or create a separate migration utility:

    **Migration method**:
    - migrateExistingFeatures(): Promise<void>
    - Load all features from storage
    - For each feature with status 'not_started', update to 'planning'
    - Save updated feature back to storage
    - Log migration count to console

    **Execution**:
    - Call this migration on app startup (in main process initialization)
    - Or provide a one-time migration script that runs automatically
    - Ensure idempotency (safe to run multiple times)

    Why: Existing features use 'not_started' which no longer exists in the new type.
    Avoid: Do not trigger PM agent auto-start here (that's Phase 98).
  </action>
  <verify>
    npm run build succeeds
    Migration logic exists and can be called
  </verify>
  <done>Migration method exists to convert not_started → planning</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds with no TypeScript errors
- [ ] FeatureStatus type has 6 statuses: planning, backlog, in_progress, needs_attention, completed, archived
- [ ] FeatureStatusManager class exists with updateFeatureStatus method
- [ ] IPC handler for feature:updateStatus exists
- [ ] Renderer store has updateFeatureStatus method
- [ ] Migration logic exists for converting not_started to planning
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Centralized status management is foundation for remaining phases
</success_criteria>

<output>
After completion, create `.planning/phases/100-feature-status-system/100-01-SUMMARY.md`
</output>
