---
phase: 56-task-plan-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/agents/task-plan-types.ts
  - src/main/agents/task-plan-store.ts
  - src/main/storage/paths.ts
autonomous: true
must_haves:
  truths:
    - "TaskPlan type is defined with checklist and iteration tracking"
    - "TaskPlanStore can create, load, save, and delete plans"
    - "Plan files are stored in feature worktree .dagent/nodes/{taskId}/plan.json"
  artifacts:
    - path: "src/main/agents/task-plan-types.ts"
      provides: "TaskPlan, ChecklistItem, ActivityEntry interfaces"
      exports: ["TaskPlan", "ChecklistItem", "ActivityEntry", "TaskPlanStatus", "ChecklistStatus", "TaskPlanConfig", "DEFAULT_CHECKLIST_ITEMS", "DEFAULT_TASK_PLAN_CONFIG"]
    - path: "src/main/agents/task-plan-store.ts"
      provides: "TaskPlanStore class with CRUD operations"
      exports: ["TaskPlanStore", "getTaskPlanStore"]
    - path: "src/main/storage/paths.ts"
      provides: "getTaskPlanPath helper"
      contains: "getTaskPlanPath"
  key_links:
    - from: "task-plan-store.ts"
      to: "paths.ts"
      via: "getTaskPlanPath for file location"
      pattern: "getTaskPlanPath"
    - from: "task-plan-store.ts"
      to: "json-store.ts"
      via: "readJson/writeJson for persistence"
      pattern: "readJson|writeJson"
---

<objective>
Create TaskPlan schema and storage infrastructure for Ralph Loop iteration tracking.

Purpose: Enable iteration state persistence across fresh DevAgent context windows. The TaskPlan tracks checklist items (implement/build/lint/test), iteration count, and activity log so each new agent iteration knows what's passing and what still needs work.

Output: Two new files (task-plan-types.ts, task-plan-store.ts) and one path helper.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/56-task-plan-infrastructure/56-RESEARCH.md

# Existing patterns to follow:
@src/main/agents/dev-types.ts
@src/main/storage/json-store.ts
@src/main/storage/paths.ts
@src/main/storage/feature-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskPlan type definitions</name>
  <files>src/main/agents/task-plan-types.ts</files>
  <action>
Create new file with TypeScript interfaces for Ralph Loop state tracking.

**Types to define:**

1. `ChecklistStatus` - literal union: 'pending' | 'pass' | 'fail' | 'skipped'

2. `ChecklistItem` interface:
   - `id: string` - e.g., 'implement', 'build', 'lint', 'test'
   - `description: string` - human-readable
   - `status: ChecklistStatus`
   - `error?: string` - error message if failed
   - `output?: string` - truncated command output (max 500 chars)
   - `verifiedAt?: string` - ISO timestamp

3. `ActivityEntry` interface:
   - `iteration: number`
   - `summary: string` - what agent accomplished
   - `timestamp: string` - ISO timestamp
   - `duration?: number` - milliseconds
   - `checklistSnapshot?: Record<string, ChecklistStatus>` - state after iteration

4. `TaskPlanStatus` - literal union: 'pending' | 'running' | 'paused' | 'completed' | 'failed' | 'aborted'

5. `TaskPlanConfig` interface:
   - `runBuild: boolean` - default true
   - `runLint: boolean` - default true
   - `runTests: boolean` - default false (opt-in)
   - `continueOnLintFail: boolean` - default true
   - `buildCommand?: string` - override detected
   - `lintCommand?: string`
   - `testCommand?: string`

6. `TaskPlan` interface:
   - `taskId: string`
   - `featureId: string`
   - `iteration: number` - current, 1-based
   - `maxIterations: number` - default 10
   - `status: TaskPlanStatus`
   - `checklist: ChecklistItem[]`
   - `activity: ActivityEntry[]`
   - `createdAt: string`
   - `updatedAt: string`
   - `completedAt?: string`
   - `config: TaskPlanConfig`

**Constants to export:**

`DEFAULT_CHECKLIST_ITEMS: ChecklistItem[]` with:
- { id: 'implement', description: 'Implement the task requirements', status: 'pending' }
- { id: 'build', description: 'Build passes without errors', status: 'pending' }
- { id: 'lint', description: 'Lint passes (if available)', status: 'pending' }
- { id: 'test', description: 'Tests pass (if available)', status: 'pending' }

`DEFAULT_TASK_PLAN_CONFIG: TaskPlanConfig` with:
- runBuild: true
- runLint: true
- runTests: false
- continueOnLintFail: true

**Pattern to follow:** Match style of dev-types.ts - JSDoc comments, organized sections, DEFAULT_ constants at bottom.
  </action>
  <verify>npx tsc --noEmit src/main/agents/task-plan-types.ts</verify>
  <done>task-plan-types.ts exports all interfaces and constants, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 2: Add getTaskPlanPath to paths.ts</name>
  <files>src/main/storage/paths.ts</files>
  <action>
Add a new path helper function for task plan files.

**Add function:**

```typescript
/**
 * Get the path to plan.json for a specific task.
 * Location: {projectRoot}/.dagent-worktrees/{featureId}/.dagent/nodes/{taskId}/plan.json
 */
export function getTaskPlanPath(projectRoot: string, featureId: string, taskId: string): string {
  return path.join(getNodeDir(projectRoot, featureId, taskId), 'plan.json');
}
```

**Location:** Add after getTaskSessionPath function (similar pattern).
  </action>
  <verify>npx tsc --noEmit src/main/storage/paths.ts</verify>
  <done>getTaskPlanPath function exported from paths.ts</done>
</task>

<task type="auto">
  <name>Task 3: Create TaskPlanStore class</name>
  <files>src/main/agents/task-plan-store.ts</files>
  <action>
Create new file with TaskPlanStore class following FeatureStore patterns.

**Class structure:**

```typescript
import { randomUUID } from 'crypto'
import { readJson, writeJson, deleteJson, exists } from '../storage/json-store'
import { getTaskPlanPath } from '../storage/paths'
import type { TaskPlan, TaskPlanConfig, ChecklistItem, ActivityEntry } from './task-plan-types'
import { DEFAULT_CHECKLIST_ITEMS, DEFAULT_TASK_PLAN_CONFIG } from './task-plan-types'

// Singleton store per projectRoot
const stores = new Map<string, TaskPlanStore>()

export function getTaskPlanStore(projectRoot: string): TaskPlanStore {
  let store = stores.get(projectRoot)
  if (!store) {
    store = new TaskPlanStore(projectRoot)
    stores.set(projectRoot, store)
  }
  return store
}

export class TaskPlanStore {
  constructor(private projectRoot: string) {}

  // Create new plan with defaults
  async createPlan(featureId: string, taskId: string, config?: Partial<TaskPlanConfig>): Promise<TaskPlan>

  // Load existing plan
  async loadPlan(featureId: string, taskId: string): Promise<TaskPlan | null>

  // Save plan (full replace)
  async savePlan(featureId: string, taskId: string, plan: TaskPlan): Promise<void>

  // Delete plan
  async deletePlan(featureId: string, taskId: string): Promise<boolean>

  // Check if plan exists
  async planExists(featureId: string, taskId: string): Promise<boolean>

  // Convenience: update single checklist item
  async updateChecklistItem(featureId: string, taskId: string, itemId: string, update: Partial<ChecklistItem>): Promise<void>

  // Convenience: add activity entry
  async addActivity(featureId: string, taskId: string, entry: Omit<ActivityEntry, 'timestamp'>): Promise<void>

  // Convenience: increment iteration and return new count
  async incrementIteration(featureId: string, taskId: string): Promise<number>

  // Private helper to get file path
  private getPath(featureId: string, taskId: string): string
}
```

**Implementation details:**

1. `createPlan`: Generate plan with:
   - Copy DEFAULT_CHECKLIST_ITEMS (deep copy to avoid mutation)
   - Merge config with DEFAULT_TASK_PLAN_CONFIG
   - Set iteration: 1, maxIterations: 10, status: 'pending'
   - Set createdAt, updatedAt to new Date().toISOString()
   - Save and return

2. `loadPlan`: Use readJson<TaskPlan>, return null if not found

3. `savePlan`: Update `updatedAt`, use writeJson

4. `updateChecklistItem`: Load plan, find item by id, merge update, set verifiedAt if status changed, save

5. `addActivity`: Load plan, push new entry with timestamp, save

6. `incrementIteration`: Load plan, increment iteration, update updatedAt, save, return new iteration

**Error handling:**
- Throw if plan not found for update operations
- Log operations for debugging

**Pattern to follow:** Match feature-store.ts singleton pattern and method signatures.
  </action>
  <verify>npx tsc --noEmit src/main/agents/task-plan-store.ts</verify>
  <done>TaskPlanStore class with all CRUD methods, TypeScript compiles</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes (or `npx tsc --noEmit`)
- [ ] task-plan-types.ts exports: TaskPlan, ChecklistItem, ActivityEntry, TaskPlanStatus, ChecklistStatus, TaskPlanConfig, DEFAULT_CHECKLIST_ITEMS, DEFAULT_TASK_PLAN_CONFIG
- [ ] task-plan-store.ts exports: TaskPlanStore, getTaskPlanStore
- [ ] paths.ts exports: getTaskPlanPath
- [ ] No circular imports
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Types align with 56-RESEARCH.md schema design
- Store follows existing singleton pattern from feature-store.ts
</success_criteria>

<output>
After completion, create `.planning/phases/56-task-plan-infrastructure/56-01-SUMMARY.md`
</output>
