---
phase: v3.0-05-dev-agent-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/types/task.ts
  - src/main/dag-engine/task-controller.ts
  - src/main/dag-engine/task-controller-types.ts
autonomous: true
must_haves:
  truths:
    - "Task type includes sessions tracking field"
    - "TaskController creates session at loop start"
    - "Iteration results are added to checkpoint"
  artifacts:
    - path: "src/shared/types/task.ts"
      provides: "Task type with sessions field"
      contains: "sessions?"
    - path: "src/main/dag-engine/task-controller.ts"
      provides: "SessionManager integration"
      contains: "getSessionManager"
  key_links:
    - from: "task-controller.ts"
      to: "session-manager.ts"
      via: "getSessionManager import"
      pattern: "getSessionManager"
---

<objective>
Add state-based session management to tasks and integrate SessionManager into TaskController for Ralph Loop iterations.

Purpose: Enable automatic conversation history tracking during iterative task execution with checkpoint compaction support.
Output: Task type with sessions field, TaskController creates/uses sessions during Ralph Loop.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v3.0-session-checkpoint-ROADMAP.md
@.planning/session-checkpoint-architecture.md

@src/shared/types/task.ts
@src/shared/types/session.ts
@src/main/dag-engine/task-controller.ts
@src/main/dag-engine/task-controller-types.ts
@src/main/services/session-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sessions field to Task type</name>
  <files>src/shared/types/task.ts</files>
  <action>
    Add optional sessions tracking field to the Task interface:

    ```typescript
    // NEW: Session tracking per task state
    sessions?: {
      in_dev?: string[]      // Session IDs for dev iterations
      in_qa?: string[]       // Session IDs for QA iterations
    }
    currentSessionId?: string  // Active session ID
    ```

    This allows tracking multiple sessions per state (e.g., if dev work spans multiple context windows).
    The field is optional for backward compatibility with existing tasks.
  </action>
  <verify>npm run build succeeds, Task type includes sessions field</verify>
  <done>Task interface has sessions tracking fields</done>
</task>

<task type="auto">
  <name>Task 2: Add sessionId to TaskControllerState</name>
  <files>src/main/dag-engine/task-controller-types.ts</files>
  <action>
    Add sessionId field to TaskControllerState interface:

    ```typescript
    sessionId: string | null  // Active session for this loop
    ```

    This tracks the session being used for the current Ralph Loop execution.
  </action>
  <verify>npm run build succeeds</verify>
  <done>TaskControllerState has sessionId field</done>
</task>

<task type="auto">
  <name>Task 3: Integrate SessionManager into TaskController</name>
  <files>src/main/dag-engine/task-controller.ts</files>
  <action>
    1. Import SessionManager:
       ```typescript
       import { getSessionManager } from '../services/session-manager'
       import type { SessionContext, AgentDescription } from '../../shared/types/session'
       ```

    2. In constructor, initialize sessionId to null:
       ```typescript
       sessionId: null
       ```

    3. In start() method, after loading TaskPlan, create or get session:
       ```typescript
       // Create dev session for this Ralph Loop
       const sessionManager = getSessionManager(this.projectRoot)
       const session = await sessionManager.getOrCreateSession({
         type: 'task',
         agentType: 'dev',
         featureId: this.state.featureId,
         taskId: this.state.taskId,
         taskState: 'in_dev'
       })
       this.state.sessionId = session.id

       // Initialize context and agent description
       await this.initializeSessionContext(session.id)
       ```

    4. Add initializeSessionContext() private method:
       ```typescript
       private async initializeSessionContext(sessionId: string): Promise<void> {
         const sessionManager = getSessionManager(this.projectRoot)

         // Build context from task/feature info
         const context: SessionContext = {
           sessionId,
           type: 'dev-task',
           featureId: this.state.featureId,
           taskId: this.state.taskId,
           project: {
             // Minimal project context - could be expanded later
             structure: { root: this.projectRoot }
           },
           task: this.task ? {
             title: this.task.title,
             description: this.task.description,
             dependencies: [],
             dependents: []
           } : undefined,
           updatedAt: new Date().toISOString()
         }

         await sessionManager.updateContext(sessionId, this.state.featureId, context)

         // Set agent description
         const agentDesc: AgentDescription = {
           sessionId,
           agentType: 'dev',
           roleInstructions: this.buildDevAgentRoleInstructions(),
           allowedTools: ['Read', 'Write', 'Edit', 'Bash', 'Glob', 'Grep'],
           createdAt: new Date().toISOString()
         }

         await sessionManager.setAgentDescription(sessionId, this.state.featureId, agentDesc)
       }

       private buildDevAgentRoleInstructions(): string {
         return `You are a Dev Agent implementing a task in an isolated git worktree.

Your job is to:
1. Implement the task as described
2. Make all necessary file changes
3. Ensure code builds and tests pass
4. Follow project conventions from CLAUDE.md

Work in the current directory only. Do not navigate elsewhere.`
       }
       ```

    5. In runIterationLoop(), after each iteration completes, add iteration result to session:
       ```typescript
       // Add iteration result to session checkpoint
       if (this.state.sessionId) {
         const sessionManager = getSessionManager(this.projectRoot)

         // Add iteration as a message
         await sessionManager.addMessage(this.state.sessionId, this.state.featureId, {
           role: 'assistant',
           content: iterationResult.summary,
           metadata: {
             internal: true,
             iterationNumber: this.state.currentIteration,
             verificationResults: iterationResult.verificationResults.map(r => ({
               checkId: r.checkId,
               passed: r.passed,
               error: r.error
             }))
           }
         })
       }
       ```

    The key principle: Each iteration adds to the session's message history.
    When token limit is reached, compaction automatically merges messages into checkpoint.
  </action>
  <verify>npm run build succeeds, TaskController imports and uses SessionManager</verify>
  <done>TaskController creates session at start and logs iterations to session</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Task type includes sessions? and currentSessionId? fields
- [ ] TaskControllerState has sessionId field
- [ ] TaskController imports getSessionManager
- [ ] TaskController creates session in start() method
- [ ] TaskController logs iteration results to session
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- TaskController uses SessionManager for Ralph Loop sessions
</success_criteria>

<output>
After completion, create `.planning/phases/v3.0-05-dev-agent-integration/05-01-SUMMARY.md`
</output>
