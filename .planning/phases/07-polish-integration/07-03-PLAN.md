---
phase: 07-polish-integration
plan: 03
type: execute
---

<objective>
Implement graph versioning with undo/redo for DAG modifications.

Purpose: Allow users to undo/redo DAG changes with 20 version history.
Output: Working undo/redo system per DAGENT_SPEC 5.5.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-polish-integration/07-02-SUMMARY.md
@src/renderer/src/stores/dag-store.ts
@src/main/storage/json-store.ts

**From DAGENT_SPEC 5.5 - Graph Versioning:**
- All modifications go through single pipeline
- AI batch operations = single version
- Store last 20 versions of graph state
- Chat history is NOT part of undo/redo
- Undo/Redo buttons in control bar

**From DAGENT_SPEC 9.1 - Storage:**
```
.dagent/
├── dag.json              # Current graph state
├── dag_history/          # Undo/redo versions (max 20)
│   ├── 001.json
│   ├── 002.json
│   └── ...
```

**Tech stack:** Zustand, Electron IPC, JSON file storage
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create history types</name>
  <files>src/shared/types/history.ts, src/shared/types/index.ts</files>
  <action>
Define history types for versioning:

**src/shared/types/history.ts:**
```typescript
import type { DAGGraph } from './dag';

export interface DAGVersion {
  version: number;
  timestamp: string;
  graph: DAGGraph;
  description?: string; // Optional description of change
}

export interface DAGHistory {
  versions: DAGVersion[];
  currentIndex: number; // Index into versions array
  maxVersions: number;  // Cap at 20
}

export interface HistoryState {
  canUndo: boolean;
  canRedo: boolean;
  currentVersion: number;
  totalVersions: number;
}
```

Update src/shared/types/index.ts to export from history.ts.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>History types defined</done>
</task>

<task type="auto">
  <name>Task 2: Create history manager in main process</name>
  <files>src/main/storage/history-manager.ts</files>
  <action>
Create HistoryManager for managing DAG versions:

```typescript
import { existsSync, readdirSync, readFileSync, writeFileSync, unlinkSync, mkdirSync } from 'fs';
import { join } from 'path';
import type { DAGGraph, DAGVersion, DAGHistory, HistoryState } from '@shared/types';

const MAX_VERSIONS = 20;

export class HistoryManager {
  private projectRoot: string;
  private featureId: string;
  private history: DAGHistory;

  constructor(projectRoot: string, featureId: string) {
    this.projectRoot = projectRoot;
    this.featureId = featureId;
    this.history = {
      versions: [],
      currentIndex: -1,
      maxVersions: MAX_VERSIONS
    };
  }

  private getHistoryDir(): string {
    return join(this.projectRoot, '.dagent-worktrees', this.featureId, '.dagent', 'dag_history');
  }

  /**
   * Load existing history from disk.
   */
  load(): void {
    const historyDir = this.getHistoryDir();
    if (!existsSync(historyDir)) {
      mkdirSync(historyDir, { recursive: true });
      return;
    }

    const files = readdirSync(historyDir)
      .filter(f => f.endsWith('.json'))
      .sort();

    this.history.versions = files.map((file, index) => {
      const content = readFileSync(join(historyDir, file), 'utf-8');
      const data = JSON.parse(content);
      return {
        version: index + 1,
        timestamp: data.timestamp || new Date().toISOString(),
        graph: data.graph || data,
        description: data.description
      };
    });

    // Current index is at the end
    this.history.currentIndex = this.history.versions.length - 1;
  }

  /**
   * Push a new version. Truncates any redo history.
   */
  pushVersion(graph: DAGGraph, description?: string): void {
    // If we're not at the end, truncate forward history
    if (this.history.currentIndex < this.history.versions.length - 1) {
      this.history.versions = this.history.versions.slice(0, this.history.currentIndex + 1);
      this.cleanupDiskVersions();
    }

    // Add new version
    const version: DAGVersion = {
      version: this.history.versions.length + 1,
      timestamp: new Date().toISOString(),
      graph: JSON.parse(JSON.stringify(graph)), // Deep clone
      description
    };

    this.history.versions.push(version);
    this.history.currentIndex = this.history.versions.length - 1;

    // Enforce max versions
    if (this.history.versions.length > MAX_VERSIONS) {
      this.history.versions.shift();
      this.history.currentIndex--;
    }

    // Save to disk
    this.saveToDisk();
  }

  /**
   * Undo - go back one version.
   */
  undo(): DAGGraph | null {
    if (!this.canUndo()) return null;

    this.history.currentIndex--;
    return this.getCurrentGraph();
  }

  /**
   * Redo - go forward one version.
   */
  redo(): DAGGraph | null {
    if (!this.canRedo()) return null;

    this.history.currentIndex++;
    return this.getCurrentGraph();
  }

  canUndo(): boolean {
    return this.history.currentIndex > 0;
  }

  canRedo(): boolean {
    return this.history.currentIndex < this.history.versions.length - 1;
  }

  getCurrentGraph(): DAGGraph | null {
    if (this.history.currentIndex < 0 || this.history.versions.length === 0) {
      return null;
    }
    return this.history.versions[this.history.currentIndex].graph;
  }

  getState(): HistoryState {
    return {
      canUndo: this.canUndo(),
      canRedo: this.canRedo(),
      currentVersion: this.history.currentIndex + 1,
      totalVersions: this.history.versions.length
    };
  }

  private saveToDisk(): void {
    const historyDir = this.getHistoryDir();
    if (!existsSync(historyDir)) {
      mkdirSync(historyDir, { recursive: true });
    }

    // Re-write all versions with sequential numbering
    this.history.versions.forEach((version, index) => {
      const filename = `${String(index + 1).padStart(3, '0')}.json`;
      const filepath = join(historyDir, filename);
      writeFileSync(filepath, JSON.stringify({
        timestamp: version.timestamp,
        graph: version.graph,
        description: version.description
      }, null, 2));
    });
  }

  private cleanupDiskVersions(): void {
    const historyDir = this.getHistoryDir();
    if (!existsSync(historyDir)) return;

    const files = readdirSync(historyDir).filter(f => f.endsWith('.json'));
    const keepCount = this.history.versions.length;

    // Remove files beyond current version count
    files.forEach((file, index) => {
      if (index >= keepCount) {
        unlinkSync(join(historyDir, file));
      }
    });
  }
}

// Cache of history managers per feature
const historyManagers: Map<string, HistoryManager> = new Map();

export function getHistoryManager(projectRoot: string, featureId: string): HistoryManager {
  const key = `${projectRoot}:${featureId}`;
  let manager = historyManagers.get(key);
  if (!manager) {
    manager = new HistoryManager(projectRoot, featureId);
    manager.load();
    historyManagers.set(key, manager);
  }
  return manager;
}

export function clearHistoryManagers(): void {
  historyManagers.clear();
}
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>HistoryManager with undo/redo and 20 version cap</done>
</task>

<task type="auto">
  <name>Task 3: Create history IPC handlers</name>
  <files>src/main/ipc/history-handlers.ts, src/main/ipc/handlers.ts</files>
  <action>
Create IPC handlers for history operations:

**src/main/ipc/history-handlers.ts:**
```typescript
import { ipcMain } from 'electron';
import { getHistoryManager } from '../storage/history-manager';
import { loadDAG, saveDAG } from '../storage';
import type { DAGGraph } from '@shared/types';

let projectRoot: string | null = null;

export function setHistoryProjectRoot(root: string): void {
  projectRoot = root;
}

export function registerHistoryHandlers(): void {
  // Push a new version after DAG modification
  ipcMain.handle('history:pushVersion', async (_event, featureId: string, graph: DAGGraph, description?: string) => {
    if (!projectRoot) return { success: false, error: 'Project not initialized' };

    const manager = getHistoryManager(projectRoot, featureId);
    manager.pushVersion(graph, description);
    return { success: true, state: manager.getState() };
  });

  // Undo
  ipcMain.handle('history:undo', async (_event, featureId: string) => {
    if (!projectRoot) return { success: false, error: 'Project not initialized' };

    const manager = getHistoryManager(projectRoot, featureId);
    const graph = manager.undo();

    if (graph) {
      // Save the restored graph as current
      await saveDAG(featureId, graph);
      return { success: true, graph, state: manager.getState() };
    }

    return { success: false, error: 'Nothing to undo' };
  });

  // Redo
  ipcMain.handle('history:redo', async (_event, featureId: string) => {
    if (!projectRoot) return { success: false, error: 'Project not initialized' };

    const manager = getHistoryManager(projectRoot, featureId);
    const graph = manager.redo();

    if (graph) {
      // Save the restored graph as current
      await saveDAG(featureId, graph);
      return { success: true, graph, state: manager.getState() };
    }

    return { success: false, error: 'Nothing to redo' };
  });

  // Get current history state
  ipcMain.handle('history:getState', async (_event, featureId: string) => {
    if (!projectRoot) return { canUndo: false, canRedo: false, currentVersion: 0, totalVersions: 0 };

    const manager = getHistoryManager(projectRoot, featureId);
    return manager.getState();
  });
}
```

Update handlers.ts to import and call registerHistoryHandlers().
  </action>
  <verify>npm run typecheck passes</verify>
  <done>History IPC handlers registered</done>
</task>

<task type="auto">
  <name>Task 4: Update preload with history API</name>
  <files>src/preload/index.ts</files>
  <action>
Add history methods to preload:

```typescript
history: {
  pushVersion: (featureId: string, graph: DAGGraph, description?: string) =>
    ipcRenderer.invoke('history:pushVersion', featureId, graph, description),
  undo: (featureId: string) => ipcRenderer.invoke('history:undo', featureId),
  redo: (featureId: string) => ipcRenderer.invoke('history:redo', featureId),
  getState: (featureId: string) => ipcRenderer.invoke('history:getState', featureId)
}
```

Import DAGGraph type if needed.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Preload exposes history API</done>
</task>

<task type="auto">
  <name>Task 5: Update DAG store with history integration</name>
  <files>src/renderer/src/stores/dag-store.ts</files>
  <action>
Update dag-store to track history and push versions on changes:

Add to DAGStoreState:
```typescript
historyState: HistoryState;
loadHistoryState: (featureId: string) => Promise<void>;
undo: () => Promise<void>;
redo: () => Promise<void>;
```

Add historyState initial value:
```typescript
historyState: {
  canUndo: false,
  canRedo: false,
  currentVersion: 0,
  totalVersions: 0
}
```

After each mutation (addNode, removeNode, updateNode, addConnection, removeConnection), push a version:
```typescript
// Example in updateNode:
updateNode: async (nodeId, updates) => {
  // ... existing mutation logic ...

  // Push version after change
  const { dag, currentFeatureId, loadHistoryState } = get();
  if (dag && currentFeatureId) {
    await window.electronAPI.history.pushVersion(
      currentFeatureId,
      dag,
      `Updated node ${nodeId}`
    );
    await loadHistoryState(currentFeatureId);
  }
}
```

Add undo/redo implementations:
```typescript
undo: async () => {
  const { currentFeatureId } = get();
  if (!currentFeatureId) return;

  const result = await window.electronAPI.history.undo(currentFeatureId);
  if (result.success && result.graph) {
    set({ dag: result.graph, historyState: result.state });
  }
},

redo: async () => {
  const { currentFeatureId } = get();
  if (!currentFeatureId) return;

  const result = await window.electronAPI.history.redo(currentFeatureId);
  if (result.success && result.graph) {
    set({ dag: result.graph, historyState: result.state });
  }
},

loadHistoryState: async (featureId) => {
  const state = await window.electronAPI.history.getState(featureId);
  set({ historyState: state });
}
```

Call loadHistoryState after loadDag completes.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>DAG store integrated with history</done>
</task>

<task type="auto">
  <name>Task 6: Connect undo/redo to ExecutionControls</name>
  <files>src/renderer/src/views/DAGView.tsx</files>
  <action>
Update DAGView to pass undo/redo props to ExecutionControls:

1. Import historyState, undo, redo from dag-store
2. Pass to ExecutionControls:

```tsx
const { dag, historyState, undo, redo, /* ... other */ } = useDAGStore();

// In JSX:
<ExecutionControls
  featureId={activeFeatureId}
  onUndo={undo}
  onRedo={redo}
  canUndo={historyState.canUndo}
  canRedo={historyState.canRedo}
/>
```

Remove the TODO comments and placeholder values.
  </action>
  <verify>npm run dev shows working undo/redo buttons</verify>
  <done>Undo/redo connected to DAG view</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] History types defined
- [ ] HistoryManager stores up to 20 versions
- [ ] DAG changes push new versions
- [ ] Undo restores previous graph state
- [ ] Redo restores forward graph state
- [ ] Undo/redo buttons enable/disable correctly
- [ ] History persists to dag_history/ directory
</verification>

<success_criteria>
- 20-version history limit enforced
- Undo/redo updates graph and saves to disk
- History state tracked in dag-store
- ExecutionControls shows correct button states
- AI batch operations create single version
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-integration/07-03-SUMMARY.md` with:
- Tasks completed
- Files created/modified
- Key decisions
- Ready for 07-04
</output>
