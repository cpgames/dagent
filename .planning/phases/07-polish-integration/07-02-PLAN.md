---
phase: 07-polish-integration
plan: 02
type: execute
---

<objective>
Implement Play/Stop execution controls connecting UI to orchestrator.

Purpose: Enable users to start and stop task execution from the DAG view.
Output: Functional Play/Stop buttons with execution state feedback per DAGENT_SPEC 6.3/6.5.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-polish-integration/07-01-SUMMARY.md
@src/main/dag-engine/orchestrator.ts
@src/main/ipc/execution-handlers.ts
@src/renderer/src/views/DAGView.tsx
@src/preload/index.ts

**Existing orchestrator methods:**
- start() - Begin execution
- pause() - Pause (running tasks complete current operation)
- resume() - Resume after pause
- stop() - Stop and reset
- getState() - Get current ExecutionState

**ExecutionState status values:**
- 'idle' - Not started
- 'running' - Actively executing tasks
- 'paused' - Paused by user
- 'completed' - All tasks done

**From DAGENT_SPEC 6.5 - Stop Behavior:**
1. Signal sent to harness
2. Harness signals all active task/merge agents
3. Agents complete current atomic operation then halt
4. In-progress tasks remain in running/merging state
5. Can resume with Play

**Tech stack:** Zustand, React, Electron IPC
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create execution store for renderer</name>
  <files>src/renderer/src/stores/execution-store.ts, src/renderer/src/stores/index.ts</files>
  <action>
Create Zustand store for execution state:

```typescript
import { create } from 'zustand';

type ExecutionStatus = 'idle' | 'running' | 'paused' | 'completed';

interface ExecutionState {
  status: ExecutionStatus;
  featureId: string | null;
  error: string | null;
  startedAt: string | null;
}

interface ExecutionStoreState {
  execution: ExecutionState;
  isLoading: boolean;

  // Actions
  start: (featureId: string) => Promise<{ success: boolean; error?: string }>;
  pause: () => Promise<{ success: boolean; error?: string }>;
  resume: () => Promise<{ success: boolean; error?: string }>;
  stop: () => Promise<{ success: boolean; error?: string }>;
  getState: () => Promise<void>;
}

export const useExecutionStore = create<ExecutionStoreState>((set) => ({
  execution: {
    status: 'idle',
    featureId: null,
    error: null,
    startedAt: null
  },
  isLoading: false,

  start: async (featureId) => {
    set({ isLoading: true });
    try {
      const result = await window.electronAPI.execution.start(featureId);
      if (result.success) {
        const state = await window.electronAPI.execution.getState();
        set({ execution: state, isLoading: false });
      } else {
        set({ isLoading: false });
      }
      return result;
    } catch (error) {
      set({ isLoading: false });
      return { success: false, error: String(error) };
    }
  },

  pause: async () => {
    set({ isLoading: true });
    try {
      const result = await window.electronAPI.execution.pause();
      if (result.success) {
        const state = await window.electronAPI.execution.getState();
        set({ execution: state, isLoading: false });
      } else {
        set({ isLoading: false });
      }
      return result;
    } catch (error) {
      set({ isLoading: false });
      return { success: false, error: String(error) };
    }
  },

  resume: async () => {
    set({ isLoading: true });
    try {
      const result = await window.electronAPI.execution.resume();
      if (result.success) {
        const state = await window.electronAPI.execution.getState();
        set({ execution: state, isLoading: false });
      } else {
        set({ isLoading: false });
      }
      return result;
    } catch (error) {
      set({ isLoading: false });
      return { success: false, error: String(error) };
    }
  },

  stop: async () => {
    set({ isLoading: true });
    try {
      const result = await window.electronAPI.execution.stop();
      if (result.success) {
        set({
          execution: {
            status: 'idle',
            featureId: null,
            error: null,
            startedAt: null
          },
          isLoading: false
        });
      } else {
        set({ isLoading: false });
      }
      return result;
    } catch (error) {
      set({ isLoading: false });
      return { success: false, error: String(error) };
    }
  },

  getState: async () => {
    try {
      const state = await window.electronAPI.execution.getState();
      set({ execution: state });
    } catch {
      // Ignore errors, keep current state
    }
  }
}));
```

Update stores/index.ts to export useExecutionStore.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Execution store with start/pause/resume/stop actions</done>
</task>

<task type="auto">
  <name>Task 2: Update execution IPC handlers</name>
  <files>src/main/ipc/execution-handlers.ts</files>
  <action>
Update execution handlers to support feature-based execution:

The existing handlers should be updated to:

1. Add 'execution:start' handler that:
   - Takes featureId as parameter
   - Loads the feature's DAG from storage
   - Initializes the orchestrator with the graph
   - Calls orchestrator.start()

2. Ensure 'execution:getState' returns ExecutionState matching renderer's expected shape:
```typescript
{
  status: ExecutionStatus;
  featureId: string | null;
  error: string | null;
  startedAt: string | null;
}
```

3. Add 'execution:pause' handler calling orchestrator.pause()
4. Add 'execution:resume' handler calling orchestrator.resume()
5. Ensure 'execution:stop' handler exists

Review existing execution-handlers.ts and update as needed. The orchestrator already has these methods.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Execution IPC handlers support feature-based start</done>
</task>

<task type="auto">
  <name>Task 3: Update preload with execution API</name>
  <files>src/preload/index.ts</files>
  <action>
Ensure preload exposes execution methods. Add if missing:

```typescript
execution: {
  start: (featureId: string) => ipcRenderer.invoke('execution:start', featureId),
  pause: () => ipcRenderer.invoke('execution:pause'),
  resume: () => ipcRenderer.invoke('execution:resume'),
  stop: () => ipcRenderer.invoke('execution:stop'),
  getState: () => ipcRenderer.invoke('execution:getState')
}
```

Verify the existing preload has these or add them.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Preload exposes execution API</done>
</task>

<task type="auto">
  <name>Task 4: Create ExecutionControls component</name>
  <files>src/renderer/src/components/DAG/ExecutionControls.tsx, src/renderer/src/components/DAG/index.ts</files>
  <action>
Create ExecutionControls component for the control bar:

```tsx
import type { JSX } from 'react';
import { useExecutionStore } from '../../stores/execution-store';

interface ExecutionControlsProps {
  featureId: string | null;
  onUndo?: () => void;
  onRedo?: () => void;
  canUndo?: boolean;
  canRedo?: boolean;
}

// Play icon SVG
const PlayIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
      d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
      d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

// Pause icon SVG
const PauseIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
      d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

// Stop icon SVG
const StopIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
      d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
      d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z" />
  </svg>
);

// Undo icon SVG
const UndoIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
      d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
  </svg>
);

// Redo icon SVG
const RedoIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
      d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6" />
  </svg>
);

export default function ExecutionControls({
  featureId,
  onUndo,
  onRedo,
  canUndo = false,
  canRedo = false
}: ExecutionControlsProps): JSX.Element {
  const { execution, isLoading, start, pause, resume, stop } = useExecutionStore();
  const { status } = execution;

  const isRunning = status === 'running';
  const isPaused = status === 'paused';
  const isIdle = status === 'idle' || status === 'completed';

  const handlePlayPause = async () => {
    if (isRunning) {
      await pause();
    } else if (isPaused) {
      await resume();
    } else if (featureId) {
      await start(featureId);
    }
  };

  const handleStop = async () => {
    await stop();
  };

  const buttonBase = 'px-3 py-1.5 rounded text-sm flex items-center gap-1 transition-colors';
  const activeButton = 'bg-gray-700 hover:bg-gray-600 text-white';
  const disabledButton = 'bg-gray-700 text-gray-400 cursor-not-allowed';

  return (
    <div className="flex items-center gap-2">
      {/* Play/Pause button */}
      <button
        onClick={handlePlayPause}
        disabled={isLoading || !featureId}
        className={`${buttonBase} ${!isLoading && featureId ? activeButton : disabledButton}`}
        title={isRunning ? 'Pause execution' : isPaused ? 'Resume execution' : 'Start execution'}
      >
        {isRunning ? <PauseIcon /> : <PlayIcon />}
        {isRunning ? 'Pause' : isPaused ? 'Resume' : 'Play'}
      </button>

      {/* Stop button */}
      <button
        onClick={handleStop}
        disabled={isLoading || isIdle}
        className={`${buttonBase} ${!isLoading && !isIdle ? activeButton : disabledButton}`}
        title="Stop execution"
      >
        <StopIcon />
        Stop
      </button>

      <div className="border-l border-gray-600 mx-2 h-6" />

      {/* Undo button */}
      <button
        onClick={onUndo}
        disabled={!canUndo}
        className={`${buttonBase} ${canUndo ? activeButton : disabledButton}`}
        title="Undo"
      >
        <UndoIcon />
        Undo
      </button>

      {/* Redo button */}
      <button
        onClick={onRedo}
        disabled={!canRedo}
        className={`${buttonBase} ${canRedo ? activeButton : disabledButton}`}
        title="Redo"
      >
        <RedoIcon />
        Redo
      </button>

      {/* Status indicator */}
      {!isIdle && (
        <div className="ml-4 text-sm">
          <span className={`inline-block w-2 h-2 rounded-full mr-2 ${
            isRunning ? 'bg-yellow-500 animate-pulse' :
            isPaused ? 'bg-blue-500' : 'bg-gray-500'
          }`} />
          <span className="text-gray-400">
            {isRunning ? 'Running...' : isPaused ? 'Paused' : status}
          </span>
        </div>
      )}
    </div>
  );
}
```

Update components/DAG/index.ts to export ExecutionControls.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>ExecutionControls component with Play/Pause/Stop/Undo/Redo buttons</done>
</task>

<task type="auto">
  <name>Task 5: Integrate ExecutionControls into DAGView</name>
  <files>src/renderer/src/views/DAGView.tsx</files>
  <action>
Replace the current disabled control bar with ExecutionControls:

1. Import ExecutionControls from components/DAG
2. Replace the hardcoded disabled buttons in the control bar with ExecutionControls
3. Pass activeFeatureId to ExecutionControls
4. Pass placeholder undo/redo handlers (will be implemented in 07-03)

The control bar section should become:
```tsx
{/* Control bar at bottom */}
<div className="border-t border-gray-700 bg-gray-800 px-4 py-2">
  <ExecutionControls
    featureId={activeFeatureId}
    onUndo={() => {}} // TODO: 07-03
    onRedo={() => {}} // TODO: 07-03
    canUndo={false}   // TODO: 07-03
    canRedo={false}   // TODO: 07-03
  />
</div>
```

Remove the old hardcoded button JSX.
  </action>
  <verify>npm run dev shows working Play/Stop controls</verify>
  <done>DAGView uses ExecutionControls component</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] Execution store tracks execution state
- [ ] Play button starts execution when feature selected
- [ ] Pause button pauses running execution
- [ ] Resume button continues paused execution
- [ ] Stop button stops execution
- [ ] Status indicator shows current state
- [ ] Buttons disabled appropriately based on state
</verification>

<success_criteria>
- ExecutionControls component created
- Execution store with start/pause/resume/stop
- IPC handlers connect UI to orchestrator
- Visual feedback for execution state
- Buttons enable/disable based on context
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-integration/07-02-SUMMARY.md` with:
- Tasks completed
- Files created/modified
- Key decisions
- Ready for 07-03
</output>
