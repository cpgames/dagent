---
phase: 50-queue-based-pools
plan: 02
type: execute
---

<objective>
Integrate queue-based pools into orchestrator and update agent event signaling.

Purpose: Make orchestrator the sole owner of pool movements, with agents signaling completion via events rather than manipulating pools directly.
Output: Orchestrator uses assignment queues for work discovery, agents decoupled from pool mechanics.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v2.2-ROADMAP.md
@.planning/phases/50-queue-based-pools/50-01-SUMMARY.md

**Key files:**
@src/main/dag-engine/orchestrator.ts
@src/main/dag-engine/cascade.ts
@src/main/agents/task-agent.ts
@src/main/agents/qa-agent.ts
@src/main/agents/merge-agent.ts

**Dependencies from 50-01:**
- TaskStatus type updated with queue-based names
- TaskPoolManager uses new pool structure
- Task state machine transitions updated

**Key insight:** Orchestrator monitors assignment queues:
- ready_for_dev → assign dev agent
- ready_for_qa → assign QA agent
- ready_for_merge → assign merge agent

Agents signal completion via their existing events/status. Orchestrator handles all pool transitions.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update orchestrator pool references</name>
  <files>src/main/dag-engine/orchestrator.ts</files>
  <action>
Update all pool status references to use new names:

1. In getNextTasks():
- Change: `poolManager.getPool('ready')` → `poolManager.getPool('ready_for_dev')`

2. In handleQATasks():
- Change: `poolManager.getPool('qa')` → `poolManager.getPool('ready_for_qa')`

3. In handleQAResult():
- On pass: move from 'ready_for_qa' to 'ready_for_merge', then to 'in_progress' when merge starts
- On fail: move from 'ready_for_qa' to 'in_progress' (dev rework)
- Update pool move calls accordingly

4. In assignTask():
- Change: 'ready' to 'ready_for_dev' in status check
- Update pool move: 'ready_for_dev' → 'in_progress'

5. In completeTaskCode():
- Change: 'dev' to 'in_progress' in status check
- Update pool move: 'in_progress' → 'ready_for_qa'

6. In completeMerge():
- Change: 'merging' to 'in_progress' in status check
- Update pool move: 'in_progress' → 'completed'

7. In failTask():
- Handle failure from any in_progress state
- Update pool move: 'in_progress' → 'failed'

8. Update cascade handling:
- Unblocked tasks go to 'ready_for_dev' (not 'ready')
  </action>
  <verify>npx tsc --noEmit passes on orchestrator.ts</verify>
  <done>Orchestrator uses new pool names throughout</done>
</task>

<task type="auto">
  <name>Task 2: Update cascade.ts for new status names</name>
  <files>src/main/dag-engine/cascade.ts</files>
  <action>
Update cascade logic to use new status names:

1. In cascadeTaskCompletion():
- When unblocking tasks, set status to 'ready_for_dev' (not 'ready')
- Update any 'ready' references to 'ready_for_dev'

2. In recalculateAllStatuses():
- Update initial status calculation:
  - No dependencies → 'ready_for_dev'
  - Has incomplete dependencies → 'blocked'
- Update any 'ready' references to 'ready_for_dev'

3. Update helper functions that check/set status values
  </action>
  <verify>npx tsc --noEmit passes on cascade.ts</verify>
  <done>Cascade logic uses new queue-based status names</done>
</task>

<task type="auto">
  <name>Task 3: Verify agent signaling (no pool manipulation)</name>
  <files>src/main/agents/task-agent.ts, src/main/agents/qa-agent.ts, src/main/agents/merge-agent.ts</files>
  <action>
Review and verify that agents don't directly manipulate pools:

1. TaskAgent (task-agent.ts):
- Verify: No direct calls to TaskPoolManager
- Verify: Signals via status ('ready_for_merge', 'failed') and events
- No changes needed if already using events

2. QAAgent (qa-agent.ts):
- Verify: No direct calls to TaskPoolManager
- Verify: Returns QAReviewResult to orchestrator
- Orchestrator handles pool transitions based on result
- No changes needed if already using results

3. MergeAgent (merge-agent.ts):
- Verify: No direct calls to TaskPoolManager
- Verify: Returns merge result to orchestrator
- Orchestrator handles pool transitions based on result
- No changes needed if already using results

If any agent DOES manipulate pools directly, remove that code and ensure it signals via events/results instead.

Note: Agents may reference TaskStatus type for their internal state tracking - that's fine. They just shouldn't call getTaskPoolManager().moveTask() directly.
  </action>
  <verify>grep -r "getTaskPoolManager" src/main/agents/ returns no results (or only imports without usage)</verify>
  <done>Agents signal via events, don't manipulate pools directly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes for all modified files
- [ ] Orchestrator checks 'ready_for_dev' for task assignment
- [ ] Orchestrator checks 'ready_for_qa' for QA agent spawning
- [ ] Orchestrator moves tasks through: ready_for_dev → in_progress → ready_for_qa → in_progress → ready_for_merge → in_progress → completed
- [ ] Agents don't directly call TaskPoolManager methods
- [ ] No grep hits for "getTaskPoolManager" in src/main/agents/ (except imports)
</verification>

<success_criteria>
- Orchestrator compiles with new pool names
- Cascade logic uses ready_for_dev for unblocked tasks
- Agents signal via events/results, not pool manipulation
- Full build passes
- Phase 50 complete
</success_criteria>

<output>
After completion, create `.planning/phases/50-queue-based-pools/50-02-SUMMARY.md`
</output>
