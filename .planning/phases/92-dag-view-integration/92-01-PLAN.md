---
phase: 92-dag-view-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/src/stores/dag-store.ts
  - src/renderer/src/views/DAGView.tsx
autonomous: true

must_haves:
  truths:
    - "DAGView uses DAGManager API for all graph mutations"
    - "Cycle detection prevents invalid connections from being added"
    - "DAG state updates reactively when DAGManager emits events"
  artifacts:
    - path: "src/renderer/src/stores/dag-store.ts"
      provides: "DAGManager integration and event subscriptions"
      min_lines: 200
      exports: ["useDAGStore"]
    - path: "src/renderer/src/views/DAGView.tsx"
      provides: "DAG view using validated operations"
      min_lines: 400
  key_links:
    - from: "src/renderer/src/stores/dag-store.ts"
      to: "DAGManager"
      via: "Import and initialize DAGManager instance"
      pattern: "DAGManager"
    - from: "src/renderer/src/stores/dag-store.ts"
      to: "DAGManager events"
      via: "Event listeners for reactive updates"
      pattern: "dagManager\\.on\\("
    - from: "src/renderer/src/views/DAGView.tsx"
      to: "src/renderer/src/stores/dag-store.ts"
      via: "Uses store methods that call DAGManager"
      pattern: "useDAGStore"
---

<objective>
Wire DAGView to use DAGManager API for all graph mutations, replacing direct React Flow state manipulation with validated operations and event-driven updates.

Purpose: Centralize DAG operations through single source of truth with cycle detection, enabling validated connections and consistent graph state.
Output: DAGView and dag-store using DAGManager for all mutations, with event subscriptions for reactive updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v2.8-ROADMAP.md
@.planning/STATE.md
@.planning/phases/90-dag-api-core/90-01-SUMMARY.md
@.planning/phases/91-vertical-node-ui/91-01-SUMMARY.md
@src/renderer/src/stores/dag-store.ts
@src/renderer/src/views/DAGView.tsx
@src/main/dag-engine/dag-manager.ts
@src/main/dag-engine/dag-api-types.ts
@src/main/dag-engine/dag-validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate DAGManager into dag-store</name>
  <files>src/renderer/src/stores/dag-store.ts</files>
  <action>
1. Import DAGManager and related types from main process (will need to expose via IPC)
2. Add dagManager instance to store state (initially null)
3. Create `initializeDAGManager(featureId, projectRoot)` action that:
   - Creates DAGManager instance via IPC handler
   - Subscribes to all DAGManager events (node-added, node-removed, connection-added, connection-removed, node-moved, graph-reset)
   - Updates local dag state when events are emitted
4. Refactor existing mutation methods to call DAGManager API instead of direct state manipulation:
   - `addNode()` → call dagManager.addNode(), update local state on event
   - `removeNode()` → call dagManager.removeNode(), update local state on event
   - `addConnection()` → call dagManager.addConnection(), handle validation errors (cycle detection), show toast on failure
   - `removeConnection()` → call dagManager.removeConnection(), update local state on event
   - `updateNode()` → keep existing direct implementation (position updates don't need validation)
5. Keep history integration (pushVersion) for undo/redo support
6. Add error handling for failed validation (show user-friendly toast messages)
7. Ensure event-driven updates don't conflict with history pushVersion calls

WHY this approach:
- DAGManager runs in main process (has access to storage), so we need IPC bridge
- Event subscriptions ensure reactive UI updates when graph changes
- Validation happens before mutations, preventing invalid graph states
- History snapshots capture validated state changes
  </action>
  <verify>
TypeScript compilation passes with no errors
Grep confirms dagManager.addNode/removeNode/addConnection patterns exist
Grep confirms event listener registration (.on('node-added', ...))
  </verify>
  <done>
dag-store uses DAGManager API for all mutations with event subscriptions
Validation errors display user-friendly toast messages
History integration preserved for undo/redo
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DAGManager IPC bridge</name>
  <files>
src/main/ipc/dag-handlers.ts,
src/preload/index.ts,
src/shared/types/electron-api.ts
  </files>
  <action>
1. Create new IPC handlers in `src/main/ipc/dag-handlers.ts`:
   - `dag:create-manager` - Initialize DAGManager for a feature
   - `dag:add-node` - Proxy to dagManager.addNode()
   - `dag:remove-node` - Proxy to dagManager.removeNode()
   - `dag:add-connection` - Proxy to dagManager.addConnection() (returns null on validation failure)
   - `dag:remove-connection` - Proxy to dagManager.removeConnection()
   - `dag:move-node` - Proxy to dagManager.moveNode()
   - `dag:get-graph` - Get current graph state
   - Event emitters for each DAGEvent type to send to renderer
2. Register handlers in main process IPC setup
3. Expose IPC methods in preload script under `window.electronAPI.dagManager`
4. Update electron-api.ts types to include dagManager methods
5. Set up event forwarding: when DAGManager emits events in main process, forward to renderer via IPC
6. Store DAGManager instances per featureId (Map<string, DAGManager>) for multi-feature support

WHY this approach:
- DAGManager needs to run in main process to access FeatureStore directly
- IPC bridge allows renderer to call DAGManager methods asynchronously
- Event forwarding keeps renderer state in sync with source of truth in main process
- Per-feature manager instances support switching between features
  </action>
  <verify>
TypeScript compilation passes
Grep confirms IPC handler registration (ipcMain.handle)
Grep confirms preload API exposure (dagManager: { ... })
  </verify>
  <done>
IPC bridge complete with all DAGManager methods exposed
Event forwarding configured for reactive updates
Preload API typed correctly in electron-api.ts
  </done>
</task>

<task type="auto">
  <name>Task 3: Update DAGView to show validation feedback</name>
  <files>src/renderer/src/views/DAGView.tsx</files>
  <action>
1. Update `handleConnect` callback to await validation result from addConnection
2. If connection validation fails (returns null from dagManager.addConnection):
   - Do NOT add edge to React Flow (prevent visual feedback of invalid connection)
   - Show toast error message with validation reason: "Cannot add connection: [reason]" (e.g., "would create cycle")
3. Remove direct React Flow edge addition (`setEdges((eds) => addEdge(connection, eds))`)
4. Let event-driven updates from dag-store handle edge additions (only adds edges that pass validation)
5. Add visual feedback during connection attempt:
   - Optional: Show temporary connecting line while validation occurs
   - On validation success: edge appears via event update
   - On validation failure: line disappears and error toast shows
6. Ensure connection validation errors are user-friendly (not raw error strings)

WHY this approach:
- Prevents user from creating invalid connections (cycles)
- Immediate feedback on why connection was rejected
- Event-driven updates ensure UI state matches validated graph state
- User understands validation rules through clear error messages
  </action>
  <verify>
Grep confirms handleConnect calls addConnection and checks return value
Grep confirms error toast display for validation failures
TypeScript compilation passes
Build succeeds
  </verify>
  <done>
DAGView shows validation errors when connections fail
Invalid connections are prevented and explained to user
UI updates only reflect validated graph changes
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compilation passes with no errors
- [ ] Build succeeds (`npm run build`)
- [ ] Grep confirms DAGManager usage in dag-store (addNode, addConnection, etc.)
- [ ] Grep confirms event listeners registered (.on('node-added', ...))
- [ ] Grep confirms IPC handlers created (ipcMain.handle('dag:...'))
- [ ] Grep confirms validation error handling in DAGView (toast.error for failed connections)
</verification>

<success_criteria>
- All tasks completed
- DAGView uses DAGManager API for all graph mutations
- Cycle detection prevents invalid connections
- User sees clear error messages when validation fails
- Event-driven updates keep UI in sync with graph state
- History integration (undo/redo) still works
- No TypeScript errors or build failures
</success_criteria>

<output>
After completion, create `.planning/phases/92-dag-view-integration/92-01-SUMMARY.md`
</output>
