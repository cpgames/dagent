---
phase: 44-qa-agent
plan: 02
title: QA Agent Orchestrator Integration
subsystem: dag-engine
tags: [qa-agent, orchestrator, dev-feedback-loop]

# Dependency graph
requires:
  - phase: 44-qa-agent
    plan: 01
    provides: QAAgent class with review capability
provides:
  - QA agent spawning in orchestrator
  - Dev → QA → Dev feedback loop
  - Dev agent reads qaFeedback context
affects: [45-communication-refactor]

# Research requirements
research:
  needed: false
---

<objective>
Integrate QA Agent with orchestrator for automatic code review after dev completion.

Purpose: Complete the dev → qa → merging pipeline. When dev commits, QA reviews. If QA fails, dev gets feedback and reworks.

Output: Full QA integration with automatic review and feedback loop.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/44-qa-agent/44-01-PLAN.md

# Key files:
@src/main/dag-engine/orchestrator.ts
@src/main/dag-engine/task-pool.ts
@src/main/agents/task-agent.ts
@src/main/agents/qa-agent.ts
@src/shared/types/task.ts

**Tech stack available:**
- QAAgent class from 44-01
- TaskPoolManager with qa pool
- State transitions: DEV_COMPLETE (dev→qa), QA_PASSED (qa→merging), QA_FAILED (qa→dev)
- Task.qaFeedback field

**Established patterns:**
- Orchestrator tick loop checks for work
- handleCompletedTasks() processes agent results
- Pool-based task lookup via getTaskPoolManager()
- State changes update pools via moveTask()

**Constraining decisions:**
- QA is autonomous (no harness communication)
- QA_FAILED stores feedback in task.qaFeedback and transitions to dev
- Priority order: merging > qa > ready
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QA Agent Spawning to Orchestrator</name>
  <files>src/main/dag-engine/orchestrator.ts</files>
  <action>
Add QA agent handling to orchestrator tick loop:

1. **Import QA agent functions:**
   ```typescript
   import { createQAAgent, registerQAAgent, getQAAgent, removeQAAgent, getAllQAAgents } from '../agents/qa-agent'
   ```

2. **Add handleQATasks() method** - Process tasks in qa state:
   ```typescript
   private async handleQATasks(): Promise<void> {
     const poolManager = getTaskPoolManager()
     const qaTasks = poolManager.getPool('qa')

     for (const taskId of qaTasks) {
       // Skip if QA agent already exists for this task
       if (getQAAgent(taskId)) continue

       const task = this.state.graph!.nodes.find(n => n.id === taskId)
       if (!task) continue

       // Get worktree path from task agent (if still exists) or construct it
       const taskAgent = getTaskAgent(taskId)
       const worktreePath = taskAgent?.getState().worktreePath

       if (!worktreePath) {
         // Task agent already cleaned up, construct path
         const gitManager = getGitManager()
         const config = gitManager.getConfig()
         const worktreeName = getTaskWorktreeName(this.state.featureId!, taskId)
         worktreePath = path.join(config.worktreesDir, worktreeName)
       }

       // Spawn QA agent
       const qaAgent = createQAAgent(this.state.featureId!, taskId)
       const initialized = await qaAgent.initialize(task.title, task.description, worktreePath)

       if (initialized) {
         registerQAAgent(qaAgent)
         // Execute review (non-blocking)
         qaAgent.execute().then(result => this.handleQAResult(taskId, result))
       }
     }
   }
   ```

3. **Add handleQAResult() method** - Process QA results:
   ```typescript
   private handleQAResult(taskId: string, result: QAReviewResult): void {
     const task = this.state.graph!.nodes.find(n => n.id === taskId)
     if (!task) return

     if (result.passed) {
       // QA passed → transition to merging
       const transitionResult = transitionTask(task, 'QA_PASSED')
       if (transitionResult.success) {
         getTaskPoolManager().moveTask(taskId, 'qa', 'merging')
         this.history.push(createStateChangeRecord(taskId, 'qa', 'merging', 'QA_PASSED'))
       }
     } else {
       // QA failed → store feedback and transition back to dev
       task.qaFeedback = result.feedback
       const transitionResult = transitionTask(task, 'QA_FAILED')
       if (transitionResult.success) {
         getTaskPoolManager().moveTask(taskId, 'qa', 'dev')
         this.history.push(createStateChangeRecord(taskId, 'qa', 'dev', 'QA_FAILED'))
       }
     }

     // Cleanup QA agent
     const qaAgent = getQAAgent(taskId)
     if (qaAgent) {
       qaAgent.cleanup()
       removeQAAgent(taskId)
     }
   }
   ```

4. **Call handleQATasks() in tick()** - Add after handleCompletedTasks():
   ```typescript
   // Handle QA reviews
   await this.handleQATasks()
   ```

5. **Update stop() to cleanup QA agents:**
   ```typescript
   // Cleanup QA agents
   for (const agent of getAllQAAgents()) {
     await agent.cleanup()
   }
   clearQAAgents()
   ```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit -p tsconfig.node.json`</verify>
  <done>QA agent spawning integrated with orchestrator tick loop</done>
</task>

<task type="auto">
  <name>Task 2: Update Dev Agent to Include QA Feedback</name>
  <files>src/main/agents/task-agent.ts</files>
  <action>
Update TaskAgent to include qaFeedback in execution context when re-running after QA failure:

1. **Update loadContext() to store qaFeedback:**
   - Add qaFeedback field to TaskContext interface in task-types.ts:
     ```typescript
     qaFeedback?: string // Feedback from QA if this is a rework cycle
     ```
   - In loadContext(), check task.qaFeedback and store it:
     ```typescript
     this.state.context = {
       ...existingFields,
       qaFeedback: task.qaFeedback || undefined
     }
     ```

2. **Update buildExecutionPrompt() to include QA feedback:**
   ```typescript
   if (context.qaFeedback) {
     parts.push(
       '## QA Feedback (IMPORTANT - Fix these issues)',
       context.qaFeedback,
       ''
     )
   }
   ```

This ensures dev agent sees what QA flagged and can address the issues.
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>Dev agent includes QA feedback in execution context when reworking</done>
</task>

<task type="auto">
  <name>Task 3: Update Task Type for QA Feedback Context</name>
  <files>src/main/agents/task-types.ts</files>
  <action>
Add qaFeedback to TaskContext interface:

```typescript
export interface TaskContext {
  // Project-level context
  claudeMd: string | null
  featureGoal: string | null

  // Task-specific context
  taskDescription: string
  taskTitle: string

  // Dependency context (from completed parent tasks)
  dependencyContext: DependencyContextEntry[]

  // QA feedback (if reworking after QA failure)
  qaFeedback?: string

  // Working directory
  worktreePath: string
}
```

This is a simple type extension to support the QA feedback loop.
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>TaskContext includes qaFeedback field, build passes</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] Orchestrator spawns QA agents for tasks in qa state
- [ ] QA pass transitions task to merging
- [ ] QA fail stores feedback and transitions task to dev
- [ ] Dev agent prompt includes QA feedback when reworking
- [ ] QA agents properly cleaned up on stop
</verification>

<success_criteria>

- Full dev → qa → merging pipeline working
- QA failure triggers rework loop with feedback
- Dev agent sees QA feedback in context
- Pool transitions correct for QA pass/fail
- All verification checks pass
- Phase 44 complete
</success_criteria>

<output>
After completion, create `.planning/phases/44-qa-agent/44-02-SUMMARY.md` following the summary template.
</output>
