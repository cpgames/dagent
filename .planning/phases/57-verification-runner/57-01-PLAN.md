---
phase: 57-verification-runner
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/agents/verification-types.ts
  - src/main/agents/verification-runner.ts
autonomous: true
must_haves:
  truths:
    - "VerificationRunner can detect available npm scripts in a worktree"
    - "VerificationRunner can run build/lint/test commands"
    - "Command output is captured and truncated appropriately"
    - "Exit codes determine pass/fail status"
  artifacts:
    - path: "src/main/agents/verification-types.ts"
      provides: "VerificationCheck, VerificationResult interfaces"
      exports: ["VerificationCheck", "VerificationResult", "VerificationCheckId", "CommandResult", "DEFAULT_VERIFICATION_CHECKS"]
    - path: "src/main/agents/verification-runner.ts"
      provides: "VerificationRunner class for executing checks"
      exports: ["VerificationRunner", "getVerificationRunner"]
  key_links:
    - from: "verification-runner.ts"
      to: "task-plan-types.ts"
      via: "Uses ChecklistStatus type for results"
      pattern: "ChecklistStatus"
    - from: "verification-runner.ts"
      to: "child_process"
      via: "execFile for running commands"
      pattern: "execFile"
---

<objective>
Create VerificationRunner class for automated build/lint/test verification in worktrees.

Purpose: Enable Ralph Loop to run automated verification checks after each DevAgent iteration. The runner detects available npm scripts, executes them in the worktree, captures output, and returns structured results.

Output: Two new files (verification-types.ts, verification-runner.ts) implementing the verification system.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 56 deliverables (types we'll use):
@src/main/agents/task-plan-types.ts

# Pattern to follow for shell command execution:
@src/main/github/pr-service.ts

# Context service for project detection patterns:
@src/main/context/context-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create verification types</name>
  <files>src/main/agents/verification-types.ts</files>
  <action>
Create new file with TypeScript interfaces for verification checks.

**Types to define:**

1. `VerificationCheckId` - literal union: 'build' | 'lint' | 'test'

2. `CommandResult` interface:
   - `exitCode: number` - process exit code (0 = success)
   - `stdout: string` - captured stdout (truncated)
   - `stderr: string` - captured stderr (truncated)
   - `duration: number` - execution time in milliseconds
   - `timedOut?: boolean` - true if command exceeded timeout

3. `VerificationCheck` interface:
   - `id: VerificationCheckId`
   - `description: string` - e.g., "Build passes without errors"
   - `command: string` - e.g., "npm run build"
   - `required: boolean` - true for build, false for lint/test
   - `continueOnFail?: boolean` - if true, run next check even if this fails (lint)

4. `VerificationResult` interface:
   - `checkId: VerificationCheckId`
   - `passed: boolean` - exitCode === 0
   - `command: string` - actual command run
   - `result: CommandResult` - full command result
   - `error?: string` - formatted error message if failed

**Constants to export:**

`DEFAULT_VERIFICATION_CHECKS: VerificationCheck[]` with:
- { id: 'build', description: 'Build passes without errors', command: 'npm run build', required: true }
- { id: 'lint', description: 'Lint passes', command: 'npm run lint', required: false, continueOnFail: true }
- { id: 'test', description: 'Tests pass', command: 'npm test', required: false }

`MAX_OUTPUT_LENGTH = 2000` - truncation limit for stdout/stderr

`DEFAULT_TIMEOUT = 300000` - 5 minute timeout per command

**Pattern to follow:** Match style of task-plan-types.ts with JSDoc comments, organized sections.
  </action>
  <verify>npx tsc --noEmit src/main/agents/verification-types.ts</verify>
  <done>verification-types.ts exports all interfaces and constants, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 2: Create VerificationRunner class</name>
  <files>src/main/agents/verification-runner.ts</files>
  <action>
Create new file with VerificationRunner class for executing checks in worktrees.

**Class structure:**

```typescript
import { execFile } from 'child_process'
import { promisify } from 'util'
import * as fs from 'fs/promises'
import * as path from 'path'
import type { ChecklistStatus } from './task-plan-types'
import type {
  VerificationCheck,
  VerificationResult,
  VerificationCheckId,
  CommandResult
} from './verification-types'
import {
  DEFAULT_VERIFICATION_CHECKS,
  MAX_OUTPUT_LENGTH,
  DEFAULT_TIMEOUT
} from './verification-types'

const execFileAsync = promisify(execFile)

export class VerificationRunner {
  constructor(private worktreePath: string) {}

  /**
   * Detect which npm scripts are available in the worktree.
   * Reads package.json and returns available script names.
   */
  async detectAvailableScripts(): Promise<Set<string>>

  /**
   * Check if a specific verification command is available.
   * For npm commands, checks if script exists in package.json.
   */
  async isCheckAvailable(check: VerificationCheck): Promise<boolean>

  /**
   * Run a single verification check.
   * Executes command in worktree, captures output, returns structured result.
   */
  async runCheck(check: VerificationCheck): Promise<VerificationResult>

  /**
   * Run all applicable verification checks.
   * Skips unavailable checks (e.g., no lint script).
   * Respects continueOnFail settings.
   * @param config Optional overrides for which checks to run
   */
  async runAllChecks(config?: {
    runBuild?: boolean
    runLint?: boolean
    runTests?: boolean
    buildCommand?: string
    lintCommand?: string
    testCommand?: string
  }): Promise<VerificationResult[]>

  /**
   * Convert verification result to ChecklistStatus for TaskPlan.
   */
  resultToStatus(result: VerificationResult): ChecklistStatus

  /**
   * Format verification results into human-readable summary.
   */
  formatResultsSummary(results: VerificationResult[]): string

  /**
   * Run a command in the worktree and capture output.
   * Private helper for runCheck.
   */
  private async executeCommand(
    command: string,
    args: string[],
    timeout?: number
  ): Promise<CommandResult>
}
```

**Implementation details:**

1. `detectAvailableScripts`:
   - Read `{worktreePath}/package.json`
   - Parse JSON and extract `scripts` object keys
   - Return Set of script names
   - Return empty Set if package.json doesn't exist or has no scripts

2. `isCheckAvailable`:
   - For npm commands (starts with 'npm run' or 'npm test'):
     - Extract script name from command
     - Check if script exists in detected scripts
   - For other commands: assume available (true)

3. `executeCommand`:
   - Use `execFileAsync` with shell: true on Windows (cross-platform)
   - Set cwd to worktreePath
   - Set timeout from DEFAULT_TIMEOUT
   - Capture stdout and stderr
   - Truncate output to MAX_OUTPUT_LENGTH
   - Track execution duration
   - Handle timeout errors specially (set timedOut: true)

4. `runCheck`:
   - Parse command into executable and args (split on spaces, handle 'npm run X')
   - Call executeCommand
   - Build VerificationResult with passed = (exitCode === 0)
   - Format error message if failed

5. `runAllChecks`:
   - Build check list from DEFAULT_VERIFICATION_CHECKS with config overrides
   - Filter by config (runBuild, runLint, runTests)
   - For each check:
     - Skip if not available (via isCheckAvailable)
     - Run check
     - If failed and !continueOnFail, stop and return results so far
   - Return all results

6. `resultToStatus`:
   - If passed: return 'pass'
   - If not passed: return 'fail'

7. `formatResultsSummary`:
   - Build multi-line string summarizing each result
   - Include check name, passed/failed, duration
   - Include truncated error output for failures

**Singleton pattern:**

```typescript
const runners = new Map<string, VerificationRunner>()

export function getVerificationRunner(worktreePath: string): VerificationRunner {
  let runner = runners.get(worktreePath)
  if (!runner) {
    runner = new VerificationRunner(worktreePath)
    runners.set(worktreePath, runner)
  }
  return runner
}
```

**Error handling:**
- Graceful handling of missing package.json
- Graceful handling of command execution failures
- Always return structured result, never throw

**Windows compatibility:**
- Use shell: true option for execFile on Windows
- Handle path separators correctly
  </action>
  <verify>npx tsc --noEmit src/main/agents/verification-runner.ts</verify>
  <done>VerificationRunner class with all methods, TypeScript compiles, follows PRService pattern</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes (or `npx tsc --noEmit`)
- [ ] verification-types.ts exports: VerificationCheck, VerificationResult, VerificationCheckId, CommandResult, DEFAULT_VERIFICATION_CHECKS, MAX_OUTPUT_LENGTH, DEFAULT_TIMEOUT
- [ ] verification-runner.ts exports: VerificationRunner, getVerificationRunner
- [ ] No circular imports (verified by typecheck)
- [ ] VerificationRunner follows PRService execFile pattern
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Types align with task-plan-types.ts (uses ChecklistStatus)
- Runner can detect npm scripts from package.json
- Runner can execute commands and capture output
- Output truncation prevents memory issues
- Timeout handling prevents hung processes
</success_criteria>

<output>
After completion, create `.planning/phases/57-verification-runner/57-01-SUMMARY.md`
</output>
