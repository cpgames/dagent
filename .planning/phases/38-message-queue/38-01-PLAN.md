---
phase: 38-message-queue
plan: 01
type: execute
---

<objective>
Create AgentMessage types and MessageBus singleton for inter-agent communication.

Purpose: Establish the messaging infrastructure that replaces direct method calls between agents.
Output: AgentMessage types and MessageBus class with publish/subscribe pattern.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/37-task-agent-sessions/37-01-SUMMARY.md
@.planning/phases/37-task-agent-sessions/37-02-SUMMARY.md
@.planning/phases/37-task-agent-sessions/37-03-SUMMARY.md

**Key files from prior plans:**
@src/shared/types/log.ts
@src/main/agents/task-agent.ts
@src/main/agents/harness-agent.ts

**Tech stack available:** EventEmitter patterns, TaskAgentMessage/TaskAgentSession types
**Established patterns:** Session-based logging, bidirectional message direction tracking
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AgentMessage types</name>
  <files>src/shared/types/message.ts, src/shared/types/index.ts</files>
  <action>
Create new file src/shared/types/message.ts with:

1. AgentMessageType enum or union:
   - 'task_registered' - Task agent registered with harness
   - 'intention_proposed' - Task agent proposes intention
   - 'intention_approved' - Harness approves intention
   - 'intention_rejected' - Harness rejects intention
   - 'task_working' - Task agent started work
   - 'task_completed' - Task agent completed
   - 'task_failed' - Task agent failed

2. AgentMessage interface:
   - id: string (uuid for tracking)
   - type: AgentMessageType
   - from: { type: 'harness' | 'task', id: string }
   - to: { type: 'harness' | 'task', id: string }
   - taskId: string (always present for routing)
   - payload: unknown (type-specific data)
   - timestamp: string (ISO)

3. Type-specific payload interfaces:
   - IntentionProposedPayload: { intention: string, files?: string[] }
   - IntentionApprovedPayload: { type: 'approved' | 'approved_with_notes', notes?: string }
   - IntentionRejectedPayload: { reason: string }
   - TaskCompletedPayload: { summary?: string, commitHash?: string }
   - TaskFailedPayload: { error: string }

Export all types. Add export to src/shared/types/index.ts.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>AgentMessage and payload types defined and exported</done>
</task>

<task type="auto">
  <name>Task 2: Create MessageBus singleton</name>
  <files>src/main/agents/message-bus.ts</files>
  <action>
Create MessageBus class with EventEmitter-based pub/sub:

1. Class structure:
   ```
   class MessageBus extends EventEmitter {
     private static instance: MessageBus | null = null

     static getInstance(): MessageBus
     static resetInstance(): void
   }
   ```

2. Core methods:
   - publish(message: AgentMessage): void
     - Emits 'message' event with full message
     - Emits 'message:{taskId}' for task-specific routing
     - Emits 'message:{type}' for type-based filtering

   - subscribe(handler: (message: AgentMessage) => void): () => void
     - Returns unsubscribe function

   - subscribeToTask(taskId: string, handler: (message: AgentMessage) => void): () => void
     - Task-specific subscription, returns unsubscribe

   - subscribeToType(type: AgentMessageType, handler: (message: AgentMessage) => void): () => void
     - Type-specific subscription, returns unsubscribe

3. Helper to generate message IDs (use crypto.randomUUID())

Export getInstance and resetInstance functions.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>MessageBus singleton with publish/subscribe pattern implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add message creation helpers</name>
  <files>src/main/agents/message-bus.ts</files>
  <action>
Add factory functions for creating typed messages:

1. createMessage(params: Omit<AgentMessage, 'id' | 'timestamp'>): AgentMessage
   - Auto-generates id and timestamp

2. createTaskMessage helper:
   - createTaskToHarnessMessage(taskId: string, agentId: string, type, payload): AgentMessage
   - createHarnessToTaskMessage(taskId: string, agentId: string, type, payload): AgentMessage

These helpers ensure consistent message structure and reduce boilerplate.

Export all factory functions.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Message creation helpers exported from message-bus.ts</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] AgentMessage types in src/shared/types/message.ts
- [ ] MessageBus class in src/main/agents/message-bus.ts
- [ ] getInstance, publish, subscribe methods work
- [ ] Factory functions for message creation
</verification>

<success_criteria>
- All tasks completed
- Message types cover all agent communication scenarios
- MessageBus can publish and subscribe to messages
- No regressions in existing code
</success_criteria>

<output>
After completion, create `.planning/phases/38-message-queue/38-01-SUMMARY.md`
</output>
