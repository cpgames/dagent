---
phase: 60-orchestrator-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/dag-engine/orchestrator.ts
  - src/main/dag-engine/orchestrator-types.ts
  - src/main/ipc/execution-handlers.ts
autonomous: true
must_haves:
  truths:
    - "Orchestrator spawns TaskController instead of direct DevAgent for task execution"
    - "TaskController manages Ralph Loop iterations with automated verification"
    - "Loop status (iteration count, check status) is exposed via IPC"
    - "Tasks complete based on verification results, not just agent claiming done"
  artifacts:
    - path: "src/main/dag-engine/orchestrator.ts"
      provides: "TaskController-based task execution"
      exports: ["ExecutionOrchestrator"]
    - path: "src/main/dag-engine/orchestrator-types.ts"
      provides: "Loop status types for UI"
    - path: "src/main/ipc/execution-handlers.ts"
      provides: "IPC handlers for loop status"
  key_links:
    - from: "orchestrator.ts"
      to: "task-controller.ts"
      via: "createTaskController in assignAgentToTask"
      pattern: "createTaskController"
    - from: "execution-handlers.ts"
      to: "orchestrator.ts"
      via: "IPC handler for loop status"
      pattern: "execution:get-loop-status"
---

<objective>
Wire orchestrator to use TaskController for task execution instead of direct DevAgent spawning.

Purpose: Replace single-shot DevAgent execution with Ralph Loop iteration cycle. Tasks now iterate until automated verification passes, ensuring work is truly complete before marking done.

Output: Updated orchestrator using TaskController, IPC handlers for loop status, iteration tracking exposed to UI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v2.4-ROADMAP.md

Prior phase summaries (used directly by this plan):
@.planning/phases/58-task-controller/58-01-SUMMARY.md
@.planning/phases/59-devagent-integration/59-01-SUMMARY.md

Source files this plan modifies:
@src/main/dag-engine/orchestrator.ts
@src/main/dag-engine/orchestrator-types.ts
@src/main/ipc/execution-handlers.ts
@src/main/dag-engine/task-controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Loop Status Types to Orchestrator Types</name>
  <files>src/main/dag-engine/orchestrator-types.ts</files>
  <action>
Add types for exposing TaskController loop status to the UI:

1. **Add TaskLoopStatus interface:**
   ```typescript
   export interface TaskLoopStatus {
     taskId: string
     status: 'idle' | 'running' | 'paused' | 'completed' | 'failed' | 'aborted'
     currentIteration: number
     maxIterations: number
     worktreePath: string | null
     checklistSnapshot: Record<string, 'pending' | 'pass' | 'fail' | 'skipped'>
     exitReason: 'all_checks_passed' | 'max_iterations_reached' | 'aborted' | 'error' | null
     error: string | null
   }
   ```

2. **Update ExecutionConfig with loop settings:**
   Add to ExecutionConfig interface:
   - maxIterations: number (default 10)
   - runBuild: boolean (default true)
   - runLint: boolean (default true)
   - runTests: boolean (default false)
   - continueOnLintFail: boolean (default true)

3. **Update DEFAULT_EXECUTION_CONFIG:**
   Add the new fields with sensible defaults matching TaskController defaults.

These types enable the UI to display iteration progress and check status.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>TaskLoopStatus interface exported, ExecutionConfig has loop settings</done>
</task>

<task type="auto">
  <name>Task 2: Replace DevAgent with TaskController in Orchestrator</name>
  <files>src/main/dag-engine/orchestrator.ts</files>
  <action>
Update assignAgentToTask() to spawn TaskController instead of direct DevAgent:

1. **Add imports:**
   ```typescript
   import { createTaskController, TaskController } from './task-controller'
   import type { TaskLoopStatus } from './orchestrator-types'
   ```

2. **Add TaskController tracking:**
   Add to class:
   ```typescript
   private taskControllers: Map<string, TaskController> = new Map()
   ```

3. **Update assignAgentToTask() method:**
   Replace DevAgent creation with TaskController:
   ```typescript
   private async assignAgentToTask(task: Task): Promise<void> {
     // ... existing setup code (load feature, claudeMd, etc.) ...

     // Get project root from context service
     const projectRoot = contextService?.getProjectRoot() || process.cwd()

     // Create TaskController with loop config from orchestrator config
     const controller = createTaskController(
       this.state.featureId,
       task.id,
       projectRoot,
       {
         maxIterations: this.config.maxIterations ?? 10,
         runBuild: this.config.runBuild ?? true,
         runLint: this.config.runLint ?? true,
         runTests: this.config.runTests ?? false,
         continueOnLintFail: this.config.continueOnLintFail ?? true
       }
     )

     // Track controller
     this.taskControllers.set(task.id, controller)

     // Subscribe to events
     controller.on('loop:start', () => {
       console.log(`[Orchestrator] Task ${task.id} loop started`)
     })

     controller.on('iteration:complete', (result) => {
       console.log(`[Orchestrator] Task ${task.id} iteration ${result.iteration} complete`)
       this.emit('task_loop_update', this.getLoopStatus(task.id))
     })

     controller.on('loop:complete', async (state) => {
       console.log(`[Orchestrator] Task ${task.id} loop complete: ${state.exitReason}`)
       await this.handleControllerComplete(task.id, state)
     })

     // Update orchestrator state
     const result = this.assignTask(task.id, `controller-${task.id}`)
     if (result.success) {
       console.log('[Orchestrator] Assigned TaskController to task:', task.id)
       this.addEvent('agent_assigned', { taskId: task.id, agentId: `controller-${task.id}` })

       // Start the loop (non-blocking)
       controller.start(task, this.state.graph!, claudeMd, featureGoal)
         .catch(err => console.error(`[Orchestrator] TaskController error for ${task.id}:`, err))
     }
   }
   ```

4. **Add handleControllerComplete() method:**
   ```typescript
   private async handleControllerComplete(
     taskId: string,
     state: TaskControllerState
   ): Promise<void> {
     // Remove from tracking
     this.taskControllers.delete(taskId)

     if (state.exitReason === 'all_checks_passed') {
       // Task successfully completed all verification
       // Now transition to QA (keeping existing QA flow)
       const codeResult = this.completeTaskCode(taskId)
       if (codeResult.success) {
         console.log('[Orchestrator] Task completed verification, moving to QA:', taskId)
         // handleQATasks will spawn QA agent in next tick
       }
     } else {
       // Task failed (max iterations, error, aborted)
       this.failTask(taskId, state.error || `Loop failed: ${state.exitReason}`)
     }

     this.emit('task_loop_update', this.getLoopStatus(taskId))
   }
   ```

5. **Add getLoopStatus() method:**
   ```typescript
   getLoopStatus(taskId: string): TaskLoopStatus | null {
     const controller = this.taskControllers.get(taskId)
     if (!controller) return null

     const state = controller.getState()
     // Get checklist from TaskPlan if available
     // For now, return from controller state
     return {
       taskId,
       status: state.status,
       currentIteration: state.currentIteration,
       maxIterations: state.maxIterations,
       worktreePath: state.worktreePath,
       checklistSnapshot: {}, // Will be populated from TaskPlan
       exitReason: state.exitReason,
       error: state.error
     }
   }
   ```

6. **Add getAllLoopStatuses() method:**
   ```typescript
   getAllLoopStatuses(): TaskLoopStatus[] {
     const statuses: TaskLoopStatus[] = []
     for (const taskId of this.taskControllers.keys()) {
       const status = this.getLoopStatus(taskId)
       if (status) statuses.push(status)
     }
     return statuses
   }
   ```

7. **Update stop() method:**
   Abort all TaskControllers on stop:
   ```typescript
   // In stop() method, add before harness.stop():
   // Abort all running task controllers
   for (const controller of this.taskControllers.values()) {
     controller.abort()
   }
   this.taskControllers.clear()
   ```

8. **Remove or comment out processPendingIntentions():**
   TaskController handles its own iteration without intention-approval, so this method's call in tick() should be removed or made conditional.
   However, keep the intention processing code commented for potential future use if we want to add human approval for iteration prompts.

Key changes:
- DevAgent is now spawned BY TaskController, not directly by orchestrator
- Task completion is based on verification results, not agent claiming done
- Orchestrator tracks TaskController instances for loop status reporting
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Orchestrator uses TaskController for task execution, tracks loop status</done>
</task>

<task type="auto">
  <name>Task 3: Add Loop Status IPC Handlers</name>
  <files>src/main/ipc/execution-handlers.ts</files>
  <action>
Add IPC handlers for exposing loop status to the renderer:

1. **Add import:**
   ```typescript
   import type { TaskLoopStatus } from '../dag-engine/orchestrator-types'
   ```

2. **Subscribe to loop update events:**
   In registerExecutionHandlers(), add event subscription:
   ```typescript
   orchestrator.on('task_loop_update', (status: TaskLoopStatus) => {
     broadcastLoopStatusUpdate(status)
   })
   ```

3. **Add broadcast function:**
   ```typescript
   function broadcastLoopStatusUpdate(status: TaskLoopStatus): void {
     const windows = BrowserWindow.getAllWindows()
     for (const win of windows) {
       if (!win.isDestroyed()) {
         win.webContents.send('task:loop-status-updated', status)
       }
     }
   }
   ```

4. **Add IPC handlers:**
   ```typescript
   ipcMain.handle('execution:get-loop-status', async (_event, taskId: string) => {
     const orchestrator = getOrchestrator()
     return orchestrator.getLoopStatus(taskId)
   })

   ipcMain.handle('execution:get-all-loop-statuses', async () => {
     const orchestrator = getOrchestrator()
     return orchestrator.getAllLoopStatuses()
   })

   ipcMain.handle('execution:abort-loop', async (_event, taskId: string) => {
     const orchestrator = getOrchestrator()
     // Abort specific TaskController if we expose that
     // For now, just return acknowledgment
     return { success: true, taskId }
   })
   ```

These handlers enable the UI (Phase 61) to display iteration progress.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Loop status IPC handlers registered, broadcasts loop updates to renderer</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run typecheck passes
- [ ] TaskLoopStatus interface exists in orchestrator-types.ts
- [ ] ExecutionConfig has loop settings (maxIterations, runBuild, runLint, etc.)
- [ ] Orchestrator imports and uses createTaskController
- [ ] assignAgentToTask creates TaskController instead of DevAgent
- [ ] handleControllerComplete transitions task based on loop result
- [ ] getLoopStatus and getAllLoopStatuses methods exist
- [ ] execution:get-loop-status IPC handler registered
- [ ] task:loop-status-updated event is broadcast
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Orchestrator spawns TaskController for task execution
- Loop status exposed via IPC for UI consumption
- Existing QA/merge flow unchanged (TaskController completes → QA → merge)
</success_criteria>

<output>
After completion, create `.planning/phases/60-orchestrator-integration/60-01-SUMMARY.md`
</output>
