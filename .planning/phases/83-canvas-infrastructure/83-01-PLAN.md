---
phase: 83-canvas-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/src/components/Background/hooks/useAnimationFrame.ts
  - src/renderer/src/components/Background/hooks/useReducedMotion.ts
  - src/renderer/src/components/Background/layers/types.ts
  - src/renderer/src/components/Background/UnifiedCanvas.tsx
  - src/renderer/src/components/Background/UnifiedCanvas.css
autonomous: true

must_haves:
  truths:
    - "useAnimationFrame hook provides delta time in milliseconds"
    - "useAnimationFrame pauses when paused=true"
    - "UnifiedCanvas resizes correctly on window resize"
    - "UnifiedCanvas respects devicePixelRatio for crisp rendering"
    - "Layer interface defines init/update/render methods"
    - "Animation stops when prefers-reduced-motion is enabled"
  artifacts:
    - path: "src/renderer/src/components/Background/hooks/useAnimationFrame.ts"
      provides: "Animation frame hook with delta time and pause"
      exports: ["useAnimationFrame"]
    - path: "src/renderer/src/components/Background/hooks/useReducedMotion.ts"
      provides: "Media query hook for reduced motion preference"
      exports: ["useReducedMotion"]
    - path: "src/renderer/src/components/Background/layers/types.ts"
      provides: "Layer interface for composable effects"
      exports: ["Layer", "LayerContext"]
    - path: "src/renderer/src/components/Background/UnifiedCanvas.tsx"
      provides: "Base canvas component with resize and DPR handling"
      exports: ["UnifiedCanvas"]
  key_links:
    - from: "UnifiedCanvas.tsx"
      to: "useAnimationFrame"
      via: "hook import and usage"
      pattern: "useAnimationFrame"
    - from: "UnifiedCanvas.tsx"
      to: "useReducedMotion"
      via: "hook import for accessibility"
      pattern: "useReducedMotion"
    - from: "UnifiedCanvas.tsx"
      to: "layers/types.ts"
      via: "Layer interface import"
      pattern: "Layer.*from"
---

<objective>
Establish core canvas animation infrastructure for the unified background system.

Purpose: Create reusable hooks, interfaces, and base component that all subsequent canvas layers will build upon. This foundation enables composable layer development with consistent animation timing and accessibility support.

Output: useAnimationFrame hook, useReducedMotion hook, Layer interface, and UnifiedCanvas base component.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md

Relevant source files:
@src/renderer/src/components/Background/SynthwaveGrid.tsx (existing patterns to extract)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAnimationFrame hook</name>
  <files>src/renderer/src/components/Background/hooks/useAnimationFrame.ts</files>
  <action>
Create a custom hook that manages requestAnimationFrame lifecycle with delta time calculation.

Requirements:
- Use `useLayoutEffect` (not useEffect) for RAF cleanup - prevents timing issues
- Accept `callback: (deltaTime: number) => void` and `paused?: boolean` parameters
- Calculate delta time in milliseconds between frames
- Store animation state in refs (frameId, lastTime, isRunning) to avoid re-renders
- Handle first-frame delta gracefully (cap at 100ms to prevent huge jumps)
- Cancel RAF on unmount or when paused

Pattern from research ARCHITECTURE.md:
```typescript
const animationRef = useRef({
  frameId: 0,
  lastTime: 0,
  isRunning: false
});
```

Export: `useAnimationFrame(callback, paused)`
  </action>
  <verify>tsc --noEmit src/renderer/src/components/Background/hooks/useAnimationFrame.ts</verify>
  <done>Hook exports and TypeScript compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create useReducedMotion hook</name>
  <files>src/renderer/src/components/Background/hooks/useReducedMotion.ts</files>
  <action>
Create a hook that detects prefers-reduced-motion media query preference.

Requirements:
- Query `(prefers-reduced-motion: reduce)` on mount
- Subscribe to changes via `addEventListener('change', handler)`
- Return boolean `reducedMotion` state
- Clean up listener on unmount

Pattern from existing SynthwaveGrid.tsx lines 31-38 can be extracted into this reusable hook.

Export: `useReducedMotion(): boolean`
  </action>
  <verify>tsc --noEmit src/renderer/src/components/Background/hooks/useReducedMotion.ts</verify>
  <done>Hook exports and TypeScript compiles without errors</done>
</task>

<task type="auto">
  <name>Task 3: Create Layer interface</name>
  <files>src/renderer/src/components/Background/layers/types.ts</files>
  <action>
Define the Layer interface that all canvas layers must implement.

Requirements based on research ARCHITECTURE.md:
```typescript
export interface LayerContext {
  width: number;
  height: number;
  dpr: number;
}

export interface Layer {
  /** Initialize layer state, called once on mount and on resize */
  init(ctx: CanvasRenderingContext2D, context: LayerContext): void;

  /** Update layer state based on elapsed time */
  update(deltaTime: number): void;

  /** Render layer to canvas context */
  render(ctx: CanvasRenderingContext2D, context: LayerContext): void;

  /** Optional: Reset layer state */
  reset?(): void;
}
```

Keep interface minimal - only what's needed for the render loop. Layers maintain their own internal state.

Export: `Layer`, `LayerContext`
  </action>
  <verify>tsc --noEmit src/renderer/src/components/Background/layers/types.ts</verify>
  <done>Interface exports and TypeScript compiles without errors</done>
</task>

<task type="auto">
  <name>Task 4: Create UnifiedCanvas component</name>
  <files>src/renderer/src/components/Background/UnifiedCanvas.tsx, src/renderer/src/components/Background/UnifiedCanvas.css</files>
  <action>
Create the base canvas component that renders layers with proper resize and DPR handling.

Requirements:
- Accept `layers: Layer[]` and `className?: string` props
- Use `useAnimationFrame` for animation loop
- Use `useReducedMotion` for accessibility
- Handle canvas resize with ResizeObserver (100ms debounce per PERF-03)
- Scale canvas for devicePixelRatio for crisp rendering on HiDPI displays
- When reducedMotion is true: call init() and render() once, skip update() and animation

Canvas setup pattern:
```typescript
const dpr = window.devicePixelRatio || 1;
canvas.width = rect.width * dpr;
canvas.height = rect.height * dpr;
ctx.scale(dpr, dpr);
```

Render loop:
1. Skip if reducedMotion
2. For each layer: layer.update(deltaTime)
3. ctx.clearRect(0, 0, width, height)
4. For each layer: layer.render(ctx, context)

CSS: Full viewport coverage, fixed positioning, pointer-events: none, z-index: 0 (behind all content).

Export: `UnifiedCanvas`
  </action>
  <verify>npm run build</verify>
  <done>Component renders without errors, handles resize, respects DPR</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] useAnimationFrame hook exists with proper exports
- [ ] useReducedMotion hook exists with proper exports
- [ ] Layer interface defines init/update/render methods
- [ ] UnifiedCanvas component handles resize and DPR
- [ ] No TypeScript errors introduced
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Infrastructure ready for Phase 84 layer implementation
</success_criteria>

<output>
After completion, create `.planning/phases/83-canvas-infrastructure/83-01-SUMMARY.md`
</output>
