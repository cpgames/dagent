---
phase: 01-foundation
plan: 03
type: execute
---

<objective>
Implement basic window management and establish IPC communication patterns.

Purpose: Create the foundational IPC infrastructure that all future main-renderer communication will use.
Output: Working IPC ping/pong, window state management, and established patterns for Phase 2+.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@DAGENT_SPEC.md

**From spec section 2.2:**
IPC connects main and renderer processes. Main hosts managers (Auth, Git, Agent), renderer hosts views.

**Depends on:** 01-02 (preload script with contextBridge established)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement IPC handlers in main process</name>
  <files>src/main/ipc/handlers.ts, src/main/index.ts</files>
  <action>
    Create IPC handler infrastructure:

    src/main/ipc/handlers.ts:
    ```typescript
    import { ipcMain, BrowserWindow } from 'electron'

    export function registerIpcHandlers() {
      // Health check - proves IPC works
      ipcMain.handle('ping', async () => {
        return 'pong'
      })

      // App info - useful for debugging
      ipcMain.handle('app:getInfo', async () => {
        return {
          version: process.env.npm_package_version || '0.0.0',
          platform: process.platform,
          arch: process.arch,
        }
      })

      // Window controls (minimize, maximize, close)
      ipcMain.handle('window:minimize', async (event) => {
        const win = BrowserWindow.fromWebContents(event.sender)
        win?.minimize()
      })

      ipcMain.handle('window:maximize', async (event) => {
        const win = BrowserWindow.fromWebContents(event.sender)
        if (win?.isMaximized()) {
          win.unmaximize()
        } else {
          win?.maximize()
        }
      })

      ipcMain.handle('window:close', async (event) => {
        const win = BrowserWindow.fromWebContents(event.sender)
        win?.close()
      })
    }
    ```

    Update src/main/index.ts to call registerIpcHandlers() after app.whenReady().

    Use ipcMain.handle (not ipcMain.on) for request-response pattern.
  </action>
  <verify>No errors on startup, handlers registered (check with console.log if needed)</verify>
  <done>IPC handlers registered for ping, app:getInfo, and window controls</done>
</task>

<task type="auto">
  <name>Task 2: Expose IPC methods in preload</name>
  <files>src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
    Update preload script to expose all IPC methods:

    src/preload/index.ts:
    ```typescript
    import { contextBridge, ipcRenderer } from 'electron'

    const electronAPI = {
      // Health check
      ping: () => ipcRenderer.invoke('ping'),

      // App info
      getAppInfo: () => ipcRenderer.invoke('app:getInfo'),

      // Window controls
      minimizeWindow: () => ipcRenderer.invoke('window:minimize'),
      maximizeWindow: () => ipcRenderer.invoke('window:maximize'),
      closeWindow: () => ipcRenderer.invoke('window:close'),
    }

    contextBridge.exposeInMainWorld('electronAPI', electronAPI)
    ```

    Update src/preload/index.d.ts with full types:
    ```typescript
    export interface AppInfo {
      version: string
      platform: NodeJS.Platform
      arch: string
    }

    export interface ElectronAPI {
      ping: () => Promise<string>
      getAppInfo: () => Promise<AppInfo>
      minimizeWindow: () => Promise<void>
      maximizeWindow: () => Promise<void>
      closeWindow: () => Promise<void>
    }

    declare global {
      interface Window {
        electronAPI: ElectronAPI
      }
    }
    ```
  </action>
  <verify>TypeScript compiles, window.electronAPI shows all methods in DevTools</verify>
  <done>All IPC methods typed and exposed via contextBridge</done>
</task>

<task type="auto">
  <name>Task 3: Test IPC from renderer</name>
  <files>src/renderer/src/App.tsx</files>
  <action>
    Add simple UI to verify IPC works:

    Update App.tsx to test IPC on mount:
    ```tsx
    import { useEffect, useState } from 'react'

    function App() {
      const [appInfo, setAppInfo] = useState<{ version: string; platform: string } | null>(null)
      const [pingResult, setPingResult] = useState<string>('')

      useEffect(() => {
        // Test IPC on mount
        window.electronAPI.ping().then(setPingResult)
        window.electronAPI.getAppInfo().then(setAppInfo)
      }, [])

      return (
        <div className="min-h-screen bg-gray-900 text-white">
          <header className="flex items-center justify-between p-4 border-b border-gray-700">
            <h1 className="text-xl font-bold text-blue-400">DAGent</h1>
            <div className="flex gap-2">
              <button
                onClick={() => window.electronAPI.minimizeWindow()}
                className="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600"
              >
                −
              </button>
              <button
                onClick={() => window.electronAPI.maximizeWindow()}
                className="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600"
              >
                □
              </button>
              <button
                onClick={() => window.electronAPI.closeWindow()}
                className="px-3 py-1 rounded bg-red-700 hover:bg-red-600"
              >
                ×
              </button>
            </div>
          </header>
          <main className="p-4">
            <p className="text-gray-400 mb-4">Dependency-aware AI agent orchestration</p>
            <div className="text-sm text-gray-500">
              <p>IPC ping: {pingResult}</p>
              {appInfo && (
                <p>App: v{appInfo.version} on {appInfo.platform}</p>
              )}
            </div>
          </main>
        </div>
      )
    }

    export default App
    ```

    This tests:
    1. ping/pong IPC
    2. app:getInfo retrieval
    3. Window control buttons (minimize, maximize, close)
  </action>
  <verify>App shows "pong" and app info, window buttons work (minimize/maximize/close)</verify>
  <done>IPC fully functional, window controls work, ready for Phase 2</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ping returns "pong" (visible in UI)
- [ ] App info displays version and platform
- [ ] Minimize button minimizes window
- [ ] Maximize button toggles maximize/restore
- [ ] Close button closes window
- [ ] No TypeScript errors
- [ ] No console errors
</verification>

<success_criteria>
- All tasks completed
- IPC infrastructure established
- Window controls functional
- TypeScript types complete
- Phase 1: Foundation complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`

**Phase 1 complete** - ready for Phase 2: Data Model & Storage
</output>
