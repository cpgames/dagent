---
phase: 33-execution-orchestration
plan: 01
type: execute
---

<objective>
Implement the execution loop that runs when Start is clicked, continuously processing ready tasks until all complete or stopped.

Purpose: The orchestrator currently just changes status but has no actual loop - this plan adds the core execution loop that drives the entire v1.8 milestone.
Output: Working execution loop that identifies ready tasks and drives the execution lifecycle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v1.8-ROADMAP.md

# Prior phase context:
@.planning/phases/03-dag-engine/03-03-SUMMARY.md
@.planning/phases/07-polish-integration/07-02-SUMMARY.md

# Key source files:
@src/main/dag-engine/orchestrator.ts
@src/main/dag-engine/analyzer.ts
@src/renderer/src/stores/execution-store.ts
@src/renderer/src/components/DAG/ExecutionControls.tsx

**Tech stack available:** Electron, TypeScript, Zustand, simple-git
**Established patterns:** Singleton orchestrator, IPC handlers, event emitters

**Constraining decisions:**
- Phase 03-03: ExecutionOrchestrator uses singleton pattern with getOrchestrator()
- Phase 07-02: ExecutionControls calls execution.initialize() then execution.start()
- DAGENT_SPEC 6.3: Execution loop must run "while tasks remain"

**Key insight from existing code:**
- `start()` only sets status to 'running', no loop
- `getNextTasks()` returns ready tasks but nothing calls it continuously
- Need interval-based tick to drive execution forward
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add execution loop with tick-based processing</name>
  <files>src/main/dag-engine/orchestrator.ts</files>
  <action>
Add execution loop infrastructure to ExecutionOrchestrator:

1. Add private field `private loopInterval: NodeJS.Timeout | null = null`

2. Add `private readonly TICK_INTERVAL_MS = 1000` constant (1 second tick)

3. Modify `start()` method to call `this.startLoop()` after setting status

4. Add `private startLoop(): void` method:
   - Clear any existing interval
   - Set new interval calling `this.tick()` every TICK_INTERVAL_MS
   - Log loop start

5. Add `private stopLoop(): void` method:
   - Clear interval if exists
   - Set loopInterval to null
   - Log loop stop

6. Add `private tick(): void` method - the core execution step:
   ```typescript
   private tick(): void {
     // Skip if not running
     if (this.state.status !== 'running') {
       this.stopLoop()
       return
     }

     // Check for completion
     if (this.checkAllTasksComplete()) {
       this.state.status = 'completed'
       this.state.stoppedAt = new Date().toISOString()
       this.addEvent('completed')
       this.stopLoop()
       return
     }

     // Get ready tasks that can be assigned
     const { available, canAssign } = this.getNextTasks()

     // Log tick for debugging
     console.log(`[Orchestrator] tick: ${available.length} available, can assign ${canAssign}`)

     // Emit tick event for UI updates (will be used in 33-02)
     this.addEvent('tick', {
       availableCount: available.length,
       canAssign
     })
   }
   ```

7. Add `private checkAllTasksComplete(): boolean` helper:
   - Return true if all nodes have status 'completed'
   - Handles empty graph edge case

8. Modify `pause()` to call `this.stopLoop()`

9. Modify `resume()` to call `this.startLoop()`

10. Modify `stop()` to call `this.stopLoop()`

IMPORTANT: Do NOT start assigning agents yet - that's Phase 34. This plan just establishes the loop.
  </action>
  <verify>
npm run typecheck passes. Add console.log in tick() and verify it logs every second when Start is clicked (via npm run dev).
  </verify>
  <done>
- ExecutionOrchestrator has tick-based loop that runs while status is 'running'
- Loop automatically stops on pause/stop/completion
- Tick identifies available tasks and logs count
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add execution state polling for UI updates</name>
  <files>src/renderer/src/stores/execution-store.ts</files>
  <action>
Add polling mechanism to execution-store so UI updates during execution:

1. Add `private pollInterval: number | null = null` tracking variable (store it in state or closure)

2. Add `pollIntervalMs` constant (2000ms - poll every 2 seconds)

3. Modify `start()` to start polling after successful start:
   ```typescript
   // After toast.success('Execution started')
   // Start polling for state updates
   const pollId = window.setInterval(async () => {
     try {
       const state = await window.electronAPI.execution.getState()
       set({
         execution: {
           status: state.status,
           featureId: state.featureId,
           error: state.error,
           startedAt: state.startedAt
         }
       })
       // Stop polling if execution ended
       if (state.status === 'idle' || state.status === 'completed' || state.status === 'failed') {
         window.clearInterval(pollId)
       }
     } catch {
       // Ignore polling errors
     }
   }, 2000)
   ```

4. Modify `stop()` to clear any existing polling interval

5. Add `activePollId` to store state to track and cleanup polling:
   ```typescript
   interface ExecutionStoreState {
     // ... existing
     activePollId: number | null
   }
   ```

6. Update initial state to include `activePollId: null`

7. On stop/pause, clear the activePollId interval

This ensures the UI reflects execution status changes even when orchestrator transitions (running â†’ completed).
  </action>
  <verify>
npm run typecheck passes. Start execution, observe UI updates status indicator when execution completes (all tasks already completed = immediate completion).
  </verify>
  <done>
- execution-store polls for state updates during execution
- Polling stops automatically when execution ends
- UI status indicator updates in real-time
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add execution snapshot IPC for richer state</name>
  <files>src/main/ipc/execution-handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Expose execution snapshot via IPC for debugging and future phases:

1. In execution-handlers.ts, add handler for `execution:get-snapshot`:
   ```typescript
   ipcMain.handle('execution:get-snapshot', async () => {
     const orchestrator = getOrchestrator()
     return orchestrator.getSnapshot()
   })
   ```

2. In preload index.ts, add to execution object:
   ```typescript
   getSnapshot: () => ipcRenderer.invoke('execution:get-snapshot')
   ```

3. In preload index.d.ts, add to ExecutionAPI interface:
   ```typescript
   getSnapshot: () => Promise<ExecutionSnapshot>
   ```

4. Import ExecutionSnapshot type in preload files from orchestrator-types

This provides full execution visibility (assignments, history, events) for debugging and Phase 36 logging.
  </action>
  <verify>
npm run typecheck passes. Call window.electronAPI.execution.getSnapshot() in devtools during execution.
  </verify>
  <done>
- getSnapshot IPC handler registered
- Preload exposes getSnapshot method
- TypeScript types correct
- Can retrieve full execution state from renderer
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] `npm run dev` runs without errors
- [ ] Click Start on a feature with tasks - see tick logs in main process console
- [ ] Execution status changes from 'running' to 'completed' when all tasks done
- [ ] Stop button stops the tick loop
- [ ] Pause button pauses the tick loop
- [ ] Resume button resumes the tick loop
</verification>

<success_criteria>
- Execution loop runs every 1 second when status is 'running'
- Loop stops on pause/stop/completion
- UI polls and updates status during execution
- getSnapshot available for debugging
- No TypeScript errors or runtime errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-execution-orchestration/33-01-SUMMARY.md`
</output>
