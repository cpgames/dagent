---
phase: 51-qa-commits
plan: 02
subsystem: agents
tags: [qa-agent, git, commit, workflow]

# Dependency graph
requires:
  - phase: 51-qa-commits/51-01
    provides: TaskAgent no longer commits code
provides:
  - QA agent commits code on successful review
  - Clean commit workflow (only good code committed)
  - Full build passes
affects: [orchestrator.ts]

# Tech tracking
tech-stack:
  added: []
  patterns: [qa-commits-only]

key-files:
  created: []
  modified:
    - src/main/agents/qa-agent.ts
    - src/main/agents/qa-types.ts

key-decisions:
  - "QA agent commits after successful review using same pattern as TaskAgent"
  - "QAReviewResult includes commitHash on pass"
  - "Commit message includes task context for traceability"
---

# Phase 51-02: Add Git Commit to QA Agent

**Objective:** QA agent commits code after successful review - no bad commits from failed reviews.

## Context

After 51-01, TaskAgent no longer commits. QA reviews uncommitted changes via `git diff`. Now we need QA to commit the changes when review passes.

**New flow:**
1. Dev codes (no commit)
2. QA reviews uncommitted changes
3. If QA passes → QA commits changes → proceed to merge
4. If QA fails → dev gets feedback (no commit created)

## Tasks

### Task 1: Add commit method to QAAgent

**File:** `src/main/agents/qa-agent.ts`

Add a commit method similar to TaskAgent's commitChanges():

```typescript
/**
 * Commit changes after successful QA review.
 * Uses the task worktree for committing.
 */
private async commitChanges(): Promise<{ commitHash?: string; filesChanged?: number; error?: string }> {
  if (!this.state.worktreePath) {
    return { error: 'No worktree path' }
  }

  try {
    const { simpleGit } = await import('simple-git')
    const git = simpleGit({ baseDir: this.state.worktreePath })

    // Verify git repository
    const isRepo = await git.checkIsRepo()
    if (!isRepo) {
      return { error: 'Not a git repository' }
    }

    // Stage all changes
    await git.add('.')
    const status = await git.status()

    const stagedCount = status.staged.length + status.created.length
    const hasChanges = stagedCount > 0 || status.modified.length > 0 || status.not_added.length > 0

    if (!hasChanges) {
      console.log(`[QAAgent ${this.state.taskId}] No changes to commit`)
      return { filesChanged: 0 }
    }

    const filesChanged = stagedCount || status.modified.length + status.not_added.length

    // Commit with task info (QA-approved)
    const commitMessage = `feat(${this.state.taskId}): ${this.taskTitle}\n\nQA-approved`
    console.log(`[QAAgent ${this.state.taskId}] Committing ${filesChanged} files: ${commitMessage}`)

    const commitResult = await git.commit(commitMessage)
    console.log(`[QAAgent ${this.state.taskId}] Committed: ${commitResult.commit}`)

    return { commitHash: commitResult.commit, filesChanged }
  } catch (error) {
    const errorMsg = (error as Error).message
    console.error('[QAAgent] Failed to commit:', errorMsg)
    return { error: errorMsg }
  }
}
```

### Task 2: Update execute() to commit on pass

**File:** `src/main/agents/qa-agent.ts`

Modify execute() to commit changes after successful review:

**In execute() after parsing review response:**

```typescript
// Parse the review response
const result = this.parseReviewResponse(responseText)

// If review passed, commit the changes
if (result.passed) {
  console.log(`[QAAgent ${this.state.taskId}] Review passed, committing changes...`)
  const commitResult = await this.commitChanges()

  if (commitResult.error) {
    // Commit failed - mark review as failed
    console.error(`[QAAgent ${this.state.taskId}] Commit failed: ${commitResult.error}`)
    result.passed = false
    result.feedback = `QA passed but commit failed: ${commitResult.error}`
  } else {
    result.commitHash = commitResult.commitHash
    result.filesChanged = commitResult.filesChanged
    console.log(`[QAAgent ${this.state.taskId}] Commit successful: ${commitResult.commitHash}`)
  }
}

this.state.reviewResult = result
```

### Task 3: Update QAReviewResult type

**File:** `src/main/agents/qa-types.ts`

Add optional commit fields to the result type:

```typescript
export interface QAReviewResult {
  passed: boolean
  feedback?: string
  filesReviewed: string[]
  commitHash?: string    // Added: commit hash if QA passed and committed
  filesChanged?: number  // Added: number of files in commit
}
```

### Task 4: Update orchestrator to use QA commit hash

**File:** `src/main/dag-engine/orchestrator.ts`

The handleQAResult method should log the commit hash for debugging:

```typescript
if (result.passed) {
  console.log(`[Orchestrator] QA passed for ${taskId}, commit: ${result.commitHash}`)
  // ... rest of transition logic
}
```

No structural changes needed - the merge agent already works with the branch's HEAD commit.

## Verification

After implementation:
1. `npm run build` passes with no errors
2. QA agent calls commitChanges() only on successful review
3. QAReviewResult includes commitHash field
4. Commit message includes "QA-approved" marker

## Testing Scenarios

1. **QA passes:**
   - Dev makes changes (no commit)
   - QA reviews and passes
   - QA commits with message "feat(taskId): title\n\nQA-approved"
   - Merge proceeds normally

2. **QA fails:**
   - Dev makes changes (no commit)
   - QA reviews and fails
   - No commit created
   - Dev gets feedback
   - Dev fixes issues
   - QA reviews again

3. **QA passes but commit fails:**
   - Rare edge case (disk full, permissions, etc.)
   - QA marks result as failed with commit error
   - Dev can retry

## Expected Impact

- Only QA-approved code gets committed
- Failed QA reviews leave no bad commits
- Commit messages clearly indicate QA approval
- Merge agent works unchanged (merges branch HEAD)
