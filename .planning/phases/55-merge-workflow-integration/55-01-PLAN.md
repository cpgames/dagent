---
phase: 55-merge-workflow-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/ipc/feature-merge-agent-handlers.ts
  - src/main/ipc/handlers.ts
  - src/preload/index.ts
  - src/preload/index.d.ts
  - src/renderer/src/components/Feature/FeatureMergeDialog.tsx
  - src/renderer/src/components/Feature/index.ts
  - src/renderer/src/views/KanbanView.tsx
autonomous: true

must_haves:
  truths:
    - "User can click Merge button on completed feature card"
    - "AI Merge option opens dialog with merge workflow UI"
    - "Create PR option opens dialog with PR creation form"
    - "Dialog shows merge progress and status updates"
    - "Merge completion/failure provides clear feedback"
  artifacts:
    - path: "src/main/ipc/feature-merge-agent-handlers.ts"
      provides: "IPC handlers for feature merge agent operations"
      exports: ["registerFeatureMergeAgentHandlers"]
    - path: "src/renderer/src/components/Feature/FeatureMergeDialog.tsx"
      provides: "Dialog component for merge workflow UI"
      exports: ["FeatureMergeDialog"]
  key_links:
    - from: "src/renderer/src/views/KanbanView.tsx"
      to: "FeatureMergeDialog"
      via: "handleMergeFeature opens dialog"
      pattern: "setMergeDialogOpen\\(true\\)"
    - from: "src/renderer/src/components/Feature/FeatureMergeDialog.tsx"
      to: "window.electronAPI.featureMerge"
      via: "IPC calls for merge operations"
      pattern: "electronAPI\\.featureMerge"
---

<objective>
Wire up full merge workflow: button → dialog → agent → completion feedback.

Purpose: Enable users to merge completed features into main branch via AI-assisted merge or create GitHub PRs
Output: FeatureMergeDialog component, IPC handlers, and KanbanView integration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-merge-button-ui/52-01-SUMMARY.md
@.planning/phases/53-feature-merge-agent/53-01-SUMMARY.md
@.planning/phases/54-github-pr-integration/54-01-SUMMARY.md

Relevant source files:
@src/main/agents/feature-merge-agent.ts
@src/main/agents/feature-merge-types.ts
@src/main/github/pr-service.ts
@src/main/github/pr-types.ts
@src/renderer/src/views/KanbanView.tsx
@src/renderer/src/components/Feature/DeleteFeatureDialog.tsx
@src/preload/index.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IPC handlers for FeatureMergeAgent</name>
  <files>src/main/ipc/feature-merge-agent-handlers.ts, src/main/ipc/handlers.ts</files>
  <action>
Create `src/main/ipc/feature-merge-agent-handlers.ts` with IPC handlers for the FeatureMergeAgent:

```typescript
import { ipcMain } from 'electron'
import {
  createFeatureMergeAgent,
  registerFeatureMergeAgent,
  getFeatureMergeAgent,
  removeFeatureMergeAgent
} from '../agents/feature-merge-agent'
import type { FeatureMergeAgentState, FeatureMergeResult } from '../agents/feature-merge-types'

export function registerFeatureMergeAgentHandlers(): void {
  // Create and initialize merge agent
  ipcMain.handle('feature-merge:create', async (_event, featureId: string, targetBranch: string = 'main') => {
    const agent = createFeatureMergeAgent(featureId, targetBranch)
    const initialized = await agent.initialize()
    if (initialized) {
      registerFeatureMergeAgent(agent)
    }
    return { success: initialized, state: agent.getState() }
  })

  // Get current agent state
  ipcMain.handle('feature-merge:get-state', async (_event, featureId: string) => {
    const agent = getFeatureMergeAgent(featureId)
    return agent?.getState() ?? null
  })

  // Check branches exist
  ipcMain.handle('feature-merge:check-branches', async (_event, featureId: string) => {
    const agent = getFeatureMergeAgent(featureId)
    if (!agent) return { success: false, error: 'Agent not found' }
    const result = await agent.checkBranches()
    return { success: result, state: agent.getState() }
  })

  // Auto-approve and execute merge (for AI Merge flow)
  ipcMain.handle('feature-merge:execute', async (_event, featureId: string, deleteBranchOnSuccess: boolean = false) => {
    const agent = getFeatureMergeAgent(featureId)
    if (!agent) return { success: false, error: 'Agent not found' }

    // Auto-approve for AI merge
    agent.receiveApproval({ approved: true })

    // Execute the merge
    const result = await agent.executeMerge(deleteBranchOnSuccess)
    return result
  })

  // Cleanup agent
  ipcMain.handle('feature-merge:cleanup', async (_event, featureId: string) => {
    const agent = getFeatureMergeAgent(featureId)
    if (agent) {
      await agent.cleanup()
      removeFeatureMergeAgent(featureId)
    }
    return { success: true }
  })
}
```

Update `src/main/ipc/handlers.ts`:
- Import: `import { registerFeatureMergeAgentHandlers } from './feature-merge-agent-handlers'`
- Add call: `registerFeatureMergeAgentHandlers()` in `registerIpcHandlers()`
  </action>
  <verify>npm run typecheck passes with new handlers</verify>
  <done>IPC handlers registered for feature-merge:create, get-state, check-branches, execute, cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Update preload to expose feature merge API</name>
  <files>src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Update `src/preload/index.d.ts` to add FeatureMergeAPI interface:

```typescript
import type {
  FeatureMergeAgentState,
  FeatureMergeResult
} from '../main/agents/feature-merge-types'

export interface FeatureMergeCreateResult {
  success: boolean
  state: FeatureMergeAgentState
}

export interface FeatureMergeBranchCheckResult {
  success: boolean
  state?: FeatureMergeAgentState
  error?: string
}

export interface FeatureMergeAPI {
  create: (featureId: string, targetBranch?: string) => Promise<FeatureMergeCreateResult>
  getState: (featureId: string) => Promise<FeatureMergeAgentState | null>
  checkBranches: (featureId: string) => Promise<FeatureMergeBranchCheckResult>
  execute: (featureId: string, deleteBranchOnSuccess?: boolean) => Promise<FeatureMergeResult>
  cleanup: (featureId: string) => Promise<{ success: boolean }>
}
```

Add to ElectronAPI interface:
```typescript
featureMerge: FeatureMergeAPI
```

Update `src/preload/index.ts`:
- Add import for FeatureMergeAgentState and FeatureMergeResult types
- Add featureMerge API object with all 5 methods using ipcRenderer.invoke
  </action>
  <verify>npm run typecheck passes</verify>
  <done>featureMerge API exposed via preload with create, getState, checkBranches, execute, cleanup methods</done>
</task>

<task type="auto">
  <name>Task 3: Create FeatureMergeDialog component and wire to KanbanView</name>
  <files>src/renderer/src/components/Feature/FeatureMergeDialog.tsx, src/renderer/src/components/Feature/index.ts, src/renderer/src/views/KanbanView.tsx</files>
  <action>
Create `src/renderer/src/components/Feature/FeatureMergeDialog.tsx`:

```tsx
import type { JSX } from 'react'
import { useState, useEffect, useCallback } from 'react'
import type { Feature } from '@shared/types'
import type { MergeType } from '../Kanban'

interface FeatureMergeDialogProps {
  isOpen: boolean
  onClose: () => void
  feature: Feature | null
  mergeType: MergeType | null
}

type MergeStatus = 'idle' | 'initializing' | 'checking' | 'merging' | 'creating-pr' | 'completed' | 'failed'

export function FeatureMergeDialog({
  isOpen,
  onClose,
  feature,
  mergeType
}: FeatureMergeDialogProps): JSX.Element | null {
  const [status, setStatus] = useState<MergeStatus>('idle')
  const [error, setError] = useState<string | null>(null)
  const [deleteBranch, setDeleteBranch] = useState(false)
  const [prUrl, setPrUrl] = useState<string | null>(null)

  // PR form state
  const [prTitle, setPrTitle] = useState('')
  const [prBody, setPrBody] = useState('')

  // Reset state when dialog opens
  useEffect(() => {
    if (isOpen && feature) {
      setStatus('idle')
      setError(null)
      setPrUrl(null)
      setPrTitle(`Merge feature: ${feature.name}`)
      setPrBody(`## Summary\nMerge completed feature "${feature.name}" into main branch.\n\n## Changes\n- ${feature.goal || 'Feature implementation'}`)
    }
  }, [isOpen, feature])

  // Cleanup on close
  const handleClose = useCallback(async () => {
    if (feature && status !== 'merging' && status !== 'creating-pr') {
      await window.electronAPI.featureMerge.cleanup(feature.id)
    }
    onClose()
  }, [feature, status, onClose])

  // AI Merge flow
  const handleAIMerge = async () => {
    if (!feature) return

    try {
      setStatus('initializing')
      setError(null)

      // Create and initialize agent
      const createResult = await window.electronAPI.featureMerge.create(feature.id, 'main')
      if (!createResult.success) {
        throw new Error(createResult.state?.error || 'Failed to initialize merge agent')
      }

      // Check branches
      setStatus('checking')
      const checkResult = await window.electronAPI.featureMerge.checkBranches(feature.id)
      if (!checkResult.success) {
        throw new Error(checkResult.error || 'Branch check failed')
      }

      // Execute merge
      setStatus('merging')
      const mergeResult = await window.electronAPI.featureMerge.execute(feature.id, deleteBranch)

      if (mergeResult.success && mergeResult.merged) {
        setStatus('completed')
      } else if (mergeResult.conflicts && mergeResult.conflicts.length > 0) {
        throw new Error(`Merge conflicts in ${mergeResult.conflicts.length} files. Please resolve manually.`)
      } else {
        throw new Error(mergeResult.error || 'Merge failed')
      }
    } catch (err) {
      setStatus('failed')
      setError((err as Error).message)
    }
  }

  // Create PR flow
  const handleCreatePR = async () => {
    if (!feature) return

    try {
      setStatus('creating-pr')
      setError(null)

      // Check gh CLI first
      const ghStatus = await window.electronAPI.pr.checkGhCli()
      if (!ghStatus.installed) {
        throw new Error('GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/')
      }
      if (!ghStatus.authenticated) {
        throw new Error('GitHub CLI is not authenticated. Run `gh auth login` to authenticate.')
      }

      // Get feature branch name
      const featureBranch = `feature/${feature.id}/main`

      // Create PR
      const result = await window.electronAPI.pr.create({
        title: prTitle,
        body: prBody,
        head: featureBranch,
        base: 'main'
      })

      if (result.success && result.prUrl) {
        setStatus('completed')
        setPrUrl(result.htmlUrl || result.prUrl)
      } else {
        throw new Error(result.error || 'Failed to create PR')
      }
    } catch (err) {
      setStatus('failed')
      setError((err as Error).message)
    }
  }

  if (!isOpen || !feature) return null

  const isProcessing = status === 'initializing' || status === 'checking' || status === 'merging' || status === 'creating-pr'
  const showPRForm = mergeType === 'pr' && status === 'idle'
  const showMergeOptions = mergeType === 'ai' && status === 'idle'

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div className="absolute inset-0 bg-black/50" onClick={isProcessing ? undefined : handleClose} />

      {/* Dialog */}
      <div
        className="relative bg-gray-800 rounded-lg shadow-xl w-full max-w-lg mx-4 p-6"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-lg font-semibold text-white">
            {mergeType === 'ai' ? 'AI Merge' : 'Create Pull Request'}
          </h2>
          <button
            type="button"
            onClick={handleClose}
            disabled={isProcessing}
            className="text-gray-400 hover:text-white focus:outline-none disabled:opacity-50"
            aria-label="Close"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Feature info */}
        <div className="mb-4 p-3 bg-gray-700/50 rounded-md">
          <p className="text-sm text-gray-300">
            Feature: <span className="font-medium text-white">{feature.name}</span>
          </p>
          <p className="text-xs text-gray-400 mt-1">
            Branch: feature/{feature.id}/main → main
          </p>
        </div>

        {/* AI Merge Options */}
        {showMergeOptions && (
          <div className="mb-4">
            <label className="flex items-center gap-3 cursor-pointer">
              <input
                type="checkbox"
                checked={deleteBranch}
                onChange={(e) => setDeleteBranch(e.target.checked)}
                className="w-4 h-4 rounded border-gray-600 bg-gray-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-gray-800"
              />
              <span className="text-sm text-gray-300">Delete feature branch after merge</span>
            </label>
          </div>
        )}

        {/* PR Form */}
        {showPRForm && (
          <div className="space-y-4 mb-4">
            <div>
              <label className="block text-sm font-medium text-gray-300 mb-1">PR Title</label>
              <input
                type="text"
                value={prTitle}
                onChange={(e) => setPrTitle(e.target.value)}
                className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-300 mb-1">Description</label>
              <textarea
                value={prBody}
                onChange={(e) => setPrBody(e.target.value)}
                rows={4}
                className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
              />
            </div>
          </div>
        )}

        {/* Status/Progress */}
        {isProcessing && (
          <div className="mb-4 p-3 bg-blue-900/30 border border-blue-700 rounded-md">
            <div className="flex items-center gap-2">
              <svg className="animate-spin h-4 w-4 text-blue-400" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
              </svg>
              <span className="text-sm text-blue-300">
                {status === 'initializing' && 'Initializing merge agent...'}
                {status === 'checking' && 'Checking branches...'}
                {status === 'merging' && 'Merging branches...'}
                {status === 'creating-pr' && 'Creating pull request...'}
              </span>
            </div>
          </div>
        )}

        {/* Success */}
        {status === 'completed' && (
          <div className="mb-4 p-3 bg-green-900/30 border border-green-700 rounded-md">
            <p className="text-sm text-green-300 font-medium">
              {mergeType === 'ai' ? 'Merge completed successfully!' : 'Pull request created!'}
            </p>
            {prUrl && (
              <a
                href={prUrl}
                target="_blank"
                rel="noopener noreferrer"
                className="text-sm text-blue-400 hover:text-blue-300 mt-1 block"
              >
                View PR: {prUrl}
              </a>
            )}
          </div>
        )}

        {/* Error */}
        {error && (
          <div className="mb-4 p-3 bg-red-900/30 border border-red-700 rounded-md">
            <p className="text-sm text-red-300">{error}</p>
          </div>
        )}

        {/* Actions */}
        <div className="flex justify-end gap-3">
          <button
            type="button"
            onClick={handleClose}
            disabled={isProcessing}
            className="px-4 py-2 text-sm font-medium text-gray-300 bg-gray-700 rounded-md hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-gray-500"
          >
            {status === 'completed' ? 'Close' : 'Cancel'}
          </button>
          {status === 'idle' && (
            <button
              type="button"
              onClick={mergeType === 'ai' ? handleAIMerge : handleCreatePR}
              className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              {mergeType === 'ai' ? 'Start Merge' : 'Create PR'}
            </button>
          )}
        </div>
      </div>
    </div>
  )
}
```

Update `src/renderer/src/components/Feature/index.ts` to export FeatureMergeDialog.

Update `src/renderer/src/views/KanbanView.tsx`:
- Import FeatureMergeDialog from '../components/Feature'
- Add state: `const [mergeDialogOpen, setMergeDialogOpen] = useState(false)`
- Add state: `const [featureToMerge, setFeatureToMerge] = useState<Feature | null>(null)`
- Add state: `const [mergeType, setMergeType] = useState<MergeType | null>(null)`
- Update handleMergeFeature to set these states and open dialog:
  ```typescript
  const handleMergeFeature = (featureId: string, mergeType: MergeType) => {
    const feature = features.find((f) => f.id === featureId)
    if (feature) {
      setFeatureToMerge(feature)
      setMergeType(mergeType)
      setMergeDialogOpen(true)
    }
  }
  ```
- Add FeatureMergeDialog after DeleteFeatureDialog in JSX:
  ```tsx
  <FeatureMergeDialog
    isOpen={mergeDialogOpen}
    onClose={() => {
      setMergeDialogOpen(false)
      setFeatureToMerge(null)
      setMergeType(null)
    }}
    feature={featureToMerge}
    mergeType={mergeType}
  />
  ```
  </action>
  <verify>npm run build passes, app starts without errors</verify>
  <done>FeatureMergeDialog component created and wired to KanbanView handleMergeFeature</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run typecheck passes
- [ ] npm run build passes
- [ ] App launches without console errors
- [ ] Merge button dropdown shows AI Merge and Create PR options on completed features
- [ ] AI Merge opens dialog and shows merge options
- [ ] Create PR opens dialog and shows PR form
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Feature merge workflow wired end-to-end: button → dialog → agent → feedback
- Both AI Merge and Create PR paths functional
</success_criteria>

<output>
After completion, create `.planning/phases/55-merge-workflow-integration/55-01-SUMMARY.md`
</output>
