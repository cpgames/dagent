---
phase: 02-data-model
plan: 03
type: execute
---

<objective>
Implement Zustand stores for state management in the renderer.

Purpose: Provide reactive state management for features, DAGs, and UI state with persistence sync.
Output: Zustand stores in src/renderer/src/stores/ that sync with main process storage.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./02-03-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-model/02-01-SUMMARY.md
@.planning/phases/02-data-model/02-02-SUMMARY.md
@DAGENT_SPEC.md (section 12.3 for Zustand requirement)

**Tech stack available:** Electron, React, TypeScript, Zustand
**Established patterns:** IPC via contextBridge, storage API in preload
**Types available:** Feature, Task, Connection, DAGGraph, ChatHistory
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zustand and create feature store</name>
  <files>package.json, src/renderer/src/stores/feature-store.ts</files>
  <action>
Install Zustand:
```bash
npm install zustand
```

Create src/renderer/src/stores/feature-store.ts:
```typescript
import { create } from 'zustand';
import type { Feature } from '@shared/types';

interface FeatureState {
  features: Feature[];
  activeFeatureId: string | null;
  isLoading: boolean;
  error: string | null;

  // Actions
  setFeatures: (features: Feature[]) => void;
  setActiveFeature: (featureId: string | null) => void;
  addFeature: (feature: Feature) => void;
  updateFeature: (featureId: string, updates: Partial<Feature>) => void;
  removeFeature: (featureId: string) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;

  // Async actions (call IPC)
  loadFeatures: () => Promise<void>;
  saveFeature: (feature: Feature) => Promise<void>;
}

export const useFeatureStore = create<FeatureState>((set, get) => ({
  features: [],
  activeFeatureId: null,
  isLoading: false,
  error: null,

  setFeatures: (features) => set({ features }),
  setActiveFeature: (featureId) => set({ activeFeatureId: featureId }),
  addFeature: (feature) => set((state) => ({
    features: [...state.features, feature]
  })),
  updateFeature: (featureId, updates) => set((state) => ({
    features: state.features.map((f) =>
      f.id === featureId ? { ...f, ...updates, updatedAt: new Date().toISOString() } : f
    ),
  })),
  removeFeature: (featureId) => set((state) => ({
    features: state.features.filter((f) => f.id !== featureId),
    activeFeatureId: state.activeFeatureId === featureId ? null : state.activeFeatureId,
  })),
  setLoading: (isLoading) => set({ isLoading }),
  setError: (error) => set({ error }),

  loadFeatures: async () => {
    set({ isLoading: true, error: null });
    try {
      const featureIds = await window.electronAPI.storage.listFeatures();
      const features: Feature[] = [];
      for (const id of featureIds) {
        const feature = await window.electronAPI.storage.loadFeature(id);
        if (feature) features.push(feature);
      }
      set({ features, isLoading: false });
    } catch (error) {
      set({ error: (error as Error).message, isLoading: false });
    }
  },

  saveFeature: async (feature) => {
    try {
      await window.electronAPI.storage.saveFeature(feature);
      get().updateFeature(feature.id, feature);
    } catch (error) {
      set({ error: (error as Error).message });
    }
  },
}));
```
  </action>
  <verify>npm run typecheck passes, Zustand installed in package.json</verify>
  <done>Feature store created with persistence sync via IPC</done>
</task>

<task type="auto">
  <name>Task 2: Create DAG store for graph state</name>
  <files>src/renderer/src/stores/dag-store.ts, src/renderer/src/stores/index.ts</files>
  <action>
Create src/renderer/src/stores/dag-store.ts:
```typescript
import { create } from 'zustand';
import type { DAGGraph, Task, Connection } from '@shared/types';

interface DAGState {
  // Current DAG (for active feature)
  dag: DAGGraph | null;
  isLoading: boolean;
  error: string | null;

  // Selection state
  selectedNodeId: string | null;

  // Actions
  setDag: (dag: DAGGraph | null) => void;
  setSelectedNode: (nodeId: string | null) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;

  // Node operations
  addNode: (node: Task) => void;
  updateNode: (nodeId: string, updates: Partial<Task>) => void;
  removeNode: (nodeId: string) => void;

  // Connection operations
  addConnection: (connection: Connection) => void;
  removeConnection: (from: string, to: string) => void;

  // Async actions
  loadDag: (featureId: string) => Promise<void>;
  saveDag: (featureId: string) => Promise<void>;
}

export const useDAGStore = create<DAGState>((set, get) => ({
  dag: null,
  isLoading: false,
  error: null,
  selectedNodeId: null,

  setDag: (dag) => set({ dag }),
  setSelectedNode: (nodeId) => set({ selectedNodeId: nodeId }),
  setLoading: (isLoading) => set({ isLoading }),
  setError: (error) => set({ error }),

  addNode: (node) => set((state) => {
    if (!state.dag) return state;
    return {
      dag: {
        ...state.dag,
        nodes: [...state.dag.nodes, node],
      },
    };
  }),

  updateNode: (nodeId, updates) => set((state) => {
    if (!state.dag) return state;
    return {
      dag: {
        ...state.dag,
        nodes: state.dag.nodes.map((n) =>
          n.id === nodeId ? { ...n, ...updates } : n
        ),
      },
    };
  }),

  removeNode: (nodeId) => set((state) => {
    if (!state.dag) return state;
    return {
      dag: {
        nodes: state.dag.nodes.filter((n) => n.id !== nodeId),
        connections: state.dag.connections.filter(
          (c) => c.from !== nodeId && c.to !== nodeId
        ),
      },
      selectedNodeId: state.selectedNodeId === nodeId ? null : state.selectedNodeId,
    };
  }),

  addConnection: (connection) => set((state) => {
    if (!state.dag) return state;
    // Check if connection already exists
    const exists = state.dag.connections.some(
      (c) => c.from === connection.from && c.to === connection.to
    );
    if (exists) return state;
    return {
      dag: {
        ...state.dag,
        connections: [...state.dag.connections, connection],
      },
    };
  }),

  removeConnection: (from, to) => set((state) => {
    if (!state.dag) return state;
    return {
      dag: {
        ...state.dag,
        connections: state.dag.connections.filter(
          (c) => !(c.from === from && c.to === to)
        ),
      },
    };
  }),

  loadDag: async (featureId) => {
    set({ isLoading: true, error: null });
    try {
      const dag = await window.electronAPI.storage.loadDag(featureId);
      set({ dag: dag || { nodes: [], connections: [] }, isLoading: false });
    } catch (error) {
      set({ error: (error as Error).message, isLoading: false });
    }
  },

  saveDag: async (featureId) => {
    const { dag } = get();
    if (!dag) return;
    try {
      await window.electronAPI.storage.saveDag(featureId, dag);
    } catch (error) {
      set({ error: (error as Error).message });
    }
  },
}));
```

Create src/renderer/src/stores/index.ts:
```typescript
export { useFeatureStore } from './feature-store';
export { useDAGStore } from './dag-store';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>DAG store created with node and connection operations</done>
</task>

<task type="auto">
  <name>Task 3: Integrate stores with App component</name>
  <files>src/renderer/src/App.tsx</files>
  <action>
Update src/renderer/src/App.tsx to demonstrate store usage:
```typescript
import { useEffect } from 'react';
import { useFeatureStore, useDAGStore } from './stores';

function App() {
  const { features, isLoading, error, loadFeatures } = useFeatureStore();
  const { dag } = useDAGStore();

  useEffect(() => {
    // Load features on mount
    loadFeatures();
  }, [loadFeatures]);

  // Keep existing ping/appInfo logic, add store display

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4">
      <header className="flex justify-between items-center mb-8">
        <h1 className="text-2xl font-bold text-blue-400">DAGent</h1>
        {/* Keep existing window controls */}
      </header>

      <main>
        <section className="mb-4">
          <h2 className="text-lg font-semibold mb-2">Features ({features.length})</h2>
          {isLoading && <p className="text-gray-400">Loading...</p>}
          {error && <p className="text-red-400">{error}</p>}
          {features.length === 0 && !isLoading && (
            <p className="text-gray-500">No features yet</p>
          )}
          <ul className="space-y-1">
            {features.map((f) => (
              <li key={f.id} className="text-gray-300">
                {f.name} - {f.status}
              </li>
            ))}
          </ul>
        </section>

        <section>
          <h2 className="text-lg font-semibold mb-2">
            DAG Nodes: {dag?.nodes.length ?? 0}
          </h2>
          <p className="text-gray-500">
            Connections: {dag?.connections.length ?? 0}
          </p>
        </section>
      </main>
    </div>
  );
}

export default App;
```

Note: Preserve existing window control buttons and IPC test code, just add the store integration.
  </action>
  <verify>npm run dev starts, UI shows feature count and DAG node count</verify>
  <done>Stores integrated with App, reactive state working</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] Zustand installed and stores created
- [ ] Feature store syncs with main process storage
- [ ] DAG store provides node/connection operations
- [ ] App component displays store state
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Zustand stores ready for UI views (Phase 6)
- Phase 2: Data Model & Storage complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-model/02-03-SUMMARY.md` with:
- Zustand stores created
- Store architecture (feature store, DAG store)
- Integration pattern with IPC storage
- Phase 2 complete, ready for Phase 3
</output>
