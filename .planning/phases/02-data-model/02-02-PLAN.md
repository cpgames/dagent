---
phase: 02-data-model
plan: 02
type: execute
---

<objective>
Implement JSON file operations for .dagent directory structure.

Purpose: Enable persistent storage of features, DAGs, chat history, and logs.
Output: Storage service in main process with IPC handlers for CRUD operations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./02-02-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-model/02-01-SUMMARY.md
@DAGENT_SPEC.md (section 9 for storage structure)

**Tech stack available:** Electron, React, TypeScript, Node.js fs/promises
**Established patterns:** IPC via contextBridge, main/preload/renderer separation
**Types available:** Feature, Task, Connection, DAGGraph, ChatHistory, AgentLog
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage service for JSON file operations</name>
  <files>src/main/storage/index.ts, src/main/storage/json-store.ts</files>
  <action>
Create src/main/storage/json-store.ts with generic JSON file operations:
```typescript
import { promises as fs } from 'fs';
import path from 'path';

export async function readJson<T>(filePath: string): Promise<T | null> {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return JSON.parse(content) as T;
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return null;
    }
    throw error;
  }
}

export async function writeJson<T>(filePath: string, data: T): Promise<void> {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
  await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');
}

export async function deleteJson(filePath: string): Promise<boolean> {
  try {
    await fs.unlink(filePath);
    return true;
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return false;
    }
    throw error;
  }
}

export async function exists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
```

Create src/main/storage/index.ts that re-exports:
```typescript
export * from './json-store';
```
  </action>
  <verify>TypeScript compiles: npm run typecheck passes</verify>
  <done>Generic JSON storage utilities created</done>
</task>

<task type="auto">
  <name>Task 2: Create feature storage with .dagent directory management</name>
  <files>src/main/storage/feature-store.ts, src/main/storage/paths.ts</files>
  <action>
Create src/main/storage/paths.ts with path utilities following DAGENT_SPEC section 9.1:
```typescript
import path from 'path';

export function getWorktreesDir(projectRoot: string): string {
  return path.join(projectRoot, '.dagent-worktrees');
}

export function getFeatureDir(projectRoot: string, featureId: string): string {
  return path.join(getWorktreesDir(projectRoot), featureId, '.dagent');
}

export function getFeaturePath(projectRoot: string, featureId: string): string {
  return path.join(getFeatureDir(projectRoot, featureId), 'feature.json');
}

export function getDagPath(projectRoot: string, featureId: string): string {
  return path.join(getFeatureDir(projectRoot, featureId), 'dag.json');
}

export function getChatPath(projectRoot: string, featureId: string): string {
  return path.join(getFeatureDir(projectRoot, featureId), 'chat.json');
}

export function getHarnessLogPath(projectRoot: string, featureId: string): string {
  return path.join(getFeatureDir(projectRoot, featureId), 'harness_log.json');
}

export function getNodeDir(projectRoot: string, featureId: string, nodeId: string): string {
  return path.join(getFeatureDir(projectRoot, featureId), 'nodes', nodeId);
}

export function getNodeChatPath(projectRoot: string, featureId: string, nodeId: string): string {
  return path.join(getNodeDir(projectRoot, featureId, nodeId), 'chat.json');
}

export function getNodeLogsPath(projectRoot: string, featureId: string, nodeId: string): string {
  return path.join(getNodeDir(projectRoot, featureId, nodeId), 'logs.json');
}

export function getArchivedDir(projectRoot: string): string {
  return path.join(projectRoot, '.dagent-archived');
}
```

Create src/main/storage/feature-store.ts with feature operations:
```typescript
import { Feature, DAGGraph, ChatHistory, AgentLog } from '@shared/types';
import { readJson, writeJson, deleteJson, exists } from './json-store';
import * as paths from './paths';
import { promises as fs } from 'fs';

export class FeatureStore {
  constructor(private projectRoot: string) {}

  async saveFeature(feature: Feature): Promise<void> {
    const filePath = paths.getFeaturePath(this.projectRoot, feature.id);
    await writeJson(filePath, feature);
  }

  async loadFeature(featureId: string): Promise<Feature | null> {
    const filePath = paths.getFeaturePath(this.projectRoot, featureId);
    return readJson<Feature>(filePath);
  }

  async saveDag(featureId: string, dag: DAGGraph): Promise<void> {
    const filePath = paths.getDagPath(this.projectRoot, featureId);
    await writeJson(filePath, dag);
  }

  async loadDag(featureId: string): Promise<DAGGraph | null> {
    const filePath = paths.getDagPath(this.projectRoot, featureId);
    return readJson<DAGGraph>(filePath);
  }

  async listFeatures(): Promise<string[]> {
    const worktreesDir = paths.getWorktreesDir(this.projectRoot);
    try {
      const entries = await fs.readdir(worktreesDir, { withFileTypes: true });
      const featureIds: string[] = [];
      for (const entry of entries) {
        if (entry.isDirectory()) {
          const featurePath = paths.getFeaturePath(this.projectRoot, entry.name);
          if (await exists(featurePath)) {
            featureIds.push(entry.name);
          }
        }
      }
      return featureIds;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        return [];
      }
      throw error;
    }
  }
}
```

Update src/main/storage/index.ts:
```typescript
export * from './json-store';
export * from './paths';
export * from './feature-store';
```
  </action>
  <verify>TypeScript compiles: npm run typecheck passes</verify>
  <done>Feature storage with proper .dagent directory structure</done>
</task>

<task type="auto">
  <name>Task 3: Add storage IPC handlers</name>
  <files>src/main/ipc/storage-handlers.ts, src/main/ipc/handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Create src/main/ipc/storage-handlers.ts:
```typescript
import { ipcMain } from 'electron';
import { FeatureStore } from '../storage/feature-store';
import type { Feature, DAGGraph } from '@shared/types';

let featureStore: FeatureStore | null = null;

export function initializeStorage(projectRoot: string): void {
  featureStore = new FeatureStore(projectRoot);
}

export function registerStorageHandlers(): void {
  ipcMain.handle('storage:saveFeature', async (_event, feature: Feature) => {
    if (!featureStore) throw new Error('Storage not initialized');
    await featureStore.saveFeature(feature);
    return true;
  });

  ipcMain.handle('storage:loadFeature', async (_event, featureId: string) => {
    if (!featureStore) throw new Error('Storage not initialized');
    return featureStore.loadFeature(featureId);
  });

  ipcMain.handle('storage:saveDag', async (_event, featureId: string, dag: DAGGraph) => {
    if (!featureStore) throw new Error('Storage not initialized');
    await featureStore.saveDag(featureId, dag);
    return true;
  });

  ipcMain.handle('storage:loadDag', async (_event, featureId: string) => {
    if (!featureStore) throw new Error('Storage not initialized');
    return featureStore.loadDag(featureId);
  });

  ipcMain.handle('storage:listFeatures', async () => {
    if (!featureStore) throw new Error('Storage not initialized');
    return featureStore.listFeatures();
  });
}
```

Update src/main/ipc/handlers.ts to register storage handlers and initialize with project root.

Update src/preload/index.ts to expose storage methods:
```typescript
storage: {
  saveFeature: (feature: Feature) => ipcRenderer.invoke('storage:saveFeature', feature),
  loadFeature: (featureId: string) => ipcRenderer.invoke('storage:loadFeature', featureId),
  saveDag: (featureId: string, dag: DAGGraph) => ipcRenderer.invoke('storage:saveDag', featureId, dag),
  loadDag: (featureId: string) => ipcRenderer.invoke('storage:loadDag', featureId),
  listFeatures: () => ipcRenderer.invoke('storage:listFeatures'),
}
```

Update src/preload/index.d.ts with storage types.
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>Storage IPC fully wired up, accessible from renderer</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] Storage service files exist in src/main/storage/
- [ ] IPC handlers registered for storage operations
- [ ] Preload exposes storage API to renderer
- [ ] Path utilities match DAGENT_SPEC section 9.1 structure
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Storage layer ready for Zustand integration (Plan 02-03)
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-model/02-02-SUMMARY.md` with:
- Storage service architecture
- IPC handlers added
- Path structure following spec
- Ready for Plan 02-03
</output>
