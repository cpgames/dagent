---
phase: 05-agent-system
plan: 03
type: execute
---

<objective>
Implement task agent that executes individual tasks with intention-approval workflow.

Purpose: Create agents that implement specific tasks in isolated worktrees with harness oversight.
Output: Task agent module with context loading, intention proposal, and execution capabilities.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./05-03-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-agent-system/05-01-SUMMARY.md (agent pool)
@.planning/phases/05-agent-system/05-02-SUMMARY.md (harness agent)
@.planning/phases/04-git-integration/04-02-SUMMARY.md (worktree operations)
@DAGENT_SPEC.md (section 7 agent communication, section 8.3 worktree lifecycle)

**Tech stack available:** Electron, TypeScript, AgentPool, HarnessAgent, GitManager
**Established patterns:** Event emitters, singleton managers, IPC handlers

**Task agent from DAGENT_SPEC:**
- Implements specific task in isolation
- Has context: CLAUDE.md, task description, context handoffs from completed dependencies
- Proposes intentions to harness before implementation
- Receives approval/rejection/modification from harness
- Works in dedicated task worktree

**Intention format (section 7.3):**
- Brief: 1-2 sentences per item
- Batched: logically grouped
- Clear: state what, not how
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create task agent types and context assembly</name>
  <files>src/main/agents/task-types.ts</files>
  <action>
Create task-types.ts with types for task agent state and context:
```typescript
import type { Task, DAGGraph } from '@shared/types';
import type { AgentContext, IntentionMessage, ApprovalMessage } from './types';
import type { IntentionDecision } from './harness-types';

export type TaskAgentStatus =
  | 'initializing'
  | 'loading_context'
  | 'proposing_intention'
  | 'awaiting_approval'
  | 'approved'
  | 'working'
  | 'completed'
  | 'failed';

export interface TaskAgentState {
  status: TaskAgentStatus;
  agentId: string | null;
  featureId: string;
  taskId: string;
  task: Task | null;
  context: TaskContext | null;
  intention: string | null;
  approval: IntentionDecision | null;
  worktreePath: string | null;
  error: string | null;
  startedAt: string | null;
  completedAt: string | null;
}

export interface TaskContext {
  // Project-level context
  claudeMd: string | null;
  featureGoal: string | null;

  // Task-specific context
  taskDescription: string;
  taskTitle: string;

  // Dependency context (from completed parent tasks)
  dependencyContext: DependencyContextEntry[];

  // Working directory
  worktreePath: string;
}

export interface DependencyContextEntry {
  taskId: string;
  taskTitle: string;
  summary: string;        // What was implemented
  keyFiles?: string[];    // Important files created/modified
  exports?: string[];     // Public interfaces/exports
}

export interface TaskAgentConfig {
  autoPropose: boolean;   // Auto-generate intention (default: true)
  autoExecute: boolean;   // Auto-execute after approval (default: true)
}

export interface TaskExecutionResult {
  success: boolean;
  taskId: string;
  filesModified?: string[];
  summary?: string;
  error?: string;
}

export const DEFAULT_TASK_AGENT_CONFIG: TaskAgentConfig = {
  autoPropose: true,
  autoExecute: true,
};

export const DEFAULT_TASK_AGENT_STATE: Omit<TaskAgentState, 'featureId' | 'taskId'> = {
  status: 'initializing',
  agentId: null,
  task: null,
  context: null,
  intention: null,
  approval: null,
  worktreePath: null,
  error: null,
  startedAt: null,
  completedAt: null,
};
```

Update src/main/agents/index.ts:
```typescript
export * from './types';
export * from './agent-pool';
export * from './harness-types';
export * from './harness-agent';
export * from './task-types';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Task agent types defined: TaskAgentState, TaskContext, DependencyContextEntry</done>
</task>

<task type="auto">
  <name>Task 2: Implement TaskAgent class</name>
  <files>src/main/agents/task-agent.ts</files>
  <action>
Create task-agent.ts with the TaskAgent class:
```typescript
import { EventEmitter } from 'events';
import type { Task, DAGGraph } from '@shared/types';
import type {
  TaskAgentState,
  TaskAgentStatus,
  TaskContext,
  DependencyContextEntry,
  TaskAgentConfig,
  TaskExecutionResult,
  DEFAULT_TASK_AGENT_STATE,
  DEFAULT_TASK_AGENT_CONFIG,
} from './task-types';
import type { IntentionDecision } from './harness-types';
import { getAgentPool } from './agent-pool';
import { getHarnessAgent } from './harness-agent';
import { getGitManager } from '../git';
import { getTaskWorktreeName } from '../git/types';

export class TaskAgent extends EventEmitter {
  private state: TaskAgentState;
  private config: TaskAgentConfig;

  constructor(featureId: string, taskId: string, config: Partial<TaskAgentConfig> = {}) {
    super();
    this.state = {
      ...DEFAULT_TASK_AGENT_STATE,
      featureId,
      taskId,
    };
    this.config = { ...DEFAULT_TASK_AGENT_CONFIG, ...config };
  }

  /**
   * Initialize task agent with task and context.
   */
  async initialize(
    task: Task,
    graph: DAGGraph,
    claudeMd?: string,
    featureGoal?: string
  ): Promise<boolean> {
    if (this.state.status !== 'initializing') {
      return false;
    }

    this.state.task = task;
    this.state.startedAt = new Date().toISOString();

    // Register with agent pool
    const pool = getAgentPool();
    if (!pool.canSpawn('task')) {
      this.state.status = 'failed';
      this.state.error = 'Cannot spawn task agent - pool limit reached';
      return false;
    }

    const agentInfo = pool.registerAgent({
      type: 'task',
      featureId: this.state.featureId,
      taskId: this.state.taskId,
    });

    this.state.agentId = agentInfo.id;
    pool.updateAgentStatus(agentInfo.id, 'busy', this.state.taskId);

    // Register with harness
    const harness = getHarnessAgent();
    harness.registerTaskAssignment(this.state.taskId, agentInfo.id);

    this.emit('task-agent:initialized', this.getState());

    // Load context
    this.state.status = 'loading_context';
    const contextLoaded = await this.loadContext(graph, claudeMd, featureGoal);

    if (!contextLoaded) {
      this.state.status = 'failed';
      this.state.error = 'Failed to load task context';
      return false;
    }

    return true;
  }

  /**
   * Load context for task execution.
   */
  private async loadContext(
    graph: DAGGraph,
    claudeMd?: string,
    featureGoal?: string
  ): Promise<boolean> {
    try {
      const task = this.state.task!;

      // Create task worktree
      const gitManager = getGitManager();
      const worktreeResult = await gitManager.createTaskWorktree(
        this.state.featureId,
        this.state.taskId
      );

      if (!worktreeResult.success || !worktreeResult.worktreePath) {
        this.state.error = worktreeResult.error || 'Failed to create task worktree';
        return false;
      }

      this.state.worktreePath = worktreeResult.worktreePath;

      // Get dependency context from completed parent tasks
      const dependencyContext = this.assembleDependencyContext(graph);

      // Build full context
      this.state.context = {
        claudeMd: claudeMd || null,
        featureGoal: featureGoal || null,
        taskTitle: task.title,
        taskDescription: task.description,
        dependencyContext,
        worktreePath: worktreeResult.worktreePath,
      };

      this.emit('task-agent:context-loaded', this.state.context);
      return true;
    } catch (error) {
      this.state.error = (error as Error).message;
      return false;
    }
  }

  /**
   * Assemble context from completed dependency tasks.
   */
  private assembleDependencyContext(graph: DAGGraph): DependencyContextEntry[] {
    const taskId = this.state.taskId;
    const dependencies: DependencyContextEntry[] = [];

    // Find all incoming connections (parent tasks)
    const parentConnections = graph.connections.filter(c => c.to === taskId);
    const parentIds = parentConnections.map(c => c.from);

    // Get completed parent tasks
    for (const parentId of parentIds) {
      const parentTask = graph.nodes.find(n => n.id === parentId);
      if (parentTask && parentTask.status === 'completed') {
        dependencies.push({
          taskId: parentTask.id,
          taskTitle: parentTask.title,
          summary: `Completed: ${parentTask.description}`,
          // In full implementation, would load from task logs/summary
        });
      }
    }

    return dependencies;
  }

  /**
   * Propose an intention to the harness.
   */
  async proposeIntention(intention?: string): Promise<boolean> {
    if (this.state.status !== 'loading_context' && this.state.status !== 'approved') {
      return false;
    }

    this.state.status = 'proposing_intention';

    // Generate intention if not provided
    const intentionText = intention || this.generateIntention();
    this.state.intention = intentionText;

    // Send to harness
    const harness = getHarnessAgent();
    harness.receiveIntention(
      this.state.agentId!,
      this.state.taskId,
      intentionText
    );

    this.state.status = 'awaiting_approval';
    this.emit('task-agent:intention-proposed', intentionText);

    return true;
  }

  /**
   * Generate an intention based on task context.
   */
  private generateIntention(): string {
    const context = this.state.context!;
    const task = this.state.task!;

    let intention = `INTENTION: Implement "${task.title}"`;

    if (task.description) {
      intention += `\n\n${task.description}`;
    }

    if (context.dependencyContext.length > 0) {
      intention += `\n\nBuilding on completed work from: ${
        context.dependencyContext.map(d => d.taskTitle).join(', ')
      }`;
    }

    return intention;
  }

  /**
   * Receive approval decision from harness.
   */
  receiveApproval(decision: IntentionDecision): void {
    if (this.state.status !== 'awaiting_approval') {
      return;
    }

    this.state.approval = decision;

    if (decision.approved) {
      this.state.status = 'approved';
      this.emit('task-agent:approved', decision);

      // Update harness
      const harness = getHarnessAgent();
      harness.markTaskWorking(this.state.taskId);

      if (this.config.autoExecute) {
        this.execute();
      }
    } else {
      this.state.status = 'failed';
      this.state.error = decision.reason || 'Intention rejected';
      this.emit('task-agent:rejected', decision);
    }
  }

  /**
   * Execute the approved task.
   * In full implementation, this would invoke Claude API.
   */
  async execute(): Promise<TaskExecutionResult> {
    if (this.state.status !== 'approved') {
      return {
        success: false,
        taskId: this.state.taskId,
        error: 'Task not approved for execution',
      };
    }

    this.state.status = 'working';
    this.emit('task-agent:executing');

    try {
      // In full implementation, this would:
      // 1. Call Claude API with context
      // 2. Apply changes to worktree
      // 3. Commit changes
      // For now, simulate completion

      // Simulate work delay
      await new Promise(resolve => setTimeout(resolve, 100));

      this.state.status = 'completed';
      this.state.completedAt = new Date().toISOString();

      const result: TaskExecutionResult = {
        success: true,
        taskId: this.state.taskId,
        summary: `Completed: ${this.state.task?.title}`,
      };

      this.emit('task-agent:completed', result);
      return result;
    } catch (error) {
      this.state.status = 'failed';
      this.state.error = (error as Error).message;

      const result: TaskExecutionResult = {
        success: false,
        taskId: this.state.taskId,
        error: this.state.error,
      };

      this.emit('task-agent:failed', result);
      return result;
    }
  }

  /**
   * Get current task agent state.
   */
  getState(): TaskAgentState {
    return { ...this.state };
  }

  /**
   * Get task agent status.
   */
  getStatus(): TaskAgentStatus {
    return this.state.status;
  }

  /**
   * Clean up task agent resources.
   */
  async cleanup(removeWorktree: boolean = false): Promise<void> {
    // Release from pool
    if (this.state.agentId) {
      const pool = getAgentPool();
      pool.terminateAgent(this.state.agentId);
    }

    // Remove worktree if requested (typically on failure for debugging)
    if (removeWorktree && this.state.worktreePath) {
      const gitManager = getGitManager();
      await gitManager.removeWorktree(this.state.worktreePath, true);
    }

    this.emit('task-agent:cleanup');
  }
}

// Factory for creating task agents
export function createTaskAgent(
  featureId: string,
  taskId: string,
  config?: Partial<TaskAgentConfig>
): TaskAgent {
  return new TaskAgent(featureId, taskId, config);
}

// Active task agents registry
const activeTaskAgents: Map<string, TaskAgent> = new Map();

export function registerTaskAgent(agent: TaskAgent): void {
  activeTaskAgents.set(agent.getState().taskId, agent);
}

export function getTaskAgent(taskId: string): TaskAgent | undefined {
  return activeTaskAgents.get(taskId);
}

export function removeTaskAgent(taskId: string): boolean {
  return activeTaskAgents.delete(taskId);
}

export function getAllTaskAgents(): TaskAgent[] {
  return Array.from(activeTaskAgents.values());
}

export function clearTaskAgents(): void {
  for (const agent of activeTaskAgents.values()) {
    agent.cleanup(false);
  }
  activeTaskAgents.clear();
}
```

Update src/main/agents/index.ts:
```typescript
export * from './types';
export * from './agent-pool';
export * from './harness-types';
export * from './harness-agent';
export * from './task-types';
export * from './task-agent';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>TaskAgent class with context loading, intention proposal, approval handling, and execution</done>
</task>

<task type="auto">
  <name>Task 3: Add task agent IPC handlers and preload exposure</name>
  <files>src/main/ipc/task-agent-handlers.ts, src/main/ipc/handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Create src/main/ipc/task-agent-handlers.ts:
```typescript
import { ipcMain } from 'electron';
import {
  createTaskAgent,
  registerTaskAgent,
  getTaskAgent,
  removeTaskAgent,
  getAllTaskAgents,
  clearTaskAgents,
} from '../agents';
import type { Task, DAGGraph } from '@shared/types';
import type { TaskAgentConfig } from '../agents/task-types';
import type { IntentionDecision } from '../agents/harness-types';

export function registerTaskAgentHandlers(): void {
  ipcMain.handle('task-agent:create', async (
    _event,
    featureId: string,
    taskId: string,
    task: Task,
    graph: DAGGraph,
    claudeMd?: string,
    featureGoal?: string,
    config?: Partial<TaskAgentConfig>
  ) => {
    const agent = createTaskAgent(featureId, taskId, config);
    const initialized = await agent.initialize(task, graph, claudeMd, featureGoal);

    if (initialized) {
      registerTaskAgent(agent);
    }

    return {
      success: initialized,
      state: agent.getState(),
    };
  });

  ipcMain.handle('task-agent:get-state', async (_event, taskId: string) => {
    const agent = getTaskAgent(taskId);
    return agent?.getState() || null;
  });

  ipcMain.handle('task-agent:get-status', async (_event, taskId: string) => {
    const agent = getTaskAgent(taskId);
    return agent?.getStatus() || null;
  });

  ipcMain.handle('task-agent:get-all', async () => {
    return getAllTaskAgents().map(a => a.getState());
  });

  ipcMain.handle('task-agent:propose-intention', async (
    _event,
    taskId: string,
    intention?: string
  ) => {
    const agent = getTaskAgent(taskId);
    if (!agent) return false;
    return agent.proposeIntention(intention);
  });

  ipcMain.handle('task-agent:receive-approval', async (
    _event,
    taskId: string,
    decision: IntentionDecision
  ) => {
    const agent = getTaskAgent(taskId);
    if (!agent) return false;
    agent.receiveApproval(decision);
    return true;
  });

  ipcMain.handle('task-agent:execute', async (_event, taskId: string) => {
    const agent = getTaskAgent(taskId);
    if (!agent) return { success: false, taskId, error: 'Agent not found' };
    return agent.execute();
  });

  ipcMain.handle('task-agent:cleanup', async (
    _event,
    taskId: string,
    removeWorktree: boolean = false
  ) => {
    const agent = getTaskAgent(taskId);
    if (!agent) return false;
    await agent.cleanup(removeWorktree);
    removeTaskAgent(taskId);
    return true;
  });

  ipcMain.handle('task-agent:clear-all', async () => {
    clearTaskAgents();
    return true;
  });
}
```

Update src/main/ipc/handlers.ts:
```typescript
import { registerTaskAgentHandlers } from './task-agent-handlers';

export function registerAllHandlers(): void {
  // ... existing handlers
  registerTaskAgentHandlers();
}
```

Update src/preload/index.ts:
```typescript
const taskAgentAPI = {
  create: (
    featureId: string,
    taskId: string,
    task: Task,
    graph: DAGGraph,
    claudeMd?: string,
    featureGoal?: string,
    config?: Partial<TaskAgentConfig>
  ) => ipcRenderer.invoke('task-agent:create', featureId, taskId, task, graph, claudeMd, featureGoal, config),
  getState: (taskId: string) => ipcRenderer.invoke('task-agent:get-state', taskId),
  getStatus: (taskId: string) => ipcRenderer.invoke('task-agent:get-status', taskId),
  getAll: () => ipcRenderer.invoke('task-agent:get-all'),
  proposeIntention: (taskId: string, intention?: string) =>
    ipcRenderer.invoke('task-agent:propose-intention', taskId, intention),
  receiveApproval: (taskId: string, decision: IntentionDecision) =>
    ipcRenderer.invoke('task-agent:receive-approval', taskId, decision),
  execute: (taskId: string) => ipcRenderer.invoke('task-agent:execute', taskId),
  cleanup: (taskId: string, removeWorktree?: boolean) =>
    ipcRenderer.invoke('task-agent:cleanup', taskId, removeWorktree),
  clearAll: () => ipcRenderer.invoke('task-agent:clear-all'),
};

// Add to contextBridge
contextBridge.exposeInMainWorld('electronAPI', {
  // ... existing
  taskAgent: taskAgentAPI,
});
```

Update src/preload/index.d.ts:
```typescript
type TaskAgentStatus =
  | 'initializing'
  | 'loading_context'
  | 'proposing_intention'
  | 'awaiting_approval'
  | 'approved'
  | 'working'
  | 'completed'
  | 'failed';

interface TaskContext {
  claudeMd: string | null;
  featureGoal: string | null;
  taskTitle: string;
  taskDescription: string;
  dependencyContext: DependencyContextEntry[];
  worktreePath: string;
}

interface DependencyContextEntry {
  taskId: string;
  taskTitle: string;
  summary: string;
  keyFiles?: string[];
  exports?: string[];
}

interface TaskAgentState {
  status: TaskAgentStatus;
  agentId: string | null;
  featureId: string;
  taskId: string;
  task: Task | null;
  context: TaskContext | null;
  intention: string | null;
  approval: IntentionDecision | null;
  worktreePath: string | null;
  error: string | null;
  startedAt: string | null;
  completedAt: string | null;
}

interface TaskAgentConfig {
  autoPropose: boolean;
  autoExecute: boolean;
}

interface TaskExecutionResult {
  success: boolean;
  taskId: string;
  filesModified?: string[];
  summary?: string;
  error?: string;
}

interface TaskAgentCreateResult {
  success: boolean;
  state: TaskAgentState;
}

interface TaskAgentAPI {
  create: (
    featureId: string,
    taskId: string,
    task: Task,
    graph: DAGGraph,
    claudeMd?: string,
    featureGoal?: string,
    config?: Partial<TaskAgentConfig>
  ) => Promise<TaskAgentCreateResult>;
  getState: (taskId: string) => Promise<TaskAgentState | null>;
  getStatus: (taskId: string) => Promise<TaskAgentStatus | null>;
  getAll: () => Promise<TaskAgentState[]>;
  proposeIntention: (taskId: string, intention?: string) => Promise<boolean>;
  receiveApproval: (taskId: string, decision: IntentionDecision) => Promise<boolean>;
  execute: (taskId: string) => Promise<TaskExecutionResult>;
  cleanup: (taskId: string, removeWorktree?: boolean) => Promise<boolean>;
  clearAll: () => Promise<boolean>;
}

interface ElectronAPI {
  // ... existing
  taskAgent: TaskAgentAPI;
}
```
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>Task agent IPC handlers expose full lifecycle to renderer</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] TaskAgent class with full lifecycle (initialize, proposeIntention, execute)
- [ ] Context assembly from completed dependencies
- [ ] Worktree creation per task
- [ ] Integration with AgentPool and HarnessAgent
- [ ] IPC handlers expose all task agent operations
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Task agent ready for merge agent integration (Plan 05-04)
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-system/05-03-SUMMARY.md` with:
- TaskAgent class structure
- Context assembly from dependencies
- Intention-approval workflow integration
- Worktree isolation per DAGENT_SPEC 8.3
- Ready for Plan 05-04 (merge agent)
</output>
