---
phase: 05-agent-system
plan: 04
type: execute
---

<objective>
Implement merge agent that integrates completed task branches into the feature branch.

Purpose: Create agent that handles branch merging with conflict detection and resolution coordination.
Output: Merge agent module with conflict detection, harness coordination, and cleanup operations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./05-04-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-agent-system/05-01-SUMMARY.md (agent pool)
@.planning/phases/05-agent-system/05-02-SUMMARY.md (harness agent)
@.planning/phases/05-agent-system/05-03-SUMMARY.md (task agent)
@.planning/phases/04-git-integration/04-03-SUMMARY.md (merge operations)
@DAGENT_SPEC.md (section 7.5 merge agent communication, section 8.4 merge flow)

**Tech stack available:** Electron, TypeScript, AgentPool, HarnessAgent, GitManager
**Established patterns:** Event emitters, singleton managers, IPC handlers

**Merge agent from DAGENT_SPEC:**
- Priority over new tasks (harness > merge > task)
- Handles branch merging with conflict resolution
- Follows same intention-approval workflow as task agents
- On success: delete task worktree and branch
- On failure: keep worktree for debugging

**Merge flow (section 8.4):**
1. Task agent completes work
2. Task status → 'merging'
3. Merge agent spawned (priority allocation)
4. Merge with harness guidance
5. On success: completed, cleanup
6. On failure: failed, keep worktree
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create merge agent types</name>
  <files>src/main/agents/merge-types.ts</files>
  <action>
Create merge-types.ts with types for merge agent state:
```typescript
import type { MergeConflict, TaskMergeResult } from '../git/types';
import type { IntentionDecision } from './harness-types';

export type MergeAgentStatus =
  | 'initializing'
  | 'checking_branches'
  | 'proposing_intention'
  | 'awaiting_approval'
  | 'merging'
  | 'resolving_conflicts'
  | 'cleaning_up'
  | 'completed'
  | 'failed';

export interface MergeAgentState {
  status: MergeAgentStatus;
  agentId: string | null;
  featureId: string;
  taskId: string;
  featureWorktreePath: string | null;
  taskWorktreePath: string | null;
  featureBranch: string | null;
  taskBranch: string | null;
  conflicts: MergeConflict[];
  intention: string | null;
  approval: IntentionDecision | null;
  mergeResult: TaskMergeResult | null;
  error: string | null;
  startedAt: string | null;
  completedAt: string | null;
}

export interface MergeContext {
  featureId: string;
  taskId: string;
  taskTitle: string;
  featureBranch: string;
  taskBranch: string;
  hasConflicts: boolean;
  conflicts: MergeConflict[];
}

export interface ConflictResolution {
  file: string;
  resolution: 'ours' | 'theirs' | 'both' | 'manual';
  content?: string;  // For manual resolution
}

export interface MergeIntention {
  type: 'clean_merge' | 'conflict_merge';
  taskId: string;
  taskBranch: string;
  featureBranch: string;
  conflicts?: MergeConflict[];
  proposedResolutions?: ConflictResolution[];
}

export const DEFAULT_MERGE_AGENT_STATE: Omit<MergeAgentState, 'featureId' | 'taskId'> = {
  status: 'initializing',
  agentId: null,
  featureWorktreePath: null,
  taskWorktreePath: null,
  featureBranch: null,
  taskBranch: null,
  conflicts: [],
  intention: null,
  approval: null,
  mergeResult: null,
  error: null,
  startedAt: null,
  completedAt: null,
};
```

Update src/main/agents/index.ts:
```typescript
export * from './types';
export * from './agent-pool';
export * from './harness-types';
export * from './harness-agent';
export * from './task-types';
export * from './task-agent';
export * from './merge-types';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Merge agent types defined: MergeAgentState, MergeContext, ConflictResolution</done>
</task>

<task type="auto">
  <name>Task 2: Implement MergeAgent class</name>
  <files>src/main/agents/merge-agent.ts</files>
  <action>
Create merge-agent.ts with the MergeAgent class:
```typescript
import { EventEmitter } from 'events';
import type { MergeConflict, TaskMergeResult } from '../git/types';
import type {
  MergeAgentState,
  MergeAgentStatus,
  MergeContext,
  MergeIntention,
  DEFAULT_MERGE_AGENT_STATE,
} from './merge-types';
import type { IntentionDecision } from './harness-types';
import { getAgentPool } from './agent-pool';
import { getHarnessAgent } from './harness-agent';
import { getGitManager, getFeatureBranchName, getTaskBranchName, getFeatureWorktreeName, getTaskWorktreeName } from '../git';
import * as path from 'path';

export class MergeAgent extends EventEmitter {
  private state: MergeAgentState;

  constructor(featureId: string, taskId: string) {
    super();
    this.state = {
      ...DEFAULT_MERGE_AGENT_STATE,
      featureId,
      taskId,
    };
  }

  /**
   * Initialize merge agent for a task.
   */
  async initialize(taskTitle: string): Promise<boolean> {
    if (this.state.status !== 'initializing') {
      return false;
    }

    this.state.startedAt = new Date().toISOString();

    // Register with agent pool (merge has priority)
    const pool = getAgentPool();
    if (!pool.canSpawn('merge')) {
      this.state.status = 'failed';
      this.state.error = 'Cannot spawn merge agent - pool limit reached';
      return false;
    }

    const agentInfo = pool.registerAgent({
      type: 'merge',
      featureId: this.state.featureId,
      taskId: this.state.taskId,
    });

    this.state.agentId = agentInfo.id;
    pool.updateAgentStatus(agentInfo.id, 'busy', this.state.taskId);

    // Set up branch names
    this.state.featureBranch = getFeatureBranchName(this.state.featureId);
    this.state.taskBranch = getTaskBranchName(this.state.featureId, this.state.taskId);

    // Set up worktree paths
    const gitManager = getGitManager();
    const config = gitManager.getConfig();
    this.state.featureWorktreePath = path.join(
      config.worktreesDir,
      getFeatureWorktreeName(this.state.featureId)
    );
    this.state.taskWorktreePath = path.join(
      config.worktreesDir,
      getTaskWorktreeName(this.state.featureId, this.state.taskId)
    );

    // Notify harness about merge starting
    const harness = getHarnessAgent();
    harness.markTaskMerging(this.state.taskId);

    this.emit('merge-agent:initialized', this.getState());
    return true;
  }

  /**
   * Check branches and detect potential conflicts.
   */
  async checkBranches(): Promise<boolean> {
    this.state.status = 'checking_branches';

    try {
      const gitManager = getGitManager();

      // Verify worktrees exist
      const featureWorktree = await gitManager.getWorktree(this.state.featureWorktreePath!);
      const taskWorktree = await gitManager.getWorktree(this.state.taskWorktreePath!);

      if (!featureWorktree) {
        this.state.error = 'Feature worktree not found';
        this.state.status = 'failed';
        return false;
      }

      if (!taskWorktree) {
        this.state.error = 'Task worktree not found';
        this.state.status = 'failed';
        return false;
      }

      // Get diff summary to understand changes
      const diffSummary = await gitManager.getDiffSummary(
        this.state.featureBranch!,
        this.state.taskBranch!
      );

      this.emit('merge-agent:branches-checked', {
        filesChanged: diffSummary.files,
        insertions: diffSummary.insertions,
        deletions: diffSummary.deletions,
      });

      return true;
    } catch (error) {
      this.state.error = (error as Error).message;
      this.state.status = 'failed';
      return false;
    }
  }

  /**
   * Propose merge intention to harness.
   */
  async proposeIntention(): Promise<boolean> {
    this.state.status = 'proposing_intention';

    // Build intention based on conflict status
    const hasConflicts = this.state.conflicts.length > 0;
    let intentionText: string;

    if (hasConflicts) {
      intentionText = `INTENTION: Merge task branch with conflict resolution\n` +
        `Task: ${this.state.taskId}\n` +
        `Branch: ${this.state.taskBranch} → ${this.state.featureBranch}\n` +
        `Conflicts detected in ${this.state.conflicts.length} files:\n` +
        this.state.conflicts.map(c => `  - ${c.file} (${c.type})`).join('\n') +
        `\nWill resolve conflicts with harness guidance.`;
    } else {
      intentionText = `INTENTION: Clean merge of task branch\n` +
        `Task: ${this.state.taskId}\n` +
        `Branch: ${this.state.taskBranch} → ${this.state.featureBranch}\n` +
        `No conflicts detected. Proceeding with merge.`;
    }

    this.state.intention = intentionText;

    // Send to harness
    const harness = getHarnessAgent();
    harness.receiveIntention(
      this.state.agentId!,
      this.state.taskId,
      intentionText
    );

    this.state.status = 'awaiting_approval';
    this.emit('merge-agent:intention-proposed', intentionText);

    return true;
  }

  /**
   * Receive approval decision from harness.
   */
  receiveApproval(decision: IntentionDecision): void {
    if (this.state.status !== 'awaiting_approval') {
      return;
    }

    this.state.approval = decision;

    if (decision.approved) {
      this.emit('merge-agent:approved', decision);
    } else {
      this.state.status = 'failed';
      this.state.error = decision.reason || 'Merge intention rejected';
      this.emit('merge-agent:rejected', decision);
    }
  }

  /**
   * Execute the merge operation.
   */
  async executeMerge(): Promise<TaskMergeResult> {
    if (!this.state.approval?.approved) {
      return {
        success: false,
        merged: false,
        worktreeRemoved: false,
        branchDeleted: false,
        error: 'Merge not approved',
      };
    }

    this.state.status = 'merging';
    this.emit('merge-agent:merging');

    try {
      const gitManager = getGitManager();

      // Perform the merge using GitManager
      const result = await gitManager.mergeTaskIntoFeature(
        this.state.featureId,
        this.state.taskId,
        true // Remove worktree on success
      );

      this.state.mergeResult = result;

      if (result.success && result.merged) {
        this.state.status = 'completed';
        this.state.completedAt = new Date().toISOString();

        // Notify harness of completion
        const harness = getHarnessAgent();
        harness.completeTask(this.state.taskId);

        this.emit('merge-agent:completed', result);
      } else if (result.conflicts && result.conflicts.length > 0) {
        // Conflicts detected during merge
        this.state.status = 'resolving_conflicts';
        this.state.conflicts = result.conflicts;
        this.emit('merge-agent:conflicts', result.conflicts);
      } else {
        this.state.status = 'failed';
        this.state.error = result.error || 'Merge failed';

        // Notify harness of failure
        const harness = getHarnessAgent();
        harness.failTask(this.state.taskId, this.state.error);

        this.emit('merge-agent:failed', result);
      }

      return result;
    } catch (error) {
      const errorMsg = (error as Error).message;
      this.state.status = 'failed';
      this.state.error = errorMsg;

      // Notify harness of failure
      const harness = getHarnessAgent();
      harness.failTask(this.state.taskId, errorMsg);

      const result: TaskMergeResult = {
        success: false,
        merged: false,
        worktreeRemoved: false,
        branchDeleted: false,
        error: errorMsg,
      };

      this.emit('merge-agent:failed', result);
      return result;
    }
  }

  /**
   * Abort the merge operation.
   */
  async abortMerge(): Promise<boolean> {
    try {
      const gitManager = getGitManager();
      const result = await gitManager.abortMerge();
      return result.success;
    } catch {
      return false;
    }
  }

  /**
   * Get current merge agent state.
   */
  getState(): MergeAgentState {
    return { ...this.state };
  }

  /**
   * Get merge agent status.
   */
  getStatus(): MergeAgentStatus {
    return this.state.status;
  }

  /**
   * Clean up merge agent resources.
   */
  async cleanup(): Promise<void> {
    // Release from pool
    if (this.state.agentId) {
      const pool = getAgentPool();
      pool.terminateAgent(this.state.agentId);
    }

    this.emit('merge-agent:cleanup');
  }
}

// Factory for creating merge agents
export function createMergeAgent(featureId: string, taskId: string): MergeAgent {
  return new MergeAgent(featureId, taskId);
}

// Active merge agents registry
const activeMergeAgents: Map<string, MergeAgent> = new Map();

export function registerMergeAgent(agent: MergeAgent): void {
  activeMergeAgents.set(agent.getState().taskId, agent);
}

export function getMergeAgent(taskId: string): MergeAgent | undefined {
  return activeMergeAgents.get(taskId);
}

export function removeMergeAgent(taskId: string): boolean {
  return activeMergeAgents.delete(taskId);
}

export function getAllMergeAgents(): MergeAgent[] {
  return Array.from(activeMergeAgents.values());
}

export function clearMergeAgents(): void {
  for (const agent of activeMergeAgents.values()) {
    agent.cleanup();
  }
  activeMergeAgents.clear();
}
```

Update src/main/agents/index.ts:
```typescript
export * from './types';
export * from './agent-pool';
export * from './harness-types';
export * from './harness-agent';
export * from './task-types';
export * from './task-agent';
export * from './merge-types';
export * from './merge-agent';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>MergeAgent class with branch checking, intention proposal, merge execution, and conflict handling</done>
</task>

<task type="auto">
  <name>Task 3: Add merge agent IPC handlers and update state</name>
  <files>src/main/ipc/merge-agent-handlers.ts, src/main/ipc/handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Create src/main/ipc/merge-agent-handlers.ts:
```typescript
import { ipcMain } from 'electron';
import {
  createMergeAgent,
  registerMergeAgent,
  getMergeAgent,
  removeMergeAgent,
  getAllMergeAgents,
  clearMergeAgents,
} from '../agents';
import type { IntentionDecision } from '../agents/harness-types';

export function registerMergeAgentHandlers(): void {
  ipcMain.handle('merge-agent:create', async (
    _event,
    featureId: string,
    taskId: string,
    taskTitle: string
  ) => {
    const agent = createMergeAgent(featureId, taskId);
    const initialized = await agent.initialize(taskTitle);

    if (initialized) {
      registerMergeAgent(agent);
      await agent.checkBranches();
    }

    return {
      success: initialized,
      state: agent.getState(),
    };
  });

  ipcMain.handle('merge-agent:get-state', async (_event, taskId: string) => {
    const agent = getMergeAgent(taskId);
    return agent?.getState() || null;
  });

  ipcMain.handle('merge-agent:get-status', async (_event, taskId: string) => {
    const agent = getMergeAgent(taskId);
    return agent?.getStatus() || null;
  });

  ipcMain.handle('merge-agent:get-all', async () => {
    return getAllMergeAgents().map(a => a.getState());
  });

  ipcMain.handle('merge-agent:propose-intention', async (_event, taskId: string) => {
    const agent = getMergeAgent(taskId);
    if (!agent) return false;
    return agent.proposeIntention();
  });

  ipcMain.handle('merge-agent:receive-approval', async (
    _event,
    taskId: string,
    decision: IntentionDecision
  ) => {
    const agent = getMergeAgent(taskId);
    if (!agent) return false;
    agent.receiveApproval(decision);
    return true;
  });

  ipcMain.handle('merge-agent:execute', async (_event, taskId: string) => {
    const agent = getMergeAgent(taskId);
    if (!agent) {
      return {
        success: false,
        merged: false,
        worktreeRemoved: false,
        branchDeleted: false,
        error: 'Merge agent not found',
      };
    }
    return agent.executeMerge();
  });

  ipcMain.handle('merge-agent:abort', async (_event, taskId: string) => {
    const agent = getMergeAgent(taskId);
    if (!agent) return false;
    return agent.abortMerge();
  });

  ipcMain.handle('merge-agent:cleanup', async (_event, taskId: string) => {
    const agent = getMergeAgent(taskId);
    if (!agent) return false;
    await agent.cleanup();
    removeMergeAgent(taskId);
    return true;
  });

  ipcMain.handle('merge-agent:clear-all', async () => {
    clearMergeAgents();
    return true;
  });
}
```

Update src/main/ipc/handlers.ts:
```typescript
import { registerMergeAgentHandlers } from './merge-agent-handlers';

export function registerAllHandlers(): void {
  // ... existing handlers
  registerMergeAgentHandlers();
}
```

Update src/preload/index.ts:
```typescript
const mergeAgentAPI = {
  create: (featureId: string, taskId: string, taskTitle: string) =>
    ipcRenderer.invoke('merge-agent:create', featureId, taskId, taskTitle),
  getState: (taskId: string) => ipcRenderer.invoke('merge-agent:get-state', taskId),
  getStatus: (taskId: string) => ipcRenderer.invoke('merge-agent:get-status', taskId),
  getAll: () => ipcRenderer.invoke('merge-agent:get-all'),
  proposeIntention: (taskId: string) =>
    ipcRenderer.invoke('merge-agent:propose-intention', taskId),
  receiveApproval: (taskId: string, decision: IntentionDecision) =>
    ipcRenderer.invoke('merge-agent:receive-approval', taskId, decision),
  execute: (taskId: string) => ipcRenderer.invoke('merge-agent:execute', taskId),
  abort: (taskId: string) => ipcRenderer.invoke('merge-agent:abort', taskId),
  cleanup: (taskId: string) => ipcRenderer.invoke('merge-agent:cleanup', taskId),
  clearAll: () => ipcRenderer.invoke('merge-agent:clear-all'),
};

// Add to contextBridge
contextBridge.exposeInMainWorld('electronAPI', {
  // ... existing
  mergeAgent: mergeAgentAPI,
});
```

Update src/preload/index.d.ts:
```typescript
type MergeAgentStatus =
  | 'initializing'
  | 'checking_branches'
  | 'proposing_intention'
  | 'awaiting_approval'
  | 'merging'
  | 'resolving_conflicts'
  | 'cleaning_up'
  | 'completed'
  | 'failed';

interface MergeAgentState {
  status: MergeAgentStatus;
  agentId: string | null;
  featureId: string;
  taskId: string;
  featureWorktreePath: string | null;
  taskWorktreePath: string | null;
  featureBranch: string | null;
  taskBranch: string | null;
  conflicts: MergeConflict[];
  intention: string | null;
  approval: IntentionDecision | null;
  mergeResult: TaskMergeResult | null;
  error: string | null;
  startedAt: string | null;
  completedAt: string | null;
}

interface MergeAgentCreateResult {
  success: boolean;
  state: MergeAgentState;
}

interface MergeAgentAPI {
  create: (featureId: string, taskId: string, taskTitle: string) => Promise<MergeAgentCreateResult>;
  getState: (taskId: string) => Promise<MergeAgentState | null>;
  getStatus: (taskId: string) => Promise<MergeAgentStatus | null>;
  getAll: () => Promise<MergeAgentState[]>;
  proposeIntention: (taskId: string) => Promise<boolean>;
  receiveApproval: (taskId: string, decision: IntentionDecision) => Promise<boolean>;
  execute: (taskId: string) => Promise<TaskMergeResult>;
  abort: (taskId: string) => Promise<boolean>;
  cleanup: (taskId: string) => Promise<boolean>;
  clearAll: () => Promise<boolean>;
}

interface ElectronAPI {
  // ... existing
  mergeAgent: MergeAgentAPI;
}
```

Also update STATE.md and ROADMAP.md:
- STATE.md: Phase 5 complete, ready for Phase 6
- ROADMAP.md: Mark Phase 5 complete with date
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>Merge agent IPC handlers complete, Phase 5 Agent System complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] MergeAgent class with full lifecycle
- [ ] Branch checking and diff summary
- [ ] Merge execution via GitManager.mergeTaskIntoFeature()
- [ ] Conflict detection and handling
- [ ] Harness integration for approval workflow
- [ ] IPC handlers expose all merge operations
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Phase 5: Agent System complete
- Ready for Phase 6 (UI Views) which will use agent APIs for execution control
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-system/05-04-SUMMARY.md` with:
- MergeAgent class structure
- Branch checking and merge execution
- Conflict handling per DAGENT_SPEC 8.4
- Phase 5 complete, ready for Phase 6 (UI Views)

Also update:
- STATE.md: Phase 5 complete, ready for Phase 6
- ROADMAP.md: Mark Phase 5 complete with date
</output>
