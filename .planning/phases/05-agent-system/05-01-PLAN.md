---
phase: 05-agent-system
plan: 01
type: execute
---

<objective>
Set up agent pool infrastructure and process management for AI agent coordination.

Purpose: Establish the foundation for spawning and managing harness, task, and merge agents.
Output: Agent pool module in src/main/agents/ with process spawning and lifecycle management.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./05-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dag-engine/03-03-SUMMARY.md (execution orchestrator integration)
@.planning/phases/04-git-integration/04-03-SUMMARY.md (git operations for merge agents)
@DAGENT_SPEC.md (section 6.1 for agent pool, section 7 for communication)

**Tech stack available:** Electron, React, TypeScript, simple-git, Node.js child_process
**Established patterns:** Singleton managers (GitManager, ExecutionOrchestrator), IPC handlers, contextBridge preload
**Integration points:** ExecutionOrchestrator for task assignment, GitManager for worktree operations

**Agent pool from DAGENT_SPEC 6.1:**
- Total pool size configurable (based on Claude plan limits)
- 1 agent always reserved for harness
- Remaining agents available for tasks/merges
- Priority: harness > merge > task

**Agent types:**
- Harness: Orchestrator, sees everything, codes nothing
- Task: Implements specific task in isolation
- Merge: Handles branch merging with conflict resolution
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent types and pool configuration</name>
  <files>src/main/agents/types.ts, src/main/agents/index.ts</files>
  <action>
Create src/main/agents/ directory and types.ts with:
```typescript
import type { ChildProcess } from 'child_process';

export type AgentType = 'harness' | 'task' | 'merge';

export type AgentStatus = 'idle' | 'busy' | 'terminated';

export interface AgentInfo {
  id: string;
  type: AgentType;
  status: AgentStatus;
  taskId?: string;       // For task/merge agents, which task they're handling
  featureId?: string;    // Which feature this agent is working on
  process?: ChildProcess;
  startedAt?: string;    // ISO timestamp
}

export interface AgentPoolConfig {
  maxAgents: number;     // Total pool size (default: 4)
  maxTaskAgents: number; // Max concurrent task agents (default: 2)
  maxMergeAgents: number; // Max concurrent merge agents (default: 1)
  // Note: 1 agent always reserved for harness
}

export interface AgentSpawnOptions {
  type: AgentType;
  featureId: string;
  taskId?: string;       // Required for task/merge agents
  context?: AgentContext;
}

export interface AgentContext {
  claudeMd?: string;     // CLAUDE.md content
  taskDescription?: string;
  dependencyContext?: string[];  // Context from completed dependencies
  featureGoal?: string;
  additionalInstructions?: string;
}

export interface AgentMessage {
  type: 'intention' | 'approval' | 'rejection' | 'modification' | 'action' | 'error' | 'complete';
  agentId: string;
  taskId?: string;
  content: string;
  timestamp: string;
}

export interface IntentionMessage {
  agentId: string;
  taskId: string;
  intention: string;      // What the agent intends to do
  files?: string[];       // Files it plans to modify
}

export interface ApprovalMessage {
  agentId: string;
  taskId: string;
  approved: boolean;
  notes?: string;         // Guidance for the task agent
  modifications?: string; // If approach should change
}

export const DEFAULT_POOL_CONFIG: AgentPoolConfig = {
  maxAgents: 4,
  maxTaskAgents: 2,
  maxMergeAgents: 1,
};
```

Create index.ts:
```typescript
export * from './types';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Agent types defined: AgentInfo, AgentPoolConfig, AgentMessage, IntentionMessage, ApprovalMessage</done>
</task>

<task type="auto">
  <name>Task 2: Implement AgentPool class for process lifecycle</name>
  <files>src/main/agents/agent-pool.ts, src/main/agents/index.ts</files>
  <action>
Create agent-pool.ts with AgentPool class:
```typescript
import { spawn, ChildProcess } from 'child_process';
import { EventEmitter } from 'events';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import type {
  AgentInfo,
  AgentPoolConfig,
  AgentType,
  AgentSpawnOptions,
  AgentMessage,
  DEFAULT_POOL_CONFIG,
} from './types';

export class AgentPool extends EventEmitter {
  private agents: Map<string, AgentInfo> = new Map();
  private config: AgentPoolConfig;
  private harnessId: string | null = null;

  constructor(config: Partial<AgentPoolConfig> = {}) {
    super();
    this.config = { ...DEFAULT_POOL_CONFIG, ...config };
  }

  /**
   * Get current pool configuration.
   */
  getConfig(): AgentPoolConfig {
    return { ...this.config };
  }

  /**
   * Update pool configuration.
   */
  updateConfig(config: Partial<AgentPoolConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Get all agents in the pool.
   */
  getAgents(): AgentInfo[] {
    return Array.from(this.agents.values()).map(a => ({
      ...a,
      process: undefined, // Don't expose process in returned info
    }));
  }

  /**
   * Get agent by ID.
   */
  getAgent(id: string): AgentInfo | undefined {
    const agent = this.agents.get(id);
    if (!agent) return undefined;
    return { ...agent, process: undefined };
  }

  /**
   * Get agents by type.
   */
  getAgentsByType(type: AgentType): AgentInfo[] {
    return this.getAgents().filter(a => a.type === type);
  }

  /**
   * Get harness agent (if active).
   */
  getHarness(): AgentInfo | undefined {
    if (!this.harnessId) return undefined;
    return this.getAgent(this.harnessId);
  }

  /**
   * Check if we can spawn a new agent of given type.
   */
  canSpawn(type: AgentType): boolean {
    const activeAgents = this.getAgents().filter(a => a.status !== 'terminated');
    const totalActive = activeAgents.length;

    if (totalActive >= this.config.maxAgents) return false;

    if (type === 'harness') {
      // Only one harness allowed
      return !this.harnessId || this.agents.get(this.harnessId)?.status === 'terminated';
    }

    if (type === 'merge') {
      const activeMerge = activeAgents.filter(a => a.type === 'merge' && a.status === 'busy').length;
      return activeMerge < this.config.maxMergeAgents;
    }

    if (type === 'task') {
      const activeTasks = activeAgents.filter(a => a.type === 'task' && a.status === 'busy').length;
      return activeTasks < this.config.maxTaskAgents;
    }

    return false;
  }

  /**
   * Count available slots for a given agent type.
   */
  getAvailableSlots(type: AgentType): number {
    const activeAgents = this.getAgents().filter(a => a.status !== 'terminated');

    if (type === 'harness') return this.canSpawn('harness') ? 1 : 0;

    if (type === 'merge') {
      const activeMerge = activeAgents.filter(a => a.type === 'merge' && a.status === 'busy').length;
      return Math.max(0, this.config.maxMergeAgents - activeMerge);
    }

    if (type === 'task') {
      const activeTasks = activeAgents.filter(a => a.type === 'task' && a.status === 'busy').length;
      return Math.max(0, this.config.maxTaskAgents - activeTasks);
    }

    return 0;
  }

  /**
   * Register an agent in the pool (without spawning a process).
   * Used when agents are managed externally (e.g., via Claude API).
   */
  registerAgent(options: AgentSpawnOptions): AgentInfo {
    const id = uuidv4();
    const agent: AgentInfo = {
      id,
      type: options.type,
      status: 'idle',
      taskId: options.taskId,
      featureId: options.featureId,
      startedAt: new Date().toISOString(),
    };

    this.agents.set(id, agent);

    if (options.type === 'harness') {
      this.harnessId = id;
    }

    this.emit('agent:registered', agent);
    return { ...agent };
  }

  /**
   * Update agent status.
   */
  updateAgentStatus(id: string, status: AgentInfo['status'], taskId?: string): boolean {
    const agent = this.agents.get(id);
    if (!agent) return false;

    agent.status = status;
    if (taskId !== undefined) {
      agent.taskId = taskId;
    }

    this.emit('agent:status', { ...agent, process: undefined });
    return true;
  }

  /**
   * Terminate an agent.
   */
  terminateAgent(id: string): boolean {
    const agent = this.agents.get(id);
    if (!agent) return false;

    if (agent.process) {
      agent.process.kill();
    }

    agent.status = 'terminated';

    if (this.harnessId === id) {
      this.harnessId = null;
    }

    this.emit('agent:terminated', { ...agent, process: undefined });
    return true;
  }

  /**
   * Terminate all agents.
   */
  terminateAll(): void {
    for (const id of this.agents.keys()) {
      this.terminateAgent(id);
    }
    this.agents.clear();
    this.harnessId = null;
  }

  /**
   * Remove terminated agents from pool.
   */
  cleanup(): number {
    let removed = 0;
    for (const [id, agent] of this.agents.entries()) {
      if (agent.status === 'terminated') {
        this.agents.delete(id);
        removed++;
      }
    }
    return removed;
  }

  /**
   * Get pool status summary.
   */
  getStatus(): {
    total: number;
    active: number;
    idle: number;
    busy: number;
    terminated: number;
    hasHarness: boolean;
    taskAgents: number;
    mergeAgents: number;
  } {
    const agents = Array.from(this.agents.values());
    return {
      total: agents.length,
      active: agents.filter(a => a.status !== 'terminated').length,
      idle: agents.filter(a => a.status === 'idle').length,
      busy: agents.filter(a => a.status === 'busy').length,
      terminated: agents.filter(a => a.status === 'terminated').length,
      hasHarness: this.harnessId !== null && this.agents.get(this.harnessId!)?.status !== 'terminated',
      taskAgents: agents.filter(a => a.type === 'task' && a.status === 'busy').length,
      mergeAgents: agents.filter(a => a.type === 'merge' && a.status === 'busy').length,
    };
  }
}

// Singleton instance
let agentPoolInstance: AgentPool | null = null;

export function getAgentPool(): AgentPool {
  if (!agentPoolInstance) {
    agentPoolInstance = new AgentPool();
  }
  return agentPoolInstance;
}

export function resetAgentPool(): void {
  if (agentPoolInstance) {
    agentPoolInstance.terminateAll();
  }
  agentPoolInstance = null;
}
```

Also install uuid: `npm install uuid && npm install -D @types/uuid`

Update index.ts:
```typescript
export * from './types';
export * from './agent-pool';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>AgentPool class with registration, status tracking, slot management, and singleton pattern</done>
</task>

<task type="auto">
  <name>Task 3: Add agent IPC handlers and preload exposure</name>
  <files>src/main/ipc/agent-handlers.ts, src/main/ipc/handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Create src/main/ipc/agent-handlers.ts:
```typescript
import { ipcMain } from 'electron';
import { getAgentPool } from '../agents';
import type { AgentType, AgentSpawnOptions, AgentPoolConfig } from '../agents';

export function registerAgentHandlers(): void {
  ipcMain.handle('agent:get-config', async () => {
    const pool = getAgentPool();
    return pool.getConfig();
  });

  ipcMain.handle('agent:update-config', async (_event, config: Partial<AgentPoolConfig>) => {
    const pool = getAgentPool();
    pool.updateConfig(config);
    return pool.getConfig();
  });

  ipcMain.handle('agent:get-all', async () => {
    const pool = getAgentPool();
    return pool.getAgents();
  });

  ipcMain.handle('agent:get-by-id', async (_event, id: string) => {
    const pool = getAgentPool();
    return pool.getAgent(id);
  });

  ipcMain.handle('agent:get-by-type', async (_event, type: AgentType) => {
    const pool = getAgentPool();
    return pool.getAgentsByType(type);
  });

  ipcMain.handle('agent:get-harness', async () => {
    const pool = getAgentPool();
    return pool.getHarness();
  });

  ipcMain.handle('agent:can-spawn', async (_event, type: AgentType) => {
    const pool = getAgentPool();
    return pool.canSpawn(type);
  });

  ipcMain.handle('agent:get-available-slots', async (_event, type: AgentType) => {
    const pool = getAgentPool();
    return pool.getAvailableSlots(type);
  });

  ipcMain.handle('agent:register', async (_event, options: AgentSpawnOptions) => {
    const pool = getAgentPool();
    return pool.registerAgent(options);
  });

  ipcMain.handle('agent:update-status', async (
    _event,
    id: string,
    status: 'idle' | 'busy' | 'terminated',
    taskId?: string
  ) => {
    const pool = getAgentPool();
    return pool.updateAgentStatus(id, status, taskId);
  });

  ipcMain.handle('agent:terminate', async (_event, id: string) => {
    const pool = getAgentPool();
    return pool.terminateAgent(id);
  });

  ipcMain.handle('agent:terminate-all', async () => {
    const pool = getAgentPool();
    pool.terminateAll();
    return true;
  });

  ipcMain.handle('agent:cleanup', async () => {
    const pool = getAgentPool();
    return pool.cleanup();
  });

  ipcMain.handle('agent:get-status', async () => {
    const pool = getAgentPool();
    return pool.getStatus();
  });
}
```

Update src/main/ipc/handlers.ts to include agent handlers:
```typescript
import { registerAgentHandlers } from './agent-handlers';

export function registerAllHandlers(): void {
  // ... existing handlers
  registerAgentHandlers();
}
```

Update src/preload/index.ts to expose agent API:
```typescript
const agentAPI = {
  getConfig: () => ipcRenderer.invoke('agent:get-config'),
  updateConfig: (config: Partial<AgentPoolConfig>) =>
    ipcRenderer.invoke('agent:update-config', config),
  getAll: () => ipcRenderer.invoke('agent:get-all'),
  getById: (id: string) => ipcRenderer.invoke('agent:get-by-id', id),
  getByType: (type: AgentType) => ipcRenderer.invoke('agent:get-by-type', type),
  getHarness: () => ipcRenderer.invoke('agent:get-harness'),
  canSpawn: (type: AgentType) => ipcRenderer.invoke('agent:can-spawn', type),
  getAvailableSlots: (type: AgentType) => ipcRenderer.invoke('agent:get-available-slots', type),
  register: (options: AgentSpawnOptions) => ipcRenderer.invoke('agent:register', options),
  updateStatus: (id: string, status: 'idle' | 'busy' | 'terminated', taskId?: string) =>
    ipcRenderer.invoke('agent:update-status', id, status, taskId),
  terminate: (id: string) => ipcRenderer.invoke('agent:terminate', id),
  terminateAll: () => ipcRenderer.invoke('agent:terminate-all'),
  cleanup: () => ipcRenderer.invoke('agent:cleanup'),
  getStatus: () => ipcRenderer.invoke('agent:get-status'),
};

// Add to contextBridge exposure
contextBridge.exposeInMainWorld('electronAPI', {
  // ... existing APIs
  agent: agentAPI,
});
```

Update src/preload/index.d.ts with agent types:
```typescript
type AgentType = 'harness' | 'task' | 'merge';
type AgentStatus = 'idle' | 'busy' | 'terminated';

interface AgentInfo {
  id: string;
  type: AgentType;
  status: AgentStatus;
  taskId?: string;
  featureId?: string;
  startedAt?: string;
}

interface AgentPoolConfig {
  maxAgents: number;
  maxTaskAgents: number;
  maxMergeAgents: number;
}

interface AgentSpawnOptions {
  type: AgentType;
  featureId: string;
  taskId?: string;
  context?: AgentContext;
}

interface AgentContext {
  claudeMd?: string;
  taskDescription?: string;
  dependencyContext?: string[];
  featureGoal?: string;
  additionalInstructions?: string;
}

interface AgentPoolStatus {
  total: number;
  active: number;
  idle: number;
  busy: number;
  terminated: number;
  hasHarness: boolean;
  taskAgents: number;
  mergeAgents: number;
}

interface AgentAPI {
  getConfig: () => Promise<AgentPoolConfig>;
  updateConfig: (config: Partial<AgentPoolConfig>) => Promise<AgentPoolConfig>;
  getAll: () => Promise<AgentInfo[]>;
  getById: (id: string) => Promise<AgentInfo | undefined>;
  getByType: (type: AgentType) => Promise<AgentInfo[]>;
  getHarness: () => Promise<AgentInfo | undefined>;
  canSpawn: (type: AgentType) => Promise<boolean>;
  getAvailableSlots: (type: AgentType) => Promise<number>;
  register: (options: AgentSpawnOptions) => Promise<AgentInfo>;
  updateStatus: (id: string, status: AgentStatus, taskId?: string) => Promise<boolean>;
  terminate: (id: string) => Promise<boolean>;
  terminateAll: () => Promise<boolean>;
  cleanup: () => Promise<number>;
  getStatus: () => Promise<AgentPoolStatus>;
}

interface ElectronAPI {
  // ... existing
  agent: AgentAPI;
}
```
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>Agent IPC handlers expose pool management to renderer process</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] uuid package installed
- [ ] Agent types defined (AgentInfo, AgentPoolConfig, AgentMessage)
- [ ] AgentPool class with registration and status management
- [ ] Singleton pattern with getAgentPool()/resetAgentPool()
- [ ] IPC handlers expose agent operations
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Agent pool foundation ready for harness implementation (Plan 05-02)
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-system/05-01-SUMMARY.md` with:
- Agent types (AgentInfo, AgentPoolConfig, AgentMessage)
- AgentPool class structure
- IPC integration pattern
- Ready for Plan 05-02 (harness agent)
</output>
