---
phase: 05-agent-system
plan: 02
type: execute
---

<objective>
Implement harness agent that orchestrates all other agents during feature execution.

Purpose: Create the central coordinator that approves/rejects task intentions and maintains global context.
Output: Harness agent module with intention-approval workflow and execution coordination.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./05-02-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-agent-system/05-01-SUMMARY.md
@.planning/phases/03-dag-engine/03-03-SUMMARY.md (execution orchestrator)
@DAGENT_SPEC.md (section 6.3 execution flow, section 7 agent communication)

**Tech stack available:** Electron, TypeScript, AgentPool, ExecutionOrchestrator
**Established patterns:** Singleton managers, event emitters, IPC handlers

**Harness agent from DAGENT_SPEC:**
- Always reserved (1 agent)
- Sees everything, codes nothing
- Has context: CLAUDE.md, feature goal, all task descriptions, all task logs, current state
- Receives intentions from task agents
- Responds with: APPROVED, APPROVED WITH NOTES, MODIFIED, REJECTED

**Communication model (section 7.1-7.4):**
- Task agents propose intentions to harness
- Harness reviews against project context and other tasks
- Harness provides guidance in approval messages
- No direct task-to-task communication
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create harness agent types and state</name>
  <files>src/main/agents/harness-types.ts</files>
  <action>
Create harness-types.ts with types for harness state and messages:
```typescript
import type { Task, DAGGraph } from '@shared/types';
import type { AgentMessage, IntentionMessage, ApprovalMessage } from './types';

export type HarnessStatus = 'idle' | 'active' | 'paused' | 'stopped';

export interface HarnessState {
  status: HarnessStatus;
  featureId: string | null;
  featureGoal: string | null;
  claudeMd: string | null;
  graph: DAGGraph | null;
  activeTasks: Map<string, TaskExecutionState>;
  pendingIntentions: Map<string, PendingIntention>;
  messageHistory: HarnessMessage[];
  startedAt: string | null;
  stoppedAt: string | null;
}

export interface TaskExecutionState {
  taskId: string;
  agentId: string;
  status: 'assigned' | 'intention_pending' | 'approved' | 'working' | 'merging';
  intention?: string;
  approvalNotes?: string;
  startedAt: string;
}

export interface PendingIntention {
  agentId: string;
  taskId: string;
  intention: string;
  files?: string[];
  receivedAt: string;
}

export interface HarnessMessage {
  type: 'intention_received' | 'approval_sent' | 'rejection_sent' | 'task_started' | 'task_completed' | 'task_failed' | 'info' | 'warning' | 'error';
  taskId?: string;
  agentId?: string;
  content: string;
  timestamp: string;
}

export interface IntentionReviewContext {
  intention: PendingIntention;
  task: Task;
  graph: DAGGraph;
  claudeMd: string | null;
  featureGoal: string | null;
  otherActiveTasks: TaskExecutionState[];
  completedTasks: Task[];
}

export interface IntentionDecision {
  approved: boolean;
  type: 'approved' | 'approved_with_notes' | 'modified' | 'rejected';
  notes?: string;
  modifications?: string;
  reason?: string;
}

export const DEFAULT_HARNESS_STATE: Omit<HarnessState, 'activeTasks' | 'pendingIntentions' | 'messageHistory'> = {
  status: 'idle',
  featureId: null,
  featureGoal: null,
  claudeMd: null,
  graph: null,
  startedAt: null,
  stoppedAt: null,
};
```

Update src/main/agents/index.ts to export harness types:
```typescript
export * from './types';
export * from './agent-pool';
export * from './harness-types';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Harness types defined: HarnessState, TaskExecutionState, PendingIntention, IntentionDecision</done>
</task>

<task type="auto">
  <name>Task 2: Implement HarnessAgent class</name>
  <files>src/main/agents/harness-agent.ts</files>
  <action>
Create harness-agent.ts with the HarnessAgent class:
```typescript
import { EventEmitter } from 'events';
import type { Task, DAGGraph } from '@shared/types';
import type { AgentInfo } from './types';
import type {
  HarnessState,
  HarnessStatus,
  TaskExecutionState,
  PendingIntention,
  HarnessMessage,
  IntentionDecision,
  IntentionReviewContext,
  DEFAULT_HARNESS_STATE,
} from './harness-types';
import { getAgentPool } from './agent-pool';
import { getOrchestrator } from '../dag-engine';

export class HarnessAgent extends EventEmitter {
  private state: HarnessState;
  private agentInfo: AgentInfo | null = null;

  constructor() {
    super();
    this.state = {
      ...DEFAULT_HARNESS_STATE,
      activeTasks: new Map(),
      pendingIntentions: new Map(),
      messageHistory: [],
    };
  }

  /**
   * Initialize harness for a feature execution.
   */
  async initialize(
    featureId: string,
    featureGoal: string,
    graph: DAGGraph,
    claudeMd?: string
  ): Promise<boolean> {
    if (this.state.status !== 'idle') {
      this.log('warning', 'Cannot initialize - harness not idle');
      return false;
    }

    // Register harness agent in pool
    const pool = getAgentPool();
    if (!pool.canSpawn('harness')) {
      this.log('error', 'Cannot spawn harness - pool limit reached');
      return false;
    }

    this.agentInfo = pool.registerAgent({
      type: 'harness',
      featureId,
    });

    this.state = {
      status: 'idle',
      featureId,
      featureGoal,
      claudeMd: claudeMd || null,
      graph,
      activeTasks: new Map(),
      pendingIntentions: new Map(),
      messageHistory: [],
      startedAt: null,
      stoppedAt: null,
    };

    this.log('info', `Harness initialized for feature: ${featureId}`);
    return true;
  }

  /**
   * Start execution - harness becomes active.
   */
  start(): boolean {
    if (this.state.status !== 'idle') {
      this.log('warning', `Cannot start - status is ${this.state.status}`);
      return false;
    }

    this.state.status = 'active';
    this.state.startedAt = new Date().toISOString();

    if (this.agentInfo) {
      getAgentPool().updateAgentStatus(this.agentInfo.id, 'busy');
    }

    this.log('info', 'Harness execution started');
    this.emit('harness:started');
    return true;
  }

  /**
   * Pause execution.
   */
  pause(): boolean {
    if (this.state.status !== 'active') {
      return false;
    }

    this.state.status = 'paused';
    this.log('info', 'Harness execution paused');
    this.emit('harness:paused');
    return true;
  }

  /**
   * Resume execution.
   */
  resume(): boolean {
    if (this.state.status !== 'paused') {
      return false;
    }

    this.state.status = 'active';
    this.log('info', 'Harness execution resumed');
    this.emit('harness:resumed');
    return true;
  }

  /**
   * Stop execution.
   */
  stop(): boolean {
    if (this.state.status === 'idle' || this.state.status === 'stopped') {
      return false;
    }

    this.state.status = 'stopped';
    this.state.stoppedAt = new Date().toISOString();

    if (this.agentInfo) {
      getAgentPool().updateAgentStatus(this.agentInfo.id, 'idle');
    }

    this.log('info', 'Harness execution stopped');
    this.emit('harness:stopped');
    return true;
  }

  /**
   * Get current harness state.
   */
  getState(): Omit<HarnessState, 'activeTasks' | 'pendingIntentions'> & {
    activeTasks: TaskExecutionState[];
    pendingIntentions: PendingIntention[];
  } {
    return {
      ...this.state,
      activeTasks: Array.from(this.state.activeTasks.values()),
      pendingIntentions: Array.from(this.state.pendingIntentions.values()),
    };
  }

  /**
   * Get harness status.
   */
  getStatus(): HarnessStatus {
    return this.state.status;
  }

  /**
   * Register a task agent assignment.
   */
  registerTaskAssignment(taskId: string, agentId: string): void {
    const taskState: TaskExecutionState = {
      taskId,
      agentId,
      status: 'assigned',
      startedAt: new Date().toISOString(),
    };

    this.state.activeTasks.set(taskId, taskState);
    this.log('task_started', `Task ${taskId} assigned to agent ${agentId}`, taskId, agentId);
    this.emit('task:assigned', taskState);
  }

  /**
   * Receive an intention from a task agent.
   */
  receiveIntention(
    agentId: string,
    taskId: string,
    intention: string,
    files?: string[]
  ): void {
    const pending: PendingIntention = {
      agentId,
      taskId,
      intention,
      files,
      receivedAt: new Date().toISOString(),
    };

    this.state.pendingIntentions.set(taskId, pending);

    // Update task execution state
    const taskState = this.state.activeTasks.get(taskId);
    if (taskState) {
      taskState.status = 'intention_pending';
      taskState.intention = intention;
    }

    this.log('intention_received', intention, taskId, agentId);
    this.emit('intention:received', pending);
  }

  /**
   * Process and decide on a pending intention.
   * Returns the decision for the task agent.
   */
  processIntention(taskId: string): IntentionDecision | null {
    const pending = this.state.pendingIntentions.get(taskId);
    if (!pending) {
      return null;
    }

    // Find the task in the graph
    const task = this.state.graph?.nodes.find(n => n.id === taskId);
    if (!task) {
      return {
        approved: false,
        type: 'rejected',
        reason: 'Task not found in graph',
      };
    }

    // Build review context
    const context: IntentionReviewContext = {
      intention: pending,
      task,
      graph: this.state.graph!,
      claudeMd: this.state.claudeMd,
      featureGoal: this.state.featureGoal,
      otherActiveTasks: Array.from(this.state.activeTasks.values()).filter(t => t.taskId !== taskId),
      completedTasks: this.state.graph!.nodes.filter(n => n.status === 'completed'),
    };

    // In a full implementation, this would call Claude API for intelligent review
    // For now, auto-approve with context notes
    const decision = this.reviewIntention(context);

    // Apply decision
    this.applyDecision(taskId, decision);

    return decision;
  }

  /**
   * Review an intention (stub for Claude API integration).
   * This will be enhanced in Plan 05-03 with actual AI review.
   */
  private reviewIntention(context: IntentionReviewContext): IntentionDecision {
    // Auto-approve for now with context-based notes
    const notes: string[] = [];

    // Check for completed dependencies that might provide context
    const taskDeps = this.state.graph?.connections
      .filter(c => c.to === context.task.id)
      .map(c => c.from) || [];

    const completedDeps = context.completedTasks.filter(t => taskDeps.includes(t.id));

    if (completedDeps.length > 0) {
      notes.push(`Context from completed tasks: ${completedDeps.map(t => t.title).join(', ')}`);
    }

    // Check for other active tasks that might conflict
    if (context.otherActiveTasks.length > 0) {
      notes.push(`Other active tasks: ${context.otherActiveTasks.length}. Avoid conflicts.`);
    }

    return {
      approved: true,
      type: notes.length > 0 ? 'approved_with_notes' : 'approved',
      notes: notes.length > 0 ? notes.join('\n') : undefined,
    };
  }

  /**
   * Apply a decision to a pending intention.
   */
  private applyDecision(taskId: string, decision: IntentionDecision): void {
    const pending = this.state.pendingIntentions.get(taskId);
    if (!pending) return;

    const taskState = this.state.activeTasks.get(taskId);

    if (decision.approved) {
      if (taskState) {
        taskState.status = 'approved';
        taskState.approvalNotes = decision.notes;
      }
      this.log('approval_sent', `Approved: ${decision.type}`, taskId, pending.agentId);
    } else {
      this.log('rejection_sent', `Rejected: ${decision.reason}`, taskId, pending.agentId);
    }

    // Remove from pending
    this.state.pendingIntentions.delete(taskId);

    this.emit('intention:decided', { taskId, decision });
  }

  /**
   * Mark task as working (post-approval).
   */
  markTaskWorking(taskId: string): void {
    const taskState = this.state.activeTasks.get(taskId);
    if (taskState) {
      taskState.status = 'working';
    }
  }

  /**
   * Mark task as merging.
   */
  markTaskMerging(taskId: string): void {
    const taskState = this.state.activeTasks.get(taskId);
    if (taskState) {
      taskState.status = 'merging';
    }
  }

  /**
   * Mark task as completed, remove from active.
   */
  completeTask(taskId: string): void {
    this.state.activeTasks.delete(taskId);
    this.log('task_completed', `Task ${taskId} completed`, taskId);
    this.emit('task:completed', taskId);
  }

  /**
   * Mark task as failed.
   */
  failTask(taskId: string, error: string): void {
    this.state.activeTasks.delete(taskId);
    this.log('task_failed', `Task ${taskId} failed: ${error}`, taskId);
    this.emit('task:failed', { taskId, error });
  }

  /**
   * Reset harness state.
   */
  reset(): void {
    if (this.agentInfo) {
      getAgentPool().terminateAgent(this.agentInfo.id);
    }

    this.state = {
      ...DEFAULT_HARNESS_STATE,
      activeTasks: new Map(),
      pendingIntentions: new Map(),
      messageHistory: [],
    };

    this.agentInfo = null;
    this.emit('harness:reset');
  }

  /**
   * Get message history.
   */
  getMessageHistory(): HarnessMessage[] {
    return [...this.state.messageHistory];
  }

  /**
   * Add a log message.
   */
  private log(
    type: HarnessMessage['type'],
    content: string,
    taskId?: string,
    agentId?: string
  ): void {
    const message: HarnessMessage = {
      type,
      content,
      taskId,
      agentId,
      timestamp: new Date().toISOString(),
    };

    this.state.messageHistory.push(message);
    this.emit('harness:message', message);
  }
}

// Singleton instance
let harnessInstance: HarnessAgent | null = null;

export function getHarnessAgent(): HarnessAgent {
  if (!harnessInstance) {
    harnessInstance = new HarnessAgent();
  }
  return harnessInstance;
}

export function resetHarnessAgent(): void {
  if (harnessInstance) {
    harnessInstance.reset();
  }
  harnessInstance = null;
}
```

Update src/main/agents/index.ts:
```typescript
export * from './types';
export * from './agent-pool';
export * from './harness-types';
export * from './harness-agent';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>HarnessAgent class with intention-approval workflow, task tracking, and event emission</done>
</task>

<task type="auto">
  <name>Task 3: Add harness IPC handlers and preload exposure</name>
  <files>src/main/ipc/harness-handlers.ts, src/main/ipc/handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Create src/main/ipc/harness-handlers.ts:
```typescript
import { ipcMain } from 'electron';
import { getHarnessAgent, resetHarnessAgent } from '../agents';
import type { DAGGraph } from '@shared/types';

export function registerHarnessHandlers(): void {
  ipcMain.handle('harness:initialize', async (
    _event,
    featureId: string,
    featureGoal: string,
    graph: DAGGraph,
    claudeMd?: string
  ) => {
    const harness = getHarnessAgent();
    return harness.initialize(featureId, featureGoal, graph, claudeMd);
  });

  ipcMain.handle('harness:start', async () => {
    const harness = getHarnessAgent();
    return harness.start();
  });

  ipcMain.handle('harness:pause', async () => {
    const harness = getHarnessAgent();
    return harness.pause();
  });

  ipcMain.handle('harness:resume', async () => {
    const harness = getHarnessAgent();
    return harness.resume();
  });

  ipcMain.handle('harness:stop', async () => {
    const harness = getHarnessAgent();
    return harness.stop();
  });

  ipcMain.handle('harness:get-state', async () => {
    const harness = getHarnessAgent();
    return harness.getState();
  });

  ipcMain.handle('harness:get-status', async () => {
    const harness = getHarnessAgent();
    return harness.getStatus();
  });

  ipcMain.handle('harness:register-task-assignment', async (
    _event,
    taskId: string,
    agentId: string
  ) => {
    const harness = getHarnessAgent();
    harness.registerTaskAssignment(taskId, agentId);
    return true;
  });

  ipcMain.handle('harness:receive-intention', async (
    _event,
    agentId: string,
    taskId: string,
    intention: string,
    files?: string[]
  ) => {
    const harness = getHarnessAgent();
    harness.receiveIntention(agentId, taskId, intention, files);
    return true;
  });

  ipcMain.handle('harness:process-intention', async (_event, taskId: string) => {
    const harness = getHarnessAgent();
    return harness.processIntention(taskId);
  });

  ipcMain.handle('harness:mark-task-working', async (_event, taskId: string) => {
    const harness = getHarnessAgent();
    harness.markTaskWorking(taskId);
    return true;
  });

  ipcMain.handle('harness:mark-task-merging', async (_event, taskId: string) => {
    const harness = getHarnessAgent();
    harness.markTaskMerging(taskId);
    return true;
  });

  ipcMain.handle('harness:complete-task', async (_event, taskId: string) => {
    const harness = getHarnessAgent();
    harness.completeTask(taskId);
    return true;
  });

  ipcMain.handle('harness:fail-task', async (_event, taskId: string, error: string) => {
    const harness = getHarnessAgent();
    harness.failTask(taskId, error);
    return true;
  });

  ipcMain.handle('harness:get-message-history', async () => {
    const harness = getHarnessAgent();
    return harness.getMessageHistory();
  });

  ipcMain.handle('harness:reset', async () => {
    resetHarnessAgent();
    return true;
  });
}
```

Update src/main/ipc/handlers.ts:
```typescript
import { registerHarnessHandlers } from './harness-handlers';

export function registerAllHandlers(): void {
  // ... existing handlers
  registerHarnessHandlers();
}
```

Update src/preload/index.ts:
```typescript
const harnessAPI = {
  initialize: (featureId: string, featureGoal: string, graph: DAGGraph, claudeMd?: string) =>
    ipcRenderer.invoke('harness:initialize', featureId, featureGoal, graph, claudeMd),
  start: () => ipcRenderer.invoke('harness:start'),
  pause: () => ipcRenderer.invoke('harness:pause'),
  resume: () => ipcRenderer.invoke('harness:resume'),
  stop: () => ipcRenderer.invoke('harness:stop'),
  getState: () => ipcRenderer.invoke('harness:get-state'),
  getStatus: () => ipcRenderer.invoke('harness:get-status'),
  registerTaskAssignment: (taskId: string, agentId: string) =>
    ipcRenderer.invoke('harness:register-task-assignment', taskId, agentId),
  receiveIntention: (agentId: string, taskId: string, intention: string, files?: string[]) =>
    ipcRenderer.invoke('harness:receive-intention', agentId, taskId, intention, files),
  processIntention: (taskId: string) =>
    ipcRenderer.invoke('harness:process-intention', taskId),
  markTaskWorking: (taskId: string) =>
    ipcRenderer.invoke('harness:mark-task-working', taskId),
  markTaskMerging: (taskId: string) =>
    ipcRenderer.invoke('harness:mark-task-merging', taskId),
  completeTask: (taskId: string) =>
    ipcRenderer.invoke('harness:complete-task', taskId),
  failTask: (taskId: string, error: string) =>
    ipcRenderer.invoke('harness:fail-task', taskId, error),
  getMessageHistory: () => ipcRenderer.invoke('harness:get-message-history'),
  reset: () => ipcRenderer.invoke('harness:reset'),
};

// Add to contextBridge
contextBridge.exposeInMainWorld('electronAPI', {
  // ... existing
  harness: harnessAPI,
});
```

Update src/preload/index.d.ts:
```typescript
type HarnessStatus = 'idle' | 'active' | 'paused' | 'stopped';

interface TaskExecutionState {
  taskId: string;
  agentId: string;
  status: 'assigned' | 'intention_pending' | 'approved' | 'working' | 'merging';
  intention?: string;
  approvalNotes?: string;
  startedAt: string;
}

interface PendingIntention {
  agentId: string;
  taskId: string;
  intention: string;
  files?: string[];
  receivedAt: string;
}

interface HarnessMessage {
  type: string;
  taskId?: string;
  agentId?: string;
  content: string;
  timestamp: string;
}

interface HarnessState {
  status: HarnessStatus;
  featureId: string | null;
  featureGoal: string | null;
  claudeMd: string | null;
  activeTasks: TaskExecutionState[];
  pendingIntentions: PendingIntention[];
  messageHistory: HarnessMessage[];
  startedAt: string | null;
  stoppedAt: string | null;
}

interface IntentionDecision {
  approved: boolean;
  type: 'approved' | 'approved_with_notes' | 'modified' | 'rejected';
  notes?: string;
  modifications?: string;
  reason?: string;
}

interface HarnessAPI {
  initialize: (featureId: string, featureGoal: string, graph: DAGGraph, claudeMd?: string) => Promise<boolean>;
  start: () => Promise<boolean>;
  pause: () => Promise<boolean>;
  resume: () => Promise<boolean>;
  stop: () => Promise<boolean>;
  getState: () => Promise<HarnessState>;
  getStatus: () => Promise<HarnessStatus>;
  registerTaskAssignment: (taskId: string, agentId: string) => Promise<boolean>;
  receiveIntention: (agentId: string, taskId: string, intention: string, files?: string[]) => Promise<boolean>;
  processIntention: (taskId: string) => Promise<IntentionDecision | null>;
  markTaskWorking: (taskId: string) => Promise<boolean>;
  markTaskMerging: (taskId: string) => Promise<boolean>;
  completeTask: (taskId: string) => Promise<boolean>;
  failTask: (taskId: string, error: string) => Promise<boolean>;
  getMessageHistory: () => Promise<HarnessMessage[]>;
  reset: () => Promise<boolean>;
}

interface ElectronAPI {
  // ... existing
  harness: HarnessAPI;
}
```
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>Harness IPC handlers expose intention-approval workflow to renderer</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] HarnessAgent class with full lifecycle (initialize, start, pause, resume, stop)
- [ ] Intention-approval workflow (receiveIntention, processIntention)
- [ ] Task tracking (registerTaskAssignment, markTaskWorking, markTaskMerging)
- [ ] Message history logging
- [ ] IPC handlers expose all harness operations
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Harness agent ready for task agent integration (Plan 05-03)
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-system/05-02-SUMMARY.md` with:
- HarnessAgent class structure
- Intention-approval workflow per DAGENT_SPEC section 7.2-7.4
- Task execution state tracking
- IPC integration pattern
- Ready for Plan 05-03 (task agent)
</output>
