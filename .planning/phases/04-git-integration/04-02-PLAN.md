---
phase: 04-git-integration
plan: 02
type: execute
---

<objective>
Implement worktree lifecycle management (create, delete, list) for feature and task isolation.

Purpose: Enable isolated working directories for features and tasks per DAGENT_SPEC section 8.2-8.3.
Output: Worktree operations in GitManager with full lifecycle support.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./04-02-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-git-integration/04-01-SUMMARY.md
@DAGENT_SPEC.md (section 8.2-8.3 for worktree structure and lifecycle)

**Tech stack available:** Electron, React, TypeScript, simple-git
**Established patterns:** GitManager class with singleton pattern, IPC via contextBridge
**Git patterns:** Branch naming functions, GitOperationResult for error handling

**Worktree structure from DAGENT_SPEC 8.2:**
- Feature worktrees: `.dagent-worktrees/feature-car/`
- Task worktrees: `.dagent-worktrees/feature-car--task-2145/`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add worktree types and extend GitManager types</name>
  <files>src/main/git/types.ts</files>
  <action>
Extend src/main/git/types.ts with worktree types:
```typescript
export interface WorktreeInfo {
  path: string;            // Absolute path to worktree
  branch: string;          // Branch name (or HEAD for detached)
  head: string;            // Current commit hash
  isDetached: boolean;     // Whether HEAD is detached
  isLocked: boolean;       // Whether worktree is locked
  prunable: boolean;       // Whether worktree can be pruned
}

export interface CreateWorktreeOptions {
  branch?: string;         // Branch to checkout (creates if doesn't exist)
  newBranch?: boolean;     // Create new branch
  detach?: boolean;        // Detached HEAD
  force?: boolean;         // Force creation even if branch exists elsewhere
}

export interface FeatureWorktreeResult extends GitOperationResult {
  worktreePath?: string;   // Path to created worktree
  branchName?: string;     // Name of feature branch
  dagentPath?: string;     // Path to .dagent directory
}

export interface TaskWorktreeResult extends GitOperationResult {
  worktreePath?: string;   // Path to created worktree
  branchName?: string;     // Name of task branch
}

// Paths helper functions
export function getWorktreePath(worktreesDir: string, worktreeName: string): string {
  return path.join(worktreesDir, worktreeName);
}

export function getDagentDirInWorktree(worktreePath: string): string {
  return path.join(worktreePath, '.dagent');
}
```

Note: Add `import * as path from 'path';` at top of file.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Worktree types defined with FeatureWorktreeResult and TaskWorktreeResult</done>
</task>

<task type="auto">
  <name>Task 2: Implement worktree operations in GitManager</name>
  <files>src/main/git/git-manager.ts</files>
  <action>
Add worktree methods to GitManager class:
```typescript
// Add to GitManager class

/**
 * List all worktrees.
 */
async listWorktrees(): Promise<WorktreeInfo[]> {
  this.ensureInitialized();
  try {
    // simple-git doesn't have built-in worktree support, use raw command
    const result = await this.git.raw(['worktree', 'list', '--porcelain']);
    return this.parseWorktreeList(result);
  } catch (error) {
    console.error('Failed to list worktrees:', error);
    return [];
  }
}

/**
 * Create a feature worktree with .dagent directory.
 */
async createFeatureWorktree(featureId: string): Promise<FeatureWorktreeResult> {
  this.ensureInitialized();
  try {
    const branchName = getFeatureBranchName(featureId);
    const worktreeName = getFeatureWorktreeName(featureId);
    const worktreePath = path.join(this.config.worktreesDir, worktreeName);

    // Check if worktree already exists
    const worktrees = await this.listWorktrees();
    if (worktrees.some(w => w.path === worktreePath)) {
      return {
        success: false,
        error: `Worktree already exists at ${worktreePath}`,
      };
    }

    // Create branch if it doesn't exist
    const branchExists = await this.branchExists(branchName);
    if (!branchExists) {
      await this.git.branch([branchName]);
    }

    // Create worktree
    await this.git.raw(['worktree', 'add', worktreePath, branchName]);

    // Create .dagent directory in worktree
    const dagentPath = path.join(worktreePath, '.dagent');
    await fs.mkdir(dagentPath, { recursive: true });
    await fs.mkdir(path.join(dagentPath, 'nodes'), { recursive: true });
    await fs.mkdir(path.join(dagentPath, 'dag_history'), { recursive: true });

    return {
      success: true,
      worktreePath,
      branchName,
      dagentPath,
    };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
}

/**
 * Create a task worktree branching from feature branch.
 */
async createTaskWorktree(featureId: string, taskId: string): Promise<TaskWorktreeResult> {
  this.ensureInitialized();
  try {
    const featureBranchName = getFeatureBranchName(featureId);
    const taskBranchName = getTaskBranchName(featureId, taskId);
    const worktreeName = getTaskWorktreeName(featureId, taskId);
    const worktreePath = path.join(this.config.worktreesDir, worktreeName);

    // Check if worktree already exists
    const worktrees = await this.listWorktrees();
    if (worktrees.some(w => w.path === worktreePath)) {
      return {
        success: false,
        error: `Worktree already exists at ${worktreePath}`,
      };
    }

    // Verify feature branch exists
    const featureBranchExists = await this.branchExists(featureBranchName);
    if (!featureBranchExists) {
      return {
        success: false,
        error: `Feature branch ${featureBranchName} does not exist`,
      };
    }

    // Create task branch from feature branch and worktree
    await this.git.raw([
      'worktree', 'add',
      '-b', taskBranchName,
      worktreePath,
      featureBranchName,
    ]);

    return {
      success: true,
      worktreePath,
      branchName: taskBranchName,
    };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
}

/**
 * Remove a worktree (and optionally its branch).
 */
async removeWorktree(worktreePath: string, deleteBranch: boolean = false): Promise<GitOperationResult> {
  this.ensureInitialized();
  try {
    // Get worktree info first
    const worktrees = await this.listWorktrees();
    const worktree = worktrees.find(w => w.path === worktreePath);

    if (!worktree) {
      return { success: false, error: `Worktree not found at ${worktreePath}` };
    }

    // Remove worktree
    await this.git.raw(['worktree', 'remove', worktreePath, '--force']);

    // Delete branch if requested
    if (deleteBranch && worktree.branch && worktree.branch !== 'HEAD') {
      await this.deleteBranch(worktree.branch, true);
    }

    return { success: true };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
}

/**
 * Get a worktree by its path.
 */
async getWorktree(worktreePath: string): Promise<WorktreeInfo | null> {
  const worktrees = await this.listWorktrees();
  return worktrees.find(w => w.path === worktreePath) || null;
}

/**
 * Check if a worktree exists.
 */
async worktreeExists(worktreePath: string): Promise<boolean> {
  const worktree = await this.getWorktree(worktreePath);
  return worktree !== null;
}

/**
 * Parse worktree list output from git.
 */
private parseWorktreeList(output: string): WorktreeInfo[] {
  const worktrees: WorktreeInfo[] = [];
  const entries = output.trim().split('\n\n');

  for (const entry of entries) {
    if (!entry.trim()) continue;

    const lines = entry.split('\n');
    const info: Partial<WorktreeInfo> = {
      isDetached: false,
      isLocked: false,
      prunable: false,
    };

    for (const line of lines) {
      if (line.startsWith('worktree ')) {
        info.path = line.substring(9);
      } else if (line.startsWith('HEAD ')) {
        info.head = line.substring(5);
      } else if (line.startsWith('branch ')) {
        info.branch = line.substring(7).replace('refs/heads/', '');
      } else if (line === 'detached') {
        info.isDetached = true;
        info.branch = 'HEAD';
      } else if (line.startsWith('locked')) {
        info.isLocked = true;
      } else if (line.startsWith('prunable')) {
        info.prunable = true;
      }
    }

    if (info.path && info.head) {
      worktrees.push(info as WorktreeInfo);
    }
  }

  return worktrees;
}
```

Add necessary imports at top of file:
```typescript
import type { WorktreeInfo, FeatureWorktreeResult, TaskWorktreeResult } from './types';
import { getFeatureBranchName, getTaskBranchName, getFeatureWorktreeName, getTaskWorktreeName } from './types';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Worktree operations implemented: create feature, create task, remove, list</done>
</task>

<task type="auto">
  <name>Task 3: Add worktree IPC handlers and update preload</name>
  <files>src/main/ipc/git-handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Add worktree handlers to src/main/ipc/git-handlers.ts:
```typescript
// Add to registerGitHandlers()

ipcMain.handle('git:list-worktrees', async () => {
  const manager = getGitManager();
  return manager.listWorktrees();
});

ipcMain.handle('git:get-worktree', async (_event, worktreePath: string) => {
  const manager = getGitManager();
  return manager.getWorktree(worktreePath);
});

ipcMain.handle('git:worktree-exists', async (_event, worktreePath: string) => {
  const manager = getGitManager();
  return manager.worktreeExists(worktreePath);
});

ipcMain.handle('git:create-feature-worktree', async (_event, featureId: string) => {
  const manager = getGitManager();
  return manager.createFeatureWorktree(featureId);
});

ipcMain.handle('git:create-task-worktree', async (_event, featureId: string, taskId: string) => {
  const manager = getGitManager();
  return manager.createTaskWorktree(featureId, taskId);
});

ipcMain.handle('git:remove-worktree', async (_event, worktreePath: string, deleteBranch: boolean = false) => {
  const manager = getGitManager();
  return manager.removeWorktree(worktreePath, deleteBranch);
});
```

Update src/preload/index.ts gitAPI:
```typescript
const gitAPI = {
  // ... existing methods

  // Worktree operations
  listWorktrees: () => ipcRenderer.invoke('git:list-worktrees'),
  getWorktree: (worktreePath: string) => ipcRenderer.invoke('git:get-worktree', worktreePath),
  worktreeExists: (worktreePath: string) => ipcRenderer.invoke('git:worktree-exists', worktreePath),
  createFeatureWorktree: (featureId: string) =>
    ipcRenderer.invoke('git:create-feature-worktree', featureId),
  createTaskWorktree: (featureId: string, taskId: string) =>
    ipcRenderer.invoke('git:create-task-worktree', featureId, taskId),
  removeWorktree: (worktreePath: string, deleteBranch?: boolean) =>
    ipcRenderer.invoke('git:remove-worktree', worktreePath, deleteBranch),
};
```

Update src/preload/index.d.ts:
```typescript
interface WorktreeInfo {
  path: string;
  branch: string;
  head: string;
  isDetached: boolean;
  isLocked: boolean;
  prunable: boolean;
}

interface FeatureWorktreeResult extends GitOperationResult {
  worktreePath?: string;
  branchName?: string;
  dagentPath?: string;
}

interface TaskWorktreeResult extends GitOperationResult {
  worktreePath?: string;
  branchName?: string;
}

interface GitAPI {
  // ... existing methods

  // Worktree operations
  listWorktrees: () => Promise<WorktreeInfo[]>;
  getWorktree: (worktreePath: string) => Promise<WorktreeInfo | null>;
  worktreeExists: (worktreePath: string) => Promise<boolean>;
  createFeatureWorktree: (featureId: string) => Promise<FeatureWorktreeResult>;
  createTaskWorktree: (featureId: string, taskId: string) => Promise<TaskWorktreeResult>;
  removeWorktree: (worktreePath: string, deleteBranch?: boolean) => Promise<GitOperationResult>;
}
```
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>Worktree IPC handlers expose lifecycle operations to renderer</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] Worktree types defined (WorktreeInfo, FeatureWorktreeResult, TaskWorktreeResult)
- [ ] Feature worktree creates branch, worktree, and .dagent directory
- [ ] Task worktree branches from feature branch
- [ ] Worktree removal works with optional branch deletion
- [ ] IPC handlers expose all worktree operations
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Worktree lifecycle ready for merge operations (Plan 04-03)
</success_criteria>

<output>
After completion, create `.planning/phases/04-git-integration/04-02-SUMMARY.md` with:
- Worktree operations (create feature, create task, remove, list)
- Directory structure created per DAGENT_SPEC 8.2
- Worktree lifecycle per DAGENT_SPEC 8.3
- Ready for Plan 04-03 (branch operations and merge handling)
</output>
