---
phase: 04-git-integration
plan: 03
type: execute
---

<objective>
Implement branch operations and merge handling for task integration.

Purpose: Enable merging task branches into feature branches per DAGENT_SPEC section 8.4.
Output: Merge operations in GitManager with conflict detection and resolution support.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./04-03-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-git-integration/04-01-SUMMARY.md
@.planning/phases/04-git-integration/04-02-SUMMARY.md
@DAGENT_SPEC.md (section 8.4 for merge flow)

**Tech stack available:** Electron, React, TypeScript, simple-git
**Established patterns:** GitManager with worktree operations, branch naming functions
**Git patterns:** Feature/task branch hierarchy, worktree isolation

**Merge flow from DAGENT_SPEC 8.4:**
1. Task agent completes work in task worktree
2. Merge task branch into feature branch
3. On success: delete task worktree and branch
4. On failure: keep worktree for debugging
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add merge types and extend GitManager types</name>
  <files>src/main/git/types.ts</files>
  <action>
Add merge-related types to src/main/git/types.ts:
```typescript
export interface MergeConflict {
  file: string;
  type: 'both_modified' | 'deleted_by_us' | 'deleted_by_them' | 'both_added';
}

export interface MergeResult extends GitOperationResult {
  merged: boolean;
  conflicts?: MergeConflict[];
  commitHash?: string;
}

export interface CommitInfo {
  hash: string;
  date: string;
  message: string;
  author: string;
  email: string;
}

export interface DiffSummary {
  files: number;
  insertions: number;
  deletions: number;
  changed: string[];
}

export interface TaskMergeResult extends GitOperationResult {
  merged: boolean;
  conflicts?: MergeConflict[];
  commitHash?: string;
  worktreeRemoved: boolean;
  branchDeleted: boolean;
}
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Merge types defined (MergeResult, MergeConflict, TaskMergeResult)</done>
</task>

<task type="auto">
  <name>Task 2: Implement merge operations in GitManager</name>
  <files>src/main/git/git-manager.ts</files>
  <action>
Add merge methods to GitManager class:
```typescript
// Add to GitManager class

/**
 * Merge a branch into current branch.
 */
async mergeBranch(branchName: string, message?: string): Promise<MergeResult> {
  this.ensureInitialized();
  try {
    const mergeOptions = message ? ['--no-ff', '-m', message] : ['--no-ff'];
    const result = await this.git.merge([branchName, ...mergeOptions]);

    return {
      success: true,
      merged: true,
      commitHash: result.commit || undefined,
    };
  } catch (error) {
    const errorMsg = (error as Error).message;

    // Check for merge conflicts
    if (errorMsg.includes('CONFLICT') || errorMsg.includes('Automatic merge failed')) {
      const conflicts = await this.getConflicts();
      return {
        success: false,
        merged: false,
        conflicts,
        error: 'Merge conflicts detected',
      };
    }

    return { success: false, merged: false, error: errorMsg };
  }
}

/**
 * Get current merge conflicts.
 */
async getConflicts(): Promise<MergeConflict[]> {
  this.ensureInitialized();
  try {
    const status = await this.git.status();
    const conflicts: MergeConflict[] = [];

    for (const file of status.conflicted) {
      conflicts.push({
        file,
        type: 'both_modified', // Simplified - actual type requires more parsing
      });
    }

    return conflicts;
  } catch {
    return [];
  }
}

/**
 * Abort an in-progress merge.
 */
async abortMerge(): Promise<GitOperationResult> {
  this.ensureInitialized();
  try {
    await this.git.merge(['--abort']);
    return { success: true };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
}

/**
 * Check if there's a merge in progress.
 */
async isMergeInProgress(): Promise<boolean> {
  this.ensureInitialized();
  try {
    const gitDir = path.join(this.config.baseDir, '.git');
    const mergeHead = path.join(gitDir, 'MERGE_HEAD');
    await fs.access(mergeHead);
    return true;
  } catch {
    return false;
  }
}

/**
 * Merge a task branch into its feature branch.
 * This is the main operation for completing a task.
 */
async mergeTaskIntoFeature(
  featureId: string,
  taskId: string,
  removeWorktreeOnSuccess: boolean = true
): Promise<TaskMergeResult> {
  this.ensureInitialized();
  try {
    const featureBranchName = getFeatureBranchName(featureId);
    const taskBranchName = getTaskBranchName(featureId, taskId);
    const featureWorktreeName = getFeatureWorktreeName(featureId);
    const taskWorktreeName = getTaskWorktreeName(featureId, taskId);
    const featureWorktreePath = path.join(this.config.worktreesDir, featureWorktreeName);
    const taskWorktreePath = path.join(this.config.worktreesDir, taskWorktreeName);

    // Verify both worktrees exist
    const featureWorktree = await this.getWorktree(featureWorktreePath);
    const taskWorktree = await this.getWorktree(taskWorktreePath);

    if (!featureWorktree) {
      return {
        success: false,
        merged: false,
        worktreeRemoved: false,
        branchDeleted: false,
        error: `Feature worktree not found at ${featureWorktreePath}`,
      };
    }

    if (!taskWorktree) {
      return {
        success: false,
        merged: false,
        worktreeRemoved: false,
        branchDeleted: false,
        error: `Task worktree not found at ${taskWorktreePath}`,
      };
    }

    // Create a git instance for the feature worktree
    const featureGit = simpleGit({ baseDir: featureWorktreePath });

    // Perform merge in the feature worktree
    const mergeMessage = `Merge task ${taskId} into feature ${featureId}`;
    let mergeResult: MergeResult;

    try {
      const result = await featureGit.merge([taskBranchName, '--no-ff', '-m', mergeMessage]);
      mergeResult = {
        success: true,
        merged: true,
        commitHash: result.commit || undefined,
      };
    } catch (error) {
      const errorMsg = (error as Error).message;

      if (errorMsg.includes('CONFLICT') || errorMsg.includes('Automatic merge failed')) {
        // Get conflicts from feature worktree
        const status = await featureGit.status();
        const conflicts: MergeConflict[] = status.conflicted.map(file => ({
          file,
          type: 'both_modified' as const,
        }));

        return {
          success: false,
          merged: false,
          conflicts,
          worktreeRemoved: false,
          branchDeleted: false,
          error: 'Merge conflicts detected',
        };
      }

      return {
        success: false,
        merged: false,
        worktreeRemoved: false,
        branchDeleted: false,
        error: errorMsg,
      };
    }

    // On successful merge, optionally remove task worktree and branch
    let worktreeRemoved = false;
    let branchDeleted = false;

    if (removeWorktreeOnSuccess && mergeResult.merged) {
      const removeResult = await this.removeWorktree(taskWorktreePath, true);
      worktreeRemoved = removeResult.success;
      branchDeleted = removeResult.success;
    }

    return {
      success: true,
      merged: true,
      commitHash: mergeResult.commitHash,
      worktreeRemoved,
      branchDeleted,
    };
  } catch (error) {
    return {
      success: false,
      merged: false,
      worktreeRemoved: false,
      branchDeleted: false,
      error: (error as Error).message,
    };
  }
}

/**
 * Get commit log for a branch or worktree.
 */
async getLog(maxCount: number = 10, branch?: string): Promise<CommitInfo[]> {
  this.ensureInitialized();
  try {
    const options: string[] = [`-${maxCount}`, '--format=%H|%aI|%s|%an|%ae'];
    if (branch) {
      options.push(branch);
    }

    const result = await this.git.log(options);
    return result.all.map(entry => ({
      hash: entry.hash,
      date: entry.date,
      message: entry.message,
      author: entry.author_name,
      email: entry.author_email,
    }));
  } catch {
    return [];
  }
}

/**
 * Get diff summary between two refs.
 */
async getDiffSummary(from: string, to: string): Promise<DiffSummary> {
  this.ensureInitialized();
  try {
    const summary = await this.git.diffSummary([from, to]);
    return {
      files: summary.files.length,
      insertions: summary.insertions,
      deletions: summary.deletions,
      changed: summary.files.map(f => f.file),
    };
  } catch {
    return { files: 0, insertions: 0, deletions: 0, changed: [] };
  }
}
```

Add necessary imports at top of file:
```typescript
import type { MergeResult, MergeConflict, TaskMergeResult, CommitInfo, DiffSummary } from './types';
```
  </action>
  <verify>npm run typecheck passes</verify>
  <done>Merge operations implemented: mergeBranch, mergeTaskIntoFeature, getConflicts</done>
</task>

<task type="auto">
  <name>Task 3: Add merge IPC handlers and update preload</name>
  <files>src/main/ipc/git-handlers.ts, src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
Add merge handlers to src/main/ipc/git-handlers.ts:
```typescript
// Add to registerGitHandlers()

ipcMain.handle('git:merge-branch', async (_event, branchName: string, message?: string) => {
  const manager = getGitManager();
  return manager.mergeBranch(branchName, message);
});

ipcMain.handle('git:get-conflicts', async () => {
  const manager = getGitManager();
  return manager.getConflicts();
});

ipcMain.handle('git:abort-merge', async () => {
  const manager = getGitManager();
  return manager.abortMerge();
});

ipcMain.handle('git:is-merge-in-progress', async () => {
  const manager = getGitManager();
  return manager.isMergeInProgress();
});

ipcMain.handle('git:merge-task-into-feature', async (
  _event,
  featureId: string,
  taskId: string,
  removeWorktreeOnSuccess: boolean = true
) => {
  const manager = getGitManager();
  return manager.mergeTaskIntoFeature(featureId, taskId, removeWorktreeOnSuccess);
});

ipcMain.handle('git:get-log', async (_event, maxCount: number = 10, branch?: string) => {
  const manager = getGitManager();
  return manager.getLog(maxCount, branch);
});

ipcMain.handle('git:get-diff-summary', async (_event, from: string, to: string) => {
  const manager = getGitManager();
  return manager.getDiffSummary(from, to);
});
```

Update src/preload/index.ts gitAPI:
```typescript
const gitAPI = {
  // ... existing methods

  // Merge operations
  mergeBranch: (branchName: string, message?: string) =>
    ipcRenderer.invoke('git:merge-branch', branchName, message),
  getConflicts: () => ipcRenderer.invoke('git:get-conflicts'),
  abortMerge: () => ipcRenderer.invoke('git:abort-merge'),
  isMergeInProgress: () => ipcRenderer.invoke('git:is-merge-in-progress'),
  mergeTaskIntoFeature: (featureId: string, taskId: string, removeWorktreeOnSuccess?: boolean) =>
    ipcRenderer.invoke('git:merge-task-into-feature', featureId, taskId, removeWorktreeOnSuccess),
  getLog: (maxCount?: number, branch?: string) =>
    ipcRenderer.invoke('git:get-log', maxCount, branch),
  getDiffSummary: (from: string, to: string) =>
    ipcRenderer.invoke('git:get-diff-summary', from, to),
};
```

Update src/preload/index.d.ts:
```typescript
interface MergeConflict {
  file: string;
  type: 'both_modified' | 'deleted_by_us' | 'deleted_by_them' | 'both_added';
}

interface MergeResult extends GitOperationResult {
  merged: boolean;
  conflicts?: MergeConflict[];
  commitHash?: string;
}

interface TaskMergeResult extends GitOperationResult {
  merged: boolean;
  conflicts?: MergeConflict[];
  commitHash?: string;
  worktreeRemoved: boolean;
  branchDeleted: boolean;
}

interface CommitInfo {
  hash: string;
  date: string;
  message: string;
  author: string;
  email: string;
}

interface DiffSummary {
  files: number;
  insertions: number;
  deletions: number;
  changed: string[];
}

interface GitAPI {
  // ... existing methods

  // Merge operations
  mergeBranch: (branchName: string, message?: string) => Promise<MergeResult>;
  getConflicts: () => Promise<MergeConflict[]>;
  abortMerge: () => Promise<GitOperationResult>;
  isMergeInProgress: () => Promise<boolean>;
  mergeTaskIntoFeature: (
    featureId: string,
    taskId: string,
    removeWorktreeOnSuccess?: boolean
  ) => Promise<TaskMergeResult>;
  getLog: (maxCount?: number, branch?: string) => Promise<CommitInfo[]>;
  getDiffSummary: (from: string, to: string) => Promise<DiffSummary>;
}
```
  </action>
  <verify>npm run typecheck passes, npm run dev starts without errors</verify>
  <done>Merge IPC handlers complete, Phase 4 Git Integration complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes with no errors
- [ ] Merge types defined (MergeResult, MergeConflict, TaskMergeResult)
- [ ] mergeTaskIntoFeature performs full task merge flow
- [ ] Conflict detection works
- [ ] IPC handlers expose all merge operations
- [ ] `npm run dev` runs without errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Phase 4: Git Integration complete
- Ready for Phase 5 (Agent System) which will use git operations for task isolation
</success_criteria>

<output>
After completion, create `.planning/phases/04-git-integration/04-03-SUMMARY.md` with:
- Merge operations (mergeBranch, mergeTaskIntoFeature)
- Conflict detection and abort
- Task merge flow per DAGENT_SPEC 8.4
- Phase 4 complete, ready for Phase 5 (Agent System)

Also update:
- STATE.md: Phase 4 complete, ready for Phase 5
- ROADMAP.md: Mark Phase 4 complete with date
</output>
