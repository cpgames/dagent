---
phase: v3.0-04-pm-agent-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/agent/pm-agent-manager.ts
  - src/renderer/src/stores/chat-store.ts
  - src/main/ipc/session-handlers.ts
  - src/preload/index.d.ts
  - src/preload/index.ts
autonomous: true

must_haves:
  truths:
    - "PM planning creates a session when feature planning starts"
    - "PM planning saves messages to session during planning workflow"
    - "PM interactive chat loads messages from session"
    - "PM interactive chat saves new messages to session"
    - "Session compaction works during interactive PM chat"
  artifacts:
    - path: "src/main/agent/pm-agent-manager.ts"
      provides: "PM planning with session-based storage"
      contains: "sessionManager"
    - path: "src/renderer/src/stores/chat-store.ts"
      provides: "Interactive chat with session-based storage"
      contains: "session.loadSession|session.addMessage"
    - path: "src/main/ipc/session-handlers.ts"
      provides: "IPC handlers for session operations"
      contains: "session:loadMessages|session:addUserMessage"
    - path: "src/preload/index.d.ts"
      provides: "Type definitions for session API"
      contains: "loadMessages|addUserMessage"
  key_links:
    - from: "src/main/agent/pm-agent-manager.ts"
      to: "SessionManager"
      via: "uses getOrCreateSession and addMessage"
      pattern: "sessionManager\\.(getOrCreateSession|addMessage)"
    - from: "src/renderer/src/stores/chat-store.ts"
      to: "session IPC API"
      via: "calls window.electronAPI.session methods"
      pattern: "electronAPI\\.session\\.(loadMessages|addUserMessage)"
---

<objective>
Migrate PM agent to use SessionManager for both planning workflow and interactive chat.

Purpose: Prove SessionManager works end-to-end with a real agent type. PM agent is ideal because it's the most frequently used agent and exercises all session capabilities (creation, message storage, context loading).

Output:
- PMAgentManager creates sessions and stores planning messages
- Chat-store loads/saves via session API instead of old chat storage
- Session-based message handling with automatic compaction readiness
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v3.0-session-checkpoint-ROADMAP.md
@.planning/STATE.md
@.planning/phases/v3.0-03-request-building/03-01-SUMMARY.md

# Relevant source files:
@src/main/agent/pm-agent-manager.ts
@src/renderer/src/stores/chat-store.ts
@src/main/services/session-manager.ts
@src/main/ipc/session-handlers.ts
@src/preload/index.d.ts
@src/preload/index.ts
@src/shared/types/session.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add session-friendly IPC handlers for message operations</name>
  <files>src/main/ipc/session-handlers.ts, src/preload/index.d.ts, src/preload/index.ts</files>
  <action>
Add IPC handlers that make it convenient for the renderer to work with sessions for PM chat:

**session-handlers.ts:**
Add three new IPC handlers:

1. `session:loadMessages` - Load all messages from a session for display
   - Parameters: projectRoot, sessionId, featureId
   - Returns: ChatMessage[] (the messages array from chat session)
   - Implementation: Get or create session, load chat session, return messages

2. `session:addUserMessage` - Add a user message and prepare for assistant response
   - Parameters: projectRoot, sessionId, featureId, content
   - Returns: void
   - Implementation: Call manager.addMessage() with role='user'

3. `session:addAssistantMessage` - Add assistant message after streaming complete
   - Parameters: projectRoot, sessionId, featureId, content, metadata (optional)
   - Returns: void
   - Implementation: Call manager.addMessage() with role='assistant'

```typescript
ipcMain.handle(
  'session:loadMessages',
  async (
    _event,
    projectRoot: string,
    sessionId: string,
    featureId: string
  ): Promise<ChatMessage[]> => {
    const manager = getSessionManager(projectRoot)
    const chatSession = await manager.loadChatSession(sessionId, featureId)
    return chatSession?.messages || []
  }
)

ipcMain.handle(
  'session:addUserMessage',
  async (
    _event,
    projectRoot: string,
    sessionId: string,
    featureId: string,
    content: string
  ): Promise<void> => {
    const manager = getSessionManager(projectRoot)
    await manager.addMessage(sessionId, featureId, 'user', content)
  }
)

ipcMain.handle(
  'session:addAssistantMessage',
  async (
    _event,
    projectRoot: string,
    sessionId: string,
    featureId: string,
    content: string,
    metadata?: Record<string, unknown>
  ): Promise<void> => {
    const manager = getSessionManager(projectRoot)
    await manager.addMessage(sessionId, featureId, 'assistant', content, metadata)
  }
)
```

Note: Import ChatMessage from session types at top of file.

**preload/index.d.ts:**
Extend SessionAPI interface with:
```typescript
loadMessages: (
  projectRoot: string,
  sessionId: string,
  featureId: string
) => Promise<import('@shared/types/session').ChatMessage[]>

addUserMessage: (
  projectRoot: string,
  sessionId: string,
  featureId: string,
  content: string
) => Promise<void>

addAssistantMessage: (
  projectRoot: string,
  sessionId: string,
  featureId: string,
  content: string,
  metadata?: Record<string, unknown>
) => Promise<void>
```

**preload/index.ts:**
Add implementations in session object:
```typescript
loadMessages: (
  projectRoot: string,
  sessionId: string,
  featureId: string
): Promise<any[]> =>
  ipcRenderer.invoke('session:loadMessages', projectRoot, sessionId, featureId),

addUserMessage: (
  projectRoot: string,
  sessionId: string,
  featureId: string,
  content: string
): Promise<void> =>
  ipcRenderer.invoke('session:addUserMessage', projectRoot, sessionId, featureId, content),

addAssistantMessage: (
  projectRoot: string,
  sessionId: string,
  featureId: string,
  content: string,
  metadata?: Record<string, unknown>
): Promise<void> =>
  ipcRenderer.invoke('session:addAssistantMessage', projectRoot, sessionId, featureId, content, metadata)
```
  </action>
  <verify>npm run build succeeds with no TypeScript errors</verify>
  <done>IPC handlers for loadMessages, addUserMessage, addAssistantMessage are registered and accessible via preload API</done>
</task>

<task type="auto">
  <name>Task 2: Update PMAgentManager to use SessionManager</name>
  <files>src/main/agent/pm-agent-manager.ts</files>
  <action>
Migrate PMAgentManager from using FeatureStore.loadChat/saveChat to using SessionManager.

**Changes:**

1. **Add SessionManager import and dependency:**
   - Import SessionManager class and getSessionManager function
   - Import session types (ChatMessage from @shared/types/session)

2. **Update startPlanningForFeature method:**
   - At the start: Create/get a session for this feature
   ```typescript
   // Get session manager
   const { getSessionManager } = await import('../services/session-manager')
   const sessionManager = getSessionManager(this.projectRoot)

   // Create PM session for this feature
   const session = await sessionManager.getOrCreateSession({
     type: 'feature',
     agentType: 'pm',
     featureId
   })
   const sessionId = session.id
   ```

   - Replace `this.featureStore.loadChat(featureId)` with:
   ```typescript
   const chatSession = await sessionManager.loadChatSession(sessionId, featureId)
   let messages = chatSession?.messages || []
   ```

   - Replace `chatHistory.entries.push()` with:
   ```typescript
   await sessionManager.addMessage(sessionId, featureId, 'user', userMessage)
   ```

   - Replace adding assistant message inside stream event with:
   ```typescript
   await sessionManager.addMessage(sessionId, featureId, 'assistant', event.message.content)
   ```

   - Remove the `this.featureStore.saveChat()` calls - SessionManager saves automatically

3. **Remove unused imports:**
   - If ChatHistory type is no longer used from featureStore, remove its import

4. **Keep FeatureStore dependency for other operations:**
   - FeatureStore is still needed for loadDag, etc.
   - Only replace chat-specific operations

**Implementation pattern:**
- Session ID format for PM feature sessions: use sessionManager.getOrCreateSession which generates "feature-{featureId}-pm"
- Messages are added one at a time, not batched
- No need to manually call saveChat - addMessage handles persistence
  </action>
  <verify>npm run build succeeds, PMAgentManager uses sessionManager for message operations</verify>
  <done>PMAgentManager creates session at planning start and uses SessionManager for all message operations</done>
</task>

<task type="auto">
  <name>Task 3: Update chat-store to use session API</name>
  <files>src/renderer/src/stores/chat-store.ts</files>
  <action>
Migrate chat-store from using storage.loadChat/saveChat to using session API for PM chat.

**Key insight:** The chat-store needs to know the session ID. For PM feature chat, the session ID follows the pattern "feature-{featureId}-pm". We'll compute this in the store.

**Changes:**

1. **Add session ID tracking:**
   ```typescript
   interface ChatState {
     // ... existing fields
     sessionId: string | null  // Add this field
   }
   ```

2. **Add helper function to compute PM session ID:**
   ```typescript
   function getPMSessionId(featureId: string): string {
     return `feature-${featureId}-pm`
   }
   ```

3. **Update loadChat method:**
   - Compute sessionId from featureId
   - Store sessionId in state
   - Load messages from session API instead of storage API

   ```typescript
   loadChat: async (contextId: string, contextType: ChatContextType = 'feature') => {
     const sessionId = getPMSessionId(contextId)

     set({
       isLoading: true,
       messages: [],
       currentFeatureId: contextId,
       sessionId,  // Store session ID
       contextType,
       systemPrompt: null,
       contextLoaded: false
     })

     try {
       // Get project root from project store
       const projectRoot = useProjectStore.getState().projectPath

       if (contextType === 'feature' && projectRoot && window.electronAPI?.session?.loadMessages) {
         const messages = await window.electronAPI.session.loadMessages(
           projectRoot,
           sessionId,
           contextId
         )

         if (messages) {
           // Convert ChatMessage to internal ChatMessage format (add id if needed)
           const chatMessages: ChatMessage[] = messages.map((msg, index) => ({
             id: msg.id || `${contextId}-${index}-${msg.timestamp}`,
             role: msg.role === 'system' ? 'assistant' : msg.role, // Map system to assistant for display
             content: msg.content,
             timestamp: msg.timestamp
           }))
           set({ messages: chatMessages })
         }
       }

       // Context loading remains the same
       if (contextType === 'feature' && window.electronAPI?.chat?.getContext) {
         const contextResult = await window.electronAPI.chat.getContext(contextId)
         if (contextResult) {
           set({ systemPrompt: contextResult.systemPrompt, contextLoaded: true })
         }
       }

       set({ isLoading: false })
     } catch (error) {
       console.error('Failed to load chat:', error)
       toast.error('Failed to load chat history')
       set({ messages: [], isLoading: false })
     }
   }
   ```

4. **Update addMessage method:**
   - Use session API instead of storage API for persistence

   ```typescript
   addMessage: (message) => {
     const newMessage: ChatMessage = {
       ...message,
       id: crypto.randomUUID(),
       timestamp: new Date().toISOString()
     }

     // Update state with new message
     set((state) => ({
       messages: [...state.messages, newMessage]
     }))

     // Persist to session asynchronously
     const { currentFeatureId, sessionId } = get()
     const projectRoot = useProjectStore.getState().projectPath

     if (currentFeatureId && sessionId && projectRoot && window.electronAPI?.session?.addUserMessage) {
       // Only persist user messages here - assistant messages are handled in sendToAgent
       if (message.role === 'user') {
         window.electronAPI.session.addUserMessage(
           projectRoot,
           sessionId,
           currentFeatureId,
           message.content
         ).catch((err) => {
           console.error('Failed to save message to session:', err)
           toast.error('Failed to save chat message')
         })
       }
     }
   }
   ```

5. **Update sendToAgent method:**
   - Add assistant message to session after streaming completes

   In the `event.type === 'done'` handler:
   ```typescript
   // After adding assistant message to state, also save to session
   const { sessionId: sessId, currentFeatureId: featId } = get()
   const projectRoot = useProjectStore.getState().projectPath

   if (streamingContent && featId && sessId && projectRoot && window.electronAPI?.session?.addAssistantMessage) {
     window.electronAPI.session.addAssistantMessage(
       projectRoot,
       sessId,
       featId,
       streamingContent
     ).catch((err) => {
       console.error('Failed to save assistant message to session:', err)
     })
   }
   ```

6. **Update clearMessages method:**
   - For now, keep the old behavior (clear the storage)
   - Session clearing can be added later

7. **Keep backward compatibility:**
   - Keep the old storage calls as fallback if session API is not available
   - This ensures smooth migration

**Important notes:**
- The session API calls are fire-and-forget for persistence (don't await)
- Error handling catches persist failures but doesn't block UI
- System messages are mapped to assistant for display purposes
  </action>
  <verify>npm run build succeeds, chat-store uses session API for PM chat</verify>
  <done>Chat-store loads and saves PM chat messages via session API, session ID is tracked in state</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds with no errors
- [ ] IPC handlers registered: session:loadMessages, session:addUserMessage, session:addAssistantMessage
- [ ] Preload API exposes loadMessages, addUserMessage, addAssistantMessage
- [ ] PMAgentManager uses SessionManager for message operations
- [ ] chat-store computes sessionId from featureId
- [ ] chat-store uses session API for loading messages
- [ ] chat-store uses session API for saving user/assistant messages
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript compilation errors
- PM planning creates sessions and stores messages via SessionManager
- Interactive PM chat loads/saves via session API
- Session ID computed correctly for PM feature sessions
</success_criteria>

<output>
After completion, create `.planning/phases/v3.0-04-pm-agent-integration/04-01-SUMMARY.md`
</output>
