---
phase: v3.0-04-pm-agent-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/main/services/migration/chat-to-session.ts
  - src/main/ipc/session-handlers.ts
  - src/preload/index.d.ts
  - src/preload/index.ts
autonomous: true

must_haves:
  truths:
    - "Existing PM chat.json files can be migrated to session format"
    - "Migrated messages are accessible via session API"
    - "Original chat.json files are preserved as backup"
    - "Migration can be triggered via IPC from renderer"
  artifacts:
    - path: "src/main/services/migration/chat-to-session.ts"
      provides: "PM chat migration logic"
      exports: ["migratePMChat"]
      min_lines: 50
    - path: "src/main/ipc/session-handlers.ts"
      provides: "IPC handler for migration"
      contains: "session:migratePMChat"
    - path: "src/preload/index.d.ts"
      provides: "Type definition for migration API"
      contains: "migratePMChat"
  key_links:
    - from: "src/main/services/migration/chat-to-session.ts"
      to: "SessionManager"
      via: "creates session and adds migrated messages"
      pattern: "sessionManager\\.(getOrCreateSession|addMessage)"
    - from: "src/main/ipc/session-handlers.ts"
      to: "migratePMChat"
      via: "IPC handler calls migration function"
      pattern: "migratePMChat"
---

<objective>
Implement migration script to convert existing PM chat.json files to the new session format.

Purpose: Ensure users don't lose their existing PM chat history when upgrading. The migration preserves all messages and creates proper session structure.

Output:
- Migration function that reads old chat.json and creates new session
- IPC handler to trigger migration from renderer
- Backup of original files before migration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v3.0-session-checkpoint-ROADMAP.md
@.planning/STATE.md
@.planning/phases/v3.0-04-pm-agent-integration/04-01-PLAN.md

# Relevant source files:
@src/main/services/session-manager.ts
@src/main/storage/feature-store.ts
@src/shared/types/session.ts
@src/shared/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PM chat migration service</name>
  <files>src/main/services/migration/chat-to-session.ts</files>
  <action>
Create a new migration service that converts old chat.json files to session format.

**Create directory and file:** `src/main/services/migration/chat-to-session.ts`

```typescript
/**
 * Chat to Session Migration Service
 *
 * Migrates old chat.json files from FeatureStore format to new SessionManager format.
 * Preserves all messages and creates proper session structure.
 */

import * as fs from 'fs/promises'
import * as path from 'path'
import { getSessionManager } from '../session-manager'
import { getFeatureDir } from '../../storage/paths'
import type { ChatHistory, ChatEntry } from '@shared/types'
import type { CreateSessionOptions } from '@shared/types/session'

export interface MigrationResult {
  success: boolean
  featureId: string
  messagesImported: number
  sessionId?: string
  error?: string
  backupPath?: string
}

/**
 * Migrate PM chat for a single feature from old format to session format.
 *
 * @param projectRoot - Project root directory
 * @param featureId - Feature ID to migrate
 * @returns Migration result
 */
export async function migratePMChat(
  projectRoot: string,
  featureId: string
): Promise<MigrationResult> {
  try {
    // 1. Check if old chat.json exists
    const featureDir = getFeatureDir(projectRoot, featureId)
    const oldChatPath = path.join(featureDir, 'chat.json')

    try {
      await fs.access(oldChatPath)
    } catch {
      // No old chat file, nothing to migrate
      return {
        success: true,
        featureId,
        messagesImported: 0
      }
    }

    // 2. Read old chat.json
    const oldChatContent = await fs.readFile(oldChatPath, 'utf-8')
    const oldChat: ChatHistory = JSON.parse(oldChatContent)

    if (!oldChat.entries || oldChat.entries.length === 0) {
      return {
        success: true,
        featureId,
        messagesImported: 0
      }
    }

    // 3. Create backup before migration
    const backupPath = path.join(featureDir, 'chat.json.backup')
    await fs.copyFile(oldChatPath, backupPath)

    // 4. Get or create session
    const sessionManager = getSessionManager(projectRoot)
    const sessionOptions: CreateSessionOptions = {
      type: 'feature',
      agentType: 'pm',
      featureId
    }
    const session = await sessionManager.getOrCreateSession(sessionOptions)

    // 5. Add each message to session
    let messagesImported = 0
    for (const entry of oldChat.entries) {
      // Map old ChatEntry to session message
      const role = entry.role === 'user' ? 'user' : 'assistant'

      await sessionManager.addMessage(
        session.id,
        featureId,
        role,
        entry.content,
        {
          migratedFrom: 'chat.json',
          originalTimestamp: entry.timestamp
        }
      )
      messagesImported++
    }

    // 6. Optionally create initial checkpoint from imported messages
    // For now, let natural compaction handle this

    console.log(`[Migration] Migrated ${messagesImported} messages for feature ${featureId}`)

    return {
      success: true,
      featureId,
      messagesImported,
      sessionId: session.id,
      backupPath
    }
  } catch (error) {
    console.error(`[Migration] Failed to migrate PM chat for ${featureId}:`, error)
    return {
      success: false,
      featureId,
      messagesImported: 0,
      error: (error as Error).message
    }
  }
}

/**
 * Migrate PM chats for all features in a project.
 *
 * @param projectRoot - Project root directory
 * @returns Array of migration results
 */
export async function migrateAllPMChats(
  projectRoot: string
): Promise<MigrationResult[]> {
  const results: MigrationResult[] = []

  try {
    // Find all feature directories
    const dagentDir = path.join(projectRoot, '.dagent', 'features')

    try {
      await fs.access(dagentDir)
    } catch {
      // No features directory
      return results
    }

    const entries = await fs.readdir(dagentDir, { withFileTypes: true })
    const featureDirs = entries.filter((e) => e.isDirectory())

    // Migrate each feature
    for (const dir of featureDirs) {
      const featureId = dir.name
      const result = await migratePMChat(projectRoot, featureId)
      results.push(result)
    }

    const successful = results.filter((r) => r.success).length
    const failed = results.filter((r) => !r.success).length
    console.log(`[Migration] Completed: ${successful} succeeded, ${failed} failed`)

    return results
  } catch (error) {
    console.error('[Migration] Failed to migrate all PM chats:', error)
    return results
  }
}

/**
 * Check if a feature needs migration.
 *
 * @param projectRoot - Project root directory
 * @param featureId - Feature ID to check
 * @returns True if old chat.json exists and session doesn't
 */
export async function needsMigration(
  projectRoot: string,
  featureId: string
): Promise<boolean> {
  try {
    const featureDir = getFeatureDir(projectRoot, featureId)
    const oldChatPath = path.join(featureDir, 'chat.json')

    // Check if old chat exists
    try {
      await fs.access(oldChatPath)
    } catch {
      return false // No old chat, no migration needed
    }

    // Check if session already exists
    const sessionManager = getSessionManager(projectRoot)
    const sessionId = `feature-${featureId}-pm`
    const session = await sessionManager.loadSession(sessionId, featureId)

    // Need migration if old chat exists but session doesn't
    return session === null
  } catch {
    return false
  }
}
```

**Note:** The `getFeatureDir` function is imported from storage/paths.ts. If it doesn't exist, create a helper function inline that computes the path as `path.join(projectRoot, '.dagent', 'features', featureId)`.
  </action>
  <verify>npm run build succeeds, migration module compiles without errors</verify>
  <done>Migration service created with migratePMChat, migrateAllPMChats, and needsMigration functions</done>
</task>

<task type="auto">
  <name>Task 2: Add IPC handlers for migration</name>
  <files>src/main/ipc/session-handlers.ts, src/preload/index.d.ts, src/preload/index.ts</files>
  <action>
Add IPC handlers to trigger migration from the renderer process.

**session-handlers.ts:**
Add import at top:
```typescript
import { migratePMChat, migrateAllPMChats, needsMigration, MigrationResult } from '../services/migration/chat-to-session'
```

Add three new IPC handlers:

```typescript
ipcMain.handle(
  'session:migratePMChat',
  async (
    _event,
    projectRoot: string,
    featureId: string
  ): Promise<MigrationResult> => {
    return await migratePMChat(projectRoot, featureId)
  }
)

ipcMain.handle(
  'session:migrateAllPMChats',
  async (
    _event,
    projectRoot: string
  ): Promise<MigrationResult[]> => {
    return await migrateAllPMChats(projectRoot)
  }
)

ipcMain.handle(
  'session:needsMigration',
  async (
    _event,
    projectRoot: string,
    featureId: string
  ): Promise<boolean> => {
    return await needsMigration(projectRoot, featureId)
  }
)
```

**preload/index.d.ts:**
Extend SessionAPI interface with:
```typescript
migratePMChat: (
  projectRoot: string,
  featureId: string
) => Promise<{
  success: boolean
  featureId: string
  messagesImported: number
  sessionId?: string
  error?: string
  backupPath?: string
}>

migrateAllPMChats: (
  projectRoot: string
) => Promise<Array<{
  success: boolean
  featureId: string
  messagesImported: number
  sessionId?: string
  error?: string
  backupPath?: string
}>>

needsMigration: (
  projectRoot: string,
  featureId: string
) => Promise<boolean>
```

**preload/index.ts:**
Add implementations in session object:
```typescript
migratePMChat: (
  projectRoot: string,
  featureId: string
): Promise<any> =>
  ipcRenderer.invoke('session:migratePMChat', projectRoot, featureId),

migrateAllPMChats: (
  projectRoot: string
): Promise<any[]> =>
  ipcRenderer.invoke('session:migrateAllPMChats', projectRoot),

needsMigration: (
  projectRoot: string,
  featureId: string
): Promise<boolean> =>
  ipcRenderer.invoke('session:needsMigration', projectRoot, featureId)
```
  </action>
  <verify>npm run build succeeds, IPC handlers registered, preload API matches types</verify>
  <done>IPC handlers for migration operations are registered and accessible via preload API</done>
</task>

<task type="auto">
  <name>Task 3: Add auto-migration on chat load</name>
  <files>src/renderer/src/stores/chat-store.ts</files>
  <action>
Update chat-store to automatically trigger migration when loading a chat if needed.

**In loadChat method, add migration check before loading:**

After setting initial state but before loading messages:
```typescript
loadChat: async (contextId: string, contextType: ChatContextType = 'feature') => {
  const sessionId = getPMSessionId(contextId)

  set({
    isLoading: true,
    messages: [],
    currentFeatureId: contextId,
    sessionId,
    contextType,
    systemPrompt: null,
    contextLoaded: false
  })

  try {
    const projectRoot = useProjectStore.getState().projectPath

    // Check if migration is needed and perform it
    if (contextType === 'feature' && projectRoot && window.electronAPI?.session?.needsMigration) {
      try {
        const needsMigration = await window.electronAPI.session.needsMigration(projectRoot, contextId)
        if (needsMigration && window.electronAPI?.session?.migratePMChat) {
          console.log('[ChatStore] Migrating old chat format for', contextId)
          const result = await window.electronAPI.session.migratePMChat(projectRoot, contextId)
          if (result.success) {
            console.log('[ChatStore] Migration successful:', result.messagesImported, 'messages imported')
          } else {
            console.error('[ChatStore] Migration failed:', result.error)
          }
        }
      } catch (migrationError) {
        console.error('[ChatStore] Migration check failed:', migrationError)
        // Continue loading - migration is optional
      }
    }

    // Load messages from session API (rest of existing code)
    if (contextType === 'feature' && projectRoot && window.electronAPI?.session?.loadMessages) {
      // ... existing loadMessages code
    }
    // ... rest of loadChat
  } catch (error) {
    // ... existing error handling
  }
}
```

**Notes:**
- Migration is transparent to the user
- If migration fails, fall back to session API which may return empty (not break)
- Migration is idempotent - won't re-migrate if already done
- Log messages help with debugging
  </action>
  <verify>npm run build succeeds, auto-migration logic is in place</verify>
  <done>Chat-store automatically migrates old chat.json when loading a feature chat for the first time</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds with no errors
- [ ] Migration service created at src/main/services/migration/chat-to-session.ts
- [ ] IPC handlers registered: session:migratePMChat, session:migrateAllPMChats, session:needsMigration
- [ ] Preload API exposes migration methods
- [ ] chat-store performs auto-migration on load when needed
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript compilation errors
- Migration reads old chat.json and imports messages to session
- Original chat.json backed up before migration
- Auto-migration triggers on first chat load after upgrade
</success_criteria>

<output>
After completion, create `.planning/phases/v3.0-04-pm-agent-integration/04-02-SUMMARY.md`
</output>
