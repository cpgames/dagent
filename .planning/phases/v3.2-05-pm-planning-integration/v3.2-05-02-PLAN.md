---
phase: v3.2-05-pm-planning-integration
plan: 02
type: execute
wave: 2
depends_on: ["v3.2-05-01"]
files_modified:
  - src/renderer/src/components/Feature/FeatureSpecViewer.tsx
  - src/main/ipc/pm-spec-handlers.ts
  - src/preload/index.ts
  - src/preload/index.d.ts
autonomous: true

must_haves:
  truths:
    - "Feature spec updates in real-time via events (not just polling)"
    - "FeatureSpecViewer subscribes to spec:updated events"
    - "PM spec changes broadcast to all renderer windows"
  artifacts:
    - path: "src/renderer/src/components/Feature/FeatureSpecViewer.tsx"
      provides: "Event-based spec updates"
      contains: "spec:updated"
    - path: "src/main/ipc/pm-spec-handlers.ts"
      provides: "Broadcast spec updates"
      contains: "spec:updated"
  key_links:
    - from: "src/main/ipc/pm-spec-handlers.ts"
      to: "FeatureSpecViewer"
      via: "IPC event broadcast"
      pattern: "webContents.send.*spec:updated"
---

<objective>
Enable real-time spec updates in FeatureSpecViewer via event subscription instead of just polling.

Purpose: Spec changes appear instantly during PM conversation (SPEC-01, SPEC-04), improving user experience during the planning phases.

Output: Modified FeatureSpecViewer with event subscription, updated pm-spec-handlers to broadcast changes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/v3.2-05-pm-planning-integration/v3.2-05-01-SUMMARY.md

@src/renderer/src/components/Feature/FeatureSpecViewer.tsx
@src/main/ipc/pm-spec-handlers.ts
@src/preload/index.ts
@src/preload/index.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Broadcast spec updates from IPC handlers</name>
  <files>src/main/ipc/pm-spec-handlers.ts</files>
  <action>
In the pm-spec-handlers.ts file, after the spec is created or updated, broadcast an event to all renderer windows.

1. Import BrowserWindow at the top:
```typescript
import { BrowserWindow } from 'electron'
```

2. In the `pm-spec:createSpec` handler, after spec is created successfully, add:
```typescript
// Broadcast spec update to all windows
const windows = BrowserWindow.getAllWindows()
for (const win of windows) {
  if (!win.isDestroyed()) {
    win.webContents.send('spec:updated', { featureId: input.featureId })
  }
}
```

3. In the `pm-spec:updateSpec` handler, after spec is updated successfully, add the same broadcast code:
```typescript
// Broadcast spec update to all windows
const windows = BrowserWindow.getAllWindows()
for (const win of windows) {
  if (!win.isDestroyed()) {
    win.webContents.send('spec:updated', { featureId: input.featureId })
  }
}
```
  </action>
  <verify>npm run typecheck:node</verify>
  <done>Spec create/update operations broadcast spec:updated event to all windows</done>
</task>

<task type="auto">
  <name>Task 2: Add spec event listener to preload</name>
  <files>src/preload/index.ts, src/preload/index.d.ts</files>
  <action>
1. In src/preload/index.ts, find the pmSpec object in contextBridge.exposeInMainWorld and add an onUpdated listener:

```typescript
pmSpec: {
  createSpec: (input: CreateSpecInput) => ipcRenderer.invoke('pm-spec:createSpec', input),
  updateSpec: (input: UpdateSpecInput) => ipcRenderer.invoke('pm-spec:updateSpec', input),
  getSpec: (input: { featureId: string }) => ipcRenderer.invoke('pm-spec:getSpec', input),
  // Add this:
  onUpdated: (callback: (data: { featureId: string }) => void) => {
    const handler = (_event: Electron.IpcRendererEvent, data: { featureId: string }) => callback(data)
    ipcRenderer.on('spec:updated', handler)
    return () => ipcRenderer.removeListener('spec:updated', handler)
  }
}
```

2. In src/preload/index.d.ts, update the pmSpec type to include the new method:

Find the pmSpec interface and add:
```typescript
onUpdated: (callback: (data: { featureId: string }) => void) => () => void
```
  </action>
  <verify>npm run typecheck:node</verify>
  <done>Preload exposes spec:updated event listener to renderer</done>
</task>

<task type="auto">
  <name>Task 3: Subscribe FeatureSpecViewer to spec events</name>
  <files>src/renderer/src/components/Feature/FeatureSpecViewer.tsx</files>
  <action>
1. Add an effect to subscribe to spec:updated events for the current feature:

```typescript
// Subscribe to spec updates for real-time refresh
useEffect(() => {
  if (!window.electronAPI?.pmSpec?.onUpdated) return

  const unsubscribe = window.electronAPI.pmSpec.onUpdated((data) => {
    // Only reload if the update is for this feature
    if (data.featureId === featureId) {
      loadSpec()
    }
  })

  return unsubscribe
}, [featureId, loadSpec])
```

Add this effect AFTER the existing polling effect (around line 86).

2. Optionally reduce the polling interval from 5000ms to 10000ms since we now have event-based updates for faster response and polling serves as a fallback:

Change:
```typescript
const interval = setInterval(loadSpec, 5000)
```
To:
```typescript
const interval = setInterval(loadSpec, 10000) // Fallback polling, events provide real-time updates
```
  </action>
  <verify>npm run typecheck:web</verify>
  <done>FeatureSpecViewer updates in real-time when spec changes via events</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run typecheck passes (both :node and :web)
- [ ] npm run build succeeds
- [ ] No console errors when starting app
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Spec updates appear immediately when PM modifies them
- Polling serves as fallback for missed events
</success_criteria>

<output>
After completion, create `.planning/phases/v3.2-05-pm-planning-integration/v3.2-05-02-SUMMARY.md`
</output>
