---
phase: 43-pool-management
plan: 01
title: TaskPoolManager and Orchestrator Integration
subsystem: dag-engine
tags: [pools, task-assignment, orchestrator]

# Dependency graph
requires:
  - phase: 42-task-state-refactor
    plan: 02
    provides: TaskStatus with dev/qa states, ACTIVE_STATUSES constant
provides:
  - TaskPoolManager class with O(1) lookups
  - Pool-based assignment in orchestrator
  - Priority: merging > qa > ready
affects: [44-qa-agent, 45-communication-refactor]

# Research requirements
research:
  needed: false
---

<objective>
Create pool-based task management for efficient assignment and prioritization.

Purpose: Organize tasks by state into pools for O(1) lookups and priority-based assignment. Currently the orchestrator filters nodes by status on every tick - pools provide indexed access.

Output: TaskPoolManager class integrated with orchestrator for optimized task assignment.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/42-task-state-refactor/42-01-SUMMARY.md
@.planning/phases/42-task-state-refactor/42-02-SUMMARY.md

# Key files:
@src/shared/types/task.ts
@src/main/dag-engine/orchestrator.ts
@src/main/dag-engine/analyzer.ts

**Tech stack available:**
- TaskStatus: 'blocked' | 'ready' | 'dev' | 'qa' | 'merging' | 'completed' | 'failed'
- ACTIVE_STATUSES constant in analyzer.ts

**Established patterns:**
- Orchestrator tick loop for periodic checks
- State machine transitions via transitionTask()
- getReadyTasks() in analyzer.ts for ready task lookup

**Constraining decisions:**
- Phase 42: TaskStatus now uses dev/qa instead of running
- Phase 42: ACTIVE_STATUSES = ['dev', 'qa', 'merging']
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskPoolManager Class</name>
  <files>src/main/dag-engine/task-pool.ts</files>
  <action>
Create TaskPoolManager class with:

1. **Pool structure** - Map from TaskStatus to Set of taskIds:
```typescript
private pools: Map<TaskStatus, Set<string>> = new Map([
  ['blocked', new Set()],
  ['ready', new Set()],
  ['dev', new Set()],
  ['qa', new Set()],
  ['merging', new Set()],
  ['completed', new Set()],
  ['failed', new Set()]
])
```

2. **Initialize from graph** - `initializeFromGraph(graph: DAGGraph)`:
   - Clear all pools
   - Iterate nodes, add each taskId to appropriate pool based on status

3. **Move between pools** - `moveTask(taskId: string, fromStatus: TaskStatus, toStatus: TaskStatus)`:
   - Remove from old pool, add to new pool
   - Return boolean success

4. **Get pool contents** - `getPool(status: TaskStatus): string[]`:
   - Return array of taskIds in that pool

5. **Get next assignable task** - `getNextTask(): string | null`:
   - Priority order: merging > qa > ready
   - Return first taskId from highest priority non-empty pool
   - Return null if no tasks available

6. **Pool counts** - `getCounts(): Record<TaskStatus, number>`:
   - Return object with count for each pool

Export singleton pattern: `getTaskPoolManager()` and `resetTaskPoolManager()` for testing.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit -p tsconfig.node.json`</verify>
  <done>TaskPoolManager class exists with all methods, type-checks successfully</done>
</task>

<task type="auto">
  <name>Task 2: Integrate TaskPoolManager with Orchestrator</name>
  <files>src/main/dag-engine/orchestrator.ts</files>
  <action>
Update orchestrator to use TaskPoolManager:

1. **Import** - Add import for getTaskPoolManager, resetTaskPoolManager

2. **Initialize pools on start** - In `initialize()` method:
   - After `recalculateAllStatuses(graph)`, call `getTaskPoolManager().initializeFromGraph(graph)`

3. **Update pools on state change** - When task status changes (via transitionTask):
   - After successful transition, call `poolManager.moveTask(taskId, previousStatus, newStatus)`
   - This applies to: assignTask(), completeTaskCode(), completeMerge(), failTask()

4. **Update getNextTasks()** - Instead of filtering all nodes:
   - Use `poolManager.getPool('ready')` to get ready tasks
   - Existing filtering logic (assigned, failed this tick) still applies
   - Keep the canAssign calculation using ACTIVE_STATUSES count

5. **Cleanup on stop** - In `stop()` method:
   - Call `resetTaskPoolManager()` to clear pools

Note: Keep existing getReadyTasks() call in analyzer.ts as fallback/verification - pools are an optimization, not a replacement of the source of truth.
  </action>
  <verify>
Build succeeds: `npm run build`
Pools initialized when execution starts
  </verify>
  <done>
- Orchestrator initializes pools from graph
- State changes update pools
- getNextTasks() uses pool for ready tasks
- Build passes with no errors
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] TypeScript compilation passes
- [ ] TaskPoolManager class exists with all methods
- [ ] Orchestrator uses pools for task lookup
- [ ] State transitions update pools correctly
</verification>

<success_criteria>

- TaskPoolManager class created with pool structure
- Orchestrator integrates pools for O(1) ready task lookup
- State changes properly move tasks between pools
- Priority order respected: merging > qa > ready
- All verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/43-pool-management/43-01-SUMMARY.md` following the summary template.
</output>
