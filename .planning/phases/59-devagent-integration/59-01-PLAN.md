---
phase: 59-devagent-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/agents/dev-types.ts
  - src/main/agents/dev-agent.ts
  - src/main/dag-engine/task-controller.ts
autonomous: true
must_haves:
  truths:
    - "TaskController can spawn DevAgent in iteration mode"
    - "DevAgent in iteration mode skips intention-approval workflow"
    - "DevAgent in iteration mode uses focused prompt from TaskController"
    - "DevAgent can execute directly without worktree creation when worktree exists"
  artifacts:
    - path: "src/main/agents/dev-types.ts"
      provides: "Iteration mode configuration"
      exports: ["DevAgentConfig.iterationMode", "DevAgentConfig.iterationPrompt", "DevAgentConfig.worktreePath"]
    - path: "src/main/agents/dev-agent.ts"
      provides: "Iteration execution method"
      exports: ["DevAgent.executeIteration"]
    - path: "src/main/dag-engine/task-controller.ts"
      provides: "Updated spawnDevAgent using iteration mode"
  key_links:
    - from: "task-controller.ts"
      to: "dev-agent.ts"
      via: "createDevAgent with iterationMode"
      pattern: "iterationMode.*true"
    - from: "dev-agent.ts"
      to: "agentService.streamQuery"
      via: "executeIteration bypasses approval"
      pattern: "executeIteration"
---

<objective>
Add iteration mode to DevAgent for integration with TaskController's Ralph Loop.

Purpose: Enable DevAgent to operate in two modes - standard mode (full intention-approval workflow) and iteration mode (streamlined execution with TaskController-provided prompt). This allows TaskController to spawn fresh DevAgents each iteration without the overhead of intention-approval workflow.

Output: DevAgent with executeIteration() method, iteration config options, updated TaskController integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v2.4-ROADMAP.md

Prior phase summaries (used directly by this plan):
@.planning/phases/56-task-plan-infrastructure/56-01-SUMMARY.md
@.planning/phases/57-verification-runner/57-01-SUMMARY.md
@.planning/phases/58-task-controller/58-01-SUMMARY.md

Source files this plan modifies:
@src/main/agents/dev-types.ts
@src/main/agents/dev-agent.ts
@src/main/dag-engine/task-controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Iteration Mode Config to DevAgent Types</name>
  <files>src/main/agents/dev-types.ts</files>
  <action>
Add iteration mode configuration options to DevAgentConfig:

1. **Add to DevAgentConfig interface:**
   - iterationMode: boolean (default false) - When true, agent operates in iteration mode
   - iterationPrompt: string | undefined - Custom prompt from TaskController (used in iteration mode)
   - existingWorktreePath: string | undefined - Pre-existing worktree path (skip worktree creation)

2. **Update DEFAULT_DEV_AGENT_CONFIG:**
   - iterationMode: false
   - iterationPrompt: undefined
   - existingWorktreePath: undefined

These fields enable TaskController to spawn DevAgents that:
- Skip the full intention-approval workflow
- Use a provided prompt instead of generating one
- Use an existing worktree instead of creating a new one
  </action>
  <verify>npm run typecheck passes</verify>
  <done>DevAgentConfig includes iterationMode, iterationPrompt, and existingWorktreePath fields</done>
</task>

<task type="auto">
  <name>Task 2: Add executeIteration Method to DevAgent</name>
  <files>src/main/agents/dev-agent.ts</files>
  <action>
Add new executeIteration() method for iteration mode execution:

1. **Add executeIteration(prompt: string): Promise<TaskExecutionResult>**
   - Called by TaskController in iteration mode
   - Bypasses intention-approval workflow entirely
   - Uses provided prompt directly
   - Sets status to 'working' and runs SDK
   - Returns TaskExecutionResult (success/fail with summary)
   - Does NOT publish MessageBus messages (TaskController handles communication)

2. **Modify initialize() method:**
   - If config.existingWorktreePath is set, skip worktree creation
   - Use provided worktreePath directly
   - Still set up context but don't create new worktree

3. **Add initializeForIteration(task: Task, graph: DAGGraph, worktreePath: string, claudeMd?: string, featureGoal?: string): Promise<boolean>**
   - Simplified initialization for iteration mode
   - Accepts existing worktreePath (no creation)
   - Sets up context without full intention workflow setup
   - Does NOT register with MessageBus or agent pool (TaskController manages lifecycle)

4. **executeIteration() implementation:**
   ```typescript
   async executeIteration(prompt: string): Promise<TaskExecutionResult> {
     if (this.state.status !== 'initializing' && this.state.status !== 'loading_context') {
       return { success: false, taskId: this.state.taskId, error: 'Invalid state for iteration' }
     }

     this.state.status = 'working'
     this.emit('dev-agent:executing')

     try {
       // Build execution prompt - use provided prompt from TaskController
       // Execute via SDK in the worktree
       const agentService = getAgentService()
       let summary = ''

       for await (const event of agentService.streamQuery({
         prompt,
         toolPreset: 'taskAgent',
         permissionMode: 'bypassPermissions',
         cwd: this.state.worktreePath!,
         agentType: 'task',
         agentId: `dev-iter-${this.state.taskId}`,
         taskId: this.state.taskId,
         priority: RequestPriority.DEV
       })) {
         // Handle events same as execute()
         // ...
       }

       this.state.status = 'ready_for_merge'
       return { success: true, taskId: this.state.taskId, summary }
     } catch (error) {
       this.state.status = 'failed'
       this.state.error = (error as Error).message
       return { success: false, taskId: this.state.taskId, error: this.state.error }
     }
   }
   ```

Key difference from execute():
- No intention-approval workflow
- Uses prompt parameter directly instead of buildExecutionPrompt()
- No MessageBus publishing (TaskController handles this)
- Simpler status flow: working â†’ ready_for_merge or failed
  </action>
  <verify>npm run typecheck passes</verify>
  <done>DevAgent has executeIteration() and initializeForIteration() methods that bypass intention workflow</done>
</task>

<task type="auto">
  <name>Task 3: Update TaskController to Use Iteration Mode</name>
  <files>src/main/dag-engine/task-controller.ts</files>
  <action>
Update TaskController.spawnDevAgent() to use the new iteration mode:

1. **Modify spawnDevAgent() to use initializeForIteration():**
   - On first iteration: use existing initialize() to create worktree
   - On subsequent iterations: use initializeForIteration() with existing worktreePath
   - Call executeIteration(prompt) instead of proposeIntention() + waiting for events

2. **Update spawnDevAgent implementation:**
   ```typescript
   private async spawnDevAgent(prompt: string): Promise<TaskExecutionResult> {
     // Clean up previous agent if exists
     if (this.currentDevAgent) {
       await this.currentDevAgent.cleanup(false)
       this.currentDevAgent = null
     }

     // Create fresh DevAgent with iteration config
     const agent = createDevAgent(this.state.featureId, this.state.taskId, {
       autoPropose: false,
       autoExecute: false,
       iterationMode: true
     })
     this.currentDevAgent = agent

     try {
       if (this.state.currentIteration === 1) {
         // First iteration: create worktree via standard initialize
         const initialized = await agent.initialize(
           this.task!,
           this.graph!,
           this.claudeMd,
           this.featureGoal
         )
         if (!initialized) {
           return { success: false, taskId: this.state.taskId, error: agent.getState().error }
         }
         this.state.worktreePath = agent.getState().worktreePath
       } else {
         // Subsequent iterations: use existing worktree
         const initialized = await agent.initializeForIteration(
           this.task!,
           this.graph!,
           this.state.worktreePath!,
           this.claudeMd,
           this.featureGoal
         )
         if (!initialized) {
           return { success: false, taskId: this.state.taskId, error: agent.getState().error }
         }
       }

       // Execute directly with iteration prompt (no intention workflow)
       return await agent.executeIteration(prompt)
     } catch (error) {
       return { success: false, taskId: this.state.taskId, error: (error as Error).message }
     }
   }
   ```

3. **Remove the Promise-based event listening:**
   Since executeIteration() returns directly, we don't need the on('dev-agent:ready_for_merge') pattern.

Key benefits:
- Cleaner iteration flow without event callbacks
- First iteration creates worktree, subsequent use existing
- Direct return from executeIteration() simplifies control flow
  </action>
  <verify>npm run typecheck passes</verify>
  <done>TaskController.spawnDevAgent() uses iteration mode with direct execution</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run typecheck passes
- [ ] DevAgentConfig has iterationMode, iterationPrompt, existingWorktreePath fields
- [ ] DevAgent has initializeForIteration() method
- [ ] DevAgent has executeIteration() method
- [ ] TaskController.spawnDevAgent() uses iteration mode
- [ ] First iteration creates worktree, subsequent iterations reuse it
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- DevAgent can operate in iteration mode without intention workflow
- TaskController integrates cleanly with iteration mode
- No changes to existing standard mode behavior
</success_criteria>

<output>
After completion, create `.planning/phases/59-devagent-integration/59-01-SUMMARY.md`
</output>
