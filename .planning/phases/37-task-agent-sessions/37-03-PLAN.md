---
phase: 37-task-agent-sessions
plan: 03
type: execute
---

<objective>
Add session loading for task resume and IPC handlers for UI access.

Purpose: Enable tasks to resume with existing session context, and expose sessions to renderer for Phase 40 (Log UI).
Output: TaskAgent loads session on resume, IPC handlers expose session data to renderer.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/37-task-agent-sessions/37-01-SUMMARY.md
@.planning/phases/37-task-agent-sessions/37-02-SUMMARY.md

**Key files from prior plans:**
@src/shared/types/log.ts
@src/main/storage/feature-store.ts
@src/main/agents/task-agent.ts

**Tech stack available:** TaskAgentSession, TaskAgentMessage, appendSessionMessage(), loadTaskSession()
**Established patterns:** Session stored at `.dagent/nodes/{taskId}/session.json`, bidirectional messages
</context>

<tasks>

<task type="auto">
  <name>Task 1: Load existing session on TaskAgent initialize</name>
  <files>src/main/agents/task-agent.ts</files>
  <action>
In the `initialize()` method, after context is loaded and before logging initialization:
1. Attempt to load existing session via store.loadTaskSession(featureId, taskId)
2. If session exists with status 'active' or 'paused':
   - Log 'Task agent resuming from existing session'
   - Continue with loaded session (appendSessionMessage will add to it)
3. If no session exists or status is 'completed'/'failed':
   - Start fresh session (existing behavior)

This enables task resume with full conversation history preserved.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>TaskAgent detects and logs when resuming from existing session</done>
</task>

<task type="auto">
  <name>Task 2: Add session IPC handlers</name>
  <files>src/main/ipc/storage-handlers.ts, src/preload/index.ts</files>
  <action>
In storage-handlers.ts, add handlers:
1. `storage:loadTaskSession` - Takes featureId and taskId, returns TaskAgentSession | null
2. `storage:listTaskSessions` - Takes featureId, returns array of taskIds that have sessions

In preload/index.ts, expose:
1. `storage.loadTaskSession(featureId, taskId)` - Returns Promise<TaskAgentSession | null>
2. `storage.listTaskSessions(featureId)` - Returns Promise<string[]>

Import TaskAgentSession type in preload for proper typing.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>IPC handlers registered and exposed via preload API</done>
</task>

<task type="auto">
  <name>Task 3: Add listTaskSessions to FeatureStore</name>
  <files>src/main/storage/feature-store.ts</files>
  <action>
Add method `listTaskSessions(featureId: string): Promise<string[]>`:
1. Get nodes directory path: `.dagent/worktrees/{featureId}/nodes/`
2. Read directory entries
3. For each subdirectory, check if session.json exists
4. Return array of taskIds that have sessions

This enables UI to discover which tasks have session history.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>FeatureStore.listTaskSessions returns taskIds with sessions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] TaskAgent logs "resuming" message when session exists
- [ ] IPC handlers registered for loadTaskSession and listTaskSessions
- [ ] Preload API exposes session methods
</verification>

<success_criteria>
- All tasks completed
- TaskAgent can resume from existing session
- Session data accessible from renderer via IPC
- No regressions in task execution flow
- Phase 37 scope from roadmap fully complete
</success_criteria>

<output>
After completion, create `.planning/phases/37-task-agent-sessions/37-03-SUMMARY.md`
</output>
