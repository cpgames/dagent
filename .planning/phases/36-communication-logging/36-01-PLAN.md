# Phase 36-01: Communication Logging

## Goal

Persist all agent communications to `harness_log.json` in real-time. The HarnessAgent already creates in-memory HarnessMessage objects and emits events, but nothing persists them. This plan wires up persistence so logs are written as events occur and viewable via LogDialog.

## Context

From Phase 35: The intention-approval workflow is wired in the orchestrator. HarnessAgent creates log messages for:
- `intention_received` - Task agent proposes intention
- `approval_sent` - PM approves intention
- `rejection_sent` - PM rejects intention
- `task_started` - Agent assigned to task
- `task_completed` - Task finished successfully
- `task_failed` - Task failed with error
- `info`, `warning`, `error` - General status messages

These are stored in `messageHistory[]` array and emitted via `harness:message` events, but NOT persisted to disk.

## Existing Infrastructure

1. **HarnessMessage type** (harness-types.ts):
   ```typescript
   type: 'intention_received' | 'approval_sent' | 'rejection_sent' | 'task_started' | 'task_completed' | 'task_failed' | 'info' | 'warning' | 'error'
   ```

2. **LogEntryType** (log.ts):
   ```typescript
   type: 'intention' | 'approval' | 'rejection' | 'modification' | 'action' | 'error' | 'pm-query' | 'pm-response'
   ```

3. **Storage methods** (feature-store.ts):
   - `saveHarnessLog(featureId, log)` - Writes entire AgentLog
   - `loadHarnessLog(featureId)` - Reads AgentLog

4. **Path utility** (paths.ts):
   - `getHarnessLogPath()` - Returns `.dagent/harness_log.json` path

## Tasks

### Task 1: Add log entry type mappings

Add new LogEntryType values to support all HarnessMessage types. Create a mapping function.

**File:** `src/shared/types/log.ts`

Add types: `'task_started'`, `'task_completed'`, `'task_failed'`, `'info'`, `'warning'`

**File:** `src/main/agents/harness-agent.ts`

Add helper to convert HarnessMessage to LogEntry:

```typescript
private toLogEntry(msg: HarnessMessage): LogEntry {
  const typeMap: Record<HarnessMessage['type'], LogEntryType> = {
    'intention_received': 'intention',
    'approval_sent': 'approval',
    'rejection_sent': 'rejection',
    'task_started': 'task_started',
    'task_completed': 'task_completed',
    'task_failed': 'task_failed',
    'info': 'info',
    'warning': 'warning',
    'error': 'error'
  }
  return {
    timestamp: msg.timestamp,
    type: typeMap[msg.type],
    agent: 'harness',
    taskId: msg.taskId,
    content: msg.content
  }
}
```

### Task 2: Add log persistence service

Create a LogService class to handle appending entries to harness_log.json without rewriting entire file each time.

**File:** `src/main/storage/log-service.ts` (new)

```typescript
import { getStore } from './feature-store'
import type { LogEntry, AgentLog } from '@shared/types'

class LogService {
  private cache: Map<string, LogEntry[]> = new Map()

  async appendEntry(featureId: string, entry: LogEntry): Promise<void> {
    // Load existing or use cache
    let entries = this.cache.get(featureId)
    if (!entries) {
      const existing = await getStore().loadHarnessLog(featureId)
      entries = existing?.entries || []
      this.cache.set(featureId, entries)
    }

    // Append and save
    entries.push(entry)
    await getStore().saveHarnessLog(featureId, { entries })
  }

  clearCache(featureId?: string): void {
    if (featureId) {
      this.cache.delete(featureId)
    } else {
      this.cache.clear()
    }
  }
}

let instance: LogService | null = null
export function getLogService(): LogService {
  if (!instance) instance = new LogService()
  return instance
}
```

### Task 3: Wire harness events to persistence

Subscribe to `harness:message` events and persist each log entry.

**File:** `src/main/dag-engine/orchestrator.ts`

In `initializeHarness()`, after harness is initialized:

```typescript
// Subscribe to harness messages for logging
harness.on('harness:message', async (msg: HarnessMessage) => {
  const logService = getLogService()
  const entry = this.convertHarnessMessage(msg)
  await logService.appendEntry(this.state.featureId, entry)
})
```

Add the conversion helper (or import from harness):

```typescript
private convertHarnessMessage(msg: HarnessMessage): LogEntry {
  // Type mapping logic
}
```

### Task 4: Clear log cache on execution stop

When execution stops, clear the log cache to ensure fresh loads next time.

**File:** `src/main/dag-engine/orchestrator.ts`

In `stop()` method:

```typescript
// Clear log cache
getLogService().clearCache(this.state.featureId)
```

## Verification

1. `npm run typecheck` - No type errors
2. `npm run build` - Build succeeds
3. Manual test:
   - Start execution on a feature with tasks
   - Check `.dagent/harness_log.json` shows entries appearing
   - View logs in LogDialog UI

## Dependencies

- Phase 35 complete (intention-approval workflow wired)
- HarnessAgent emits `harness:message` events
- Storage layer has `saveHarnessLog`/`loadHarnessLog`
