---
phase: 39-harness-router
plan: 02
type: execute
---

<objective>
Send approval/rejection responses via MessageBus and remove direct method calls from TaskAgent.

Purpose: Complete the message-based communication migration - harness sends decisions via messages, TaskAgent removes direct harness method calls.
Output: Full message-based communication between TaskAgent and HarnessAgent.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-harness-router/39-01-SUMMARY.md

**Key files from prior plans:**
@src/main/agents/harness-agent.ts
@src/main/agents/task-agent.ts
@src/main/agents/message-bus.ts
@src/shared/types/message.ts

**Tech stack available:** MessageBus, InterAgentMessage types, createHarnessToTaskMessage helper
**Established patterns:** Dual-write migration, message handlers, subscription cleanup
</context>

<tasks>

<task type="auto">
  <name>Task 1: Send approval/rejection via MessageBus</name>
  <files>src/main/agents/harness-agent.ts</files>
  <action>
1. Import createHarnessToTaskMessage at top of file:
   ```typescript
   import { getMessageBus, createHarnessToTaskMessage } from './message-bus'
   ```

2. In applyDecision() method, after updating local state, publish message:
   ```typescript
   // Send decision via MessageBus
   const bus = getMessageBus()
   if (decision.approved) {
     bus.publish(createHarnessToTaskMessage(
       taskId,
       pending.agentId,
       'intention_approved',
       { type: decision.type, notes: decision.notes }
     ))
   } else {
     bus.publish(createHarnessToTaskMessage(
       taskId,
       pending.agentId,
       'intention_rejected',
       { reason: decision.reason }
     ))
   }
   ```

This allows TaskAgent to receive decisions via its message subscription.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>HarnessAgent publishes approval/rejection messages</done>
</task>

<task type="auto">
  <name>Task 2: Remove direct harness method calls from TaskAgent</name>
  <files>src/main/agents/task-agent.ts</files>
  <action>
Now that harness receives messages and sends responses via MessageBus, remove direct calls:

1. In initialize(), remove direct harness call (keep only message):
   ```typescript
   // REMOVE these lines:
   // const harness = getHarnessAgent()
   // harness.registerTaskAssignment(this.state.taskId, agentInfo.id)
   ```
   Keep only the MessageBus publish.

2. In proposeIntention(), remove direct harness call:
   ```typescript
   // REMOVE these lines:
   // const harness = getHarnessAgent()
   // harness.receiveIntention(this.state.agentId!, this.state.taskId, intentionText)
   ```
   Keep only the MessageBus publish.

3. In receiveApproval(), remove direct markTaskWorking call and publish message instead:
   ```typescript
   // REMOVE:
   // const harness = getHarnessAgent()
   // harness.markTaskWorking(this.state.taskId)

   // ADD (publish task_working message):
   const bus = getMessageBus()
   bus.publish(createTaskToHarnessMessage(
     this.state.taskId,
     this.state.agentId!,
     'task_working',
     { startedAt: new Date().toISOString() }
   ))
   ```

4. Remove getHarnessAgent import if no longer used.

Migration complete - all communication now via MessageBus.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>TaskAgent uses only MessageBus for harness communication</done>
</task>

<task type="auto">
  <name>Task 3: Add task_completed and task_failed message publishing</name>
  <files>src/main/agents/task-agent.ts</files>
  <action>
In execute() method, publish completion/failure messages:

1. On success (after commitChanges), publish task_completed:
   ```typescript
   // Publish task_completed message
   const bus = getMessageBus()
   bus.publish(createTaskToHarnessMessage(
     this.state.taskId,
     this.state.agentId!,
     'task_completed',
     { summary: completionSummary, commitHash: commitResult.commitHash }
   ))
   ```

2. In catch block (on failure), publish task_failed:
   ```typescript
   // Publish task_failed message
   const bus = getMessageBus()
   bus.publish(createTaskToHarnessMessage(
     this.state.taskId,
     this.state.agentId!,
     'task_failed',
     { error: this.state.error }
   ))
   ```

This completes the message-based lifecycle communication.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>TaskAgent publishes completion/failure messages</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] HarnessAgent publishes approval/rejection messages
- [ ] TaskAgent no longer calls harness methods directly
- [ ] TaskAgent publishes task_working, task_completed, task_failed messages
- [ ] Full message-based communication between agents
</verification>

<success_criteria>
- All tasks completed
- No direct method calls between TaskAgent and HarnessAgent
- All communication via MessageBus
- Session logging continues alongside messaging
- No regressions in task execution flow
</success_criteria>

<output>
After completion, create `.planning/phases/39-harness-router/39-02-SUMMARY.md`
</output>
