---
phase: 39-harness-router
plan: 01
type: execute
---

<objective>
Subscribe HarnessAgent to MessageBus and handle incoming task messages.

Purpose: HarnessAgent receives task_registered and intention_proposed messages via MessageBus instead of relying solely on direct method calls.
Output: HarnessAgent subscribed to message bus, routing messages to existing handlers.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/38-message-queue/38-01-SUMMARY.md
@.planning/phases/38-message-queue/38-02-SUMMARY.md

**Key files from prior plans:**
@src/main/agents/harness-agent.ts
@src/main/agents/message-bus.ts
@src/shared/types/message.ts

**Tech stack available:** MessageBus, InterAgentMessage types, createHarnessToTaskMessage helper
**Established patterns:** Task-scoped subscriptions, dual-write migration, handler delegation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Subscribe HarnessAgent to MessageBus on start</name>
  <files>src/main/agents/harness-agent.ts</files>
  <action>
1. Import MessageBus and message helpers at top of file:
   ```typescript
   import { getMessageBus } from './message-bus'
   import type { InterAgentMessage, TaskRegisteredPayload, IntentionProposedPayload } from '@shared/types'
   ```

2. Add private unsubscribe property to class:
   ```typescript
   private unsubscribe?: () => void
   ```

3. In start() method, after setting status to 'active', subscribe to all messages:
   ```typescript
   // Subscribe to task messages
   const bus = getMessageBus()
   this.unsubscribe = bus.subscribe((msg) => {
     if (msg.to.type === 'harness') {
       this.handleMessage(msg)
     }
   })
   ```

4. In stop() and reset() methods, call this.unsubscribe?.() before other cleanup.

This sets up harness to receive all messages destined for it.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>HarnessAgent subscribes to MessageBus on start, unsubscribes on stop/reset</done>
</task>

<task type="auto">
  <name>Task 2: Add message handler routing</name>
  <files>src/main/agents/harness-agent.ts</files>
  <action>
Add private handleMessage method to route messages by type:

```typescript
/**
 * Handle incoming message from MessageBus.
 * Routes to appropriate handler based on message type.
 */
private handleMessage(msg: InterAgentMessage): void {
  switch (msg.type) {
    case 'task_registered':
      this.handleTaskRegistered(msg)
      break
    case 'intention_proposed':
      this.handleIntentionProposed(msg)
      break
    case 'task_working':
      this.handleTaskWorking(msg)
      break
    case 'task_completed':
      this.handleTaskCompleted(msg)
      break
    case 'task_failed':
      this.handleTaskFailed(msg)
      break
    default:
      // Unknown message type - log and ignore
      this.log('warning', `Unknown message type: ${msg.type}`, msg.taskId)
  }
}
```

This provides centralized message routing for all task-to-harness messages.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>HarnessAgent routes messages to type-specific handlers</done>
</task>

<task type="auto">
  <name>Task 3: Implement message-specific handlers</name>
  <files>src/main/agents/harness-agent.ts</files>
  <action>
Add handler methods that delegate to existing logic:

```typescript
/**
 * Handle task_registered message.
 * Delegates to existing registerTaskAssignment logic.
 */
private handleTaskRegistered(msg: InterAgentMessage): void {
  const payload = msg.payload as TaskRegisteredPayload
  // The existing method already does the work - this is for message-based path
  // Note: During dual-write, both direct call AND message arrive - avoid duplicate processing
  // Check if task already registered
  if (!this.state.activeTasks.has(msg.taskId)) {
    this.registerTaskAssignment(msg.taskId, msg.from.id)
  }
}

/**
 * Handle intention_proposed message.
 * Delegates to existing receiveIntention logic.
 */
private handleIntentionProposed(msg: InterAgentMessage): void {
  const payload = msg.payload as IntentionProposedPayload
  // Check if intention already pending (from direct call)
  if (!this.state.pendingIntentions.has(msg.taskId)) {
    this.receiveIntention(msg.from.id, msg.taskId, payload.intention, payload.files)
  }
}

/**
 * Handle task_working message.
 */
private handleTaskWorking(msg: InterAgentMessage): void {
  this.markTaskWorking(msg.taskId)
}

/**
 * Handle task_completed message.
 */
private handleTaskCompleted(msg: InterAgentMessage): void {
  this.completeTask(msg.taskId)
}

/**
 * Handle task_failed message.
 */
private handleTaskFailed(msg: InterAgentMessage): void {
  const payload = msg.payload as { error: string }
  this.failTask(msg.taskId, payload.error)
}
```

Handlers check for duplicate processing during dual-write migration period.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>HarnessAgent handles task messages via MessageBus</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] HarnessAgent subscribes to MessageBus on start()
- [ ] HarnessAgent unsubscribes on stop() and reset()
- [ ] Messages routed to appropriate handlers by type
- [ ] Duplicate processing avoided during dual-write period
</verification>

<success_criteria>
- All tasks completed
- HarnessAgent receives and processes task messages
- Backward compatibility maintained (direct calls still work)
- No regressions in execution flow
</success_criteria>

<output>
After completion, create `.planning/phases/39-harness-router/39-01-SUMMARY.md`
</output>
