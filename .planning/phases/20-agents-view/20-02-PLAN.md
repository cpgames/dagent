# Phase 20 Plan 02: Agent Configuration UI and Persistence

**Goal**: Create agent configuration panel with editing, persistence via IPC, and runtime status integration

**Depends on**: Plan 20-01 (AgentsView, agent-store, AgentConfig types)

## Context

Plan 20-01 established the Agents View infrastructure with card display. This plan adds the configuration editing UI, backend persistence, and runtime status connection.

**Current state (after 20-01):**
- AgentsView shows 5 agent cards with mock data
- agent-store has loadConfigs/updateConfig stubs
- No persistence or IPC handlers
- No connection to actual agent pool status

**Target state:**
- Full configuration panel for editing agent settings
- IPC handlers for loading/saving agent configs
- Storage in .dagent/agents.json per project
- Runtime status updates from agent pool

## Tasks

### Task 1: Create AgentConfigPanel component

**File**: `src/renderer/src/components/Agents/AgentConfigPanel.tsx` (NEW)

1. Create configuration editing panel:
   ```typescript
   import type { JSX } from 'react'
   import { useState, useEffect } from 'react'
   import { useAgentStore } from '../../stores'
   import type { AgentConfig, AgentRole } from '@shared/types'

   interface AgentConfigPanelProps {
     role: AgentRole
     onClose: () => void
   }

   export function AgentConfigPanel({ role, onClose }: AgentConfigPanelProps): JSX.Element {
     const { configs, updateConfig, runtimeStatus } = useAgentStore()
     const config = configs[role]
     const status = runtimeStatus[role]

     // Local state for editing
     const [name, setName] = useState(config.name)
     const [instructions, setInstructions] = useState(config.instructions)
     const [enabled, setEnabled] = useState(config.enabled)
     const [permissionMode, setPermissionMode] = useState(config.permissionMode)
     const [isSaving, setIsSaving] = useState(false)

     // Reset local state when role changes
     useEffect(() => {
       setName(config.name)
       setInstructions(config.instructions)
       setEnabled(config.enabled)
       setPermissionMode(config.permissionMode)
     }, [config])

     const hasChanges =
       name !== config.name ||
       instructions !== config.instructions ||
       enabled !== config.enabled ||
       permissionMode !== config.permissionMode

     const handleSave = async (): Promise<void> => {
       setIsSaving(true)
       try {
         await updateConfig(role, { name, instructions, enabled, permissionMode })
       } finally {
         setIsSaving(false)
       }
     }

     const handleReset = (): void => {
       setName(config.name)
       setInstructions(config.instructions)
       setEnabled(config.enabled)
       setPermissionMode(config.permissionMode)
     }

     return (
       <div className="p-4 bg-gray-800 rounded-lg border border-gray-700">
         {/* Header */}
         <div className="flex items-center justify-between mb-4">
           <div className="flex items-center gap-3">
             <h3 className="text-lg font-medium text-white">{config.name}</h3>
             <StatusBadge status={status.status} />
           </div>
           <button
             onClick={onClose}
             className="text-gray-400 hover:text-white transition-colors"
           >
             <XIcon className="w-5 h-5" />
           </button>
         </div>

         {/* Current activity */}
         {status.status === 'busy' && status.currentTaskTitle && (
           <div className="mb-4 p-2 bg-blue-900/20 border border-blue-800 rounded text-sm text-blue-300">
             Currently working on: {status.currentTaskTitle}
           </div>
         )}

         {/* Name field */}
         <div className="mb-4">
           <label className="block text-sm font-medium text-gray-300 mb-1">
             Display Name
           </label>
           <input
             type="text"
             value={name}
             onChange={(e) => setName(e.target.value)}
             className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-white focus:border-blue-500 focus:outline-none"
           />
         </div>

         {/* Instructions field */}
         <div className="mb-4">
           <label className="block text-sm font-medium text-gray-300 mb-1">
             Instructions (System Prompt)
           </label>
           <textarea
             value={instructions}
             onChange={(e) => setInstructions(e.target.value)}
             rows={5}
             className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-white focus:border-blue-500 focus:outline-none resize-none"
           />
           <p className="text-xs text-gray-500 mt-1">
             These instructions are prepended to the agent's prompts
           </p>
         </div>

         {/* Permission mode */}
         <div className="mb-4">
           <label className="block text-sm font-medium text-gray-300 mb-1">
             Permission Mode
           </label>
           <select
             value={permissionMode}
             onChange={(e) => setPermissionMode(e.target.value as AgentConfig['permissionMode'])}
             className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded text-white focus:border-blue-500 focus:outline-none"
           >
             <option value="default">Default (ask for permissions)</option>
             <option value="acceptEdits">Accept Edits (auto-approve file changes)</option>
             <option value="bypassPermissions">Bypass All (full autonomy)</option>
           </select>
         </div>

         {/* Enabled toggle */}
         <div className="mb-4">
           <label className="flex items-center gap-2 cursor-pointer">
             <input
               type="checkbox"
               checked={enabled}
               onChange={(e) => setEnabled(e.target.checked)}
               className="w-4 h-4 rounded border-gray-600 bg-gray-700 text-blue-500 focus:ring-blue-500"
             />
             <span className="text-sm text-gray-300">Agent enabled</span>
           </label>
           <p className="text-xs text-gray-500 mt-1 ml-6">
             Disabled agents won't be used for task execution
           </p>
         </div>

         {/* Tools display (read-only for now) */}
         <div className="mb-4">
           <label className="block text-sm font-medium text-gray-300 mb-1">
             Allowed Tools
           </label>
           <div className="flex flex-wrap gap-1">
             {config.allowedTools.map((tool) => (
               <span
                 key={tool}
                 className="px-2 py-0.5 bg-gray-700 rounded text-xs text-gray-300"
               >
                 {tool}
               </span>
             ))}
           </div>
         </div>

         {/* Actions */}
         <div className="flex items-center justify-end gap-2 pt-4 border-t border-gray-700">
           {hasChanges && (
             <button
               onClick={handleReset}
               className="px-3 py-1.5 text-sm text-gray-400 hover:text-white transition-colors"
             >
               Reset
             </button>
           )}
           <button
             onClick={handleSave}
             disabled={!hasChanges || isSaving}
             className={`
               px-4 py-1.5 text-sm font-medium rounded transition-colors
               ${hasChanges
                 ? 'bg-blue-600 hover:bg-blue-500 text-white'
                 : 'bg-gray-700 text-gray-500 cursor-not-allowed'}
             `}
           >
             {isSaving ? 'Saving...' : 'Save Changes'}
           </button>
         </div>
       </div>
     )
   }

   function StatusBadge({ status }: { status: 'idle' | 'busy' | 'offline' }): JSX.Element {
     const styles = {
       idle: 'bg-green-900/50 text-green-400 border-green-800',
       busy: 'bg-yellow-900/50 text-yellow-400 border-yellow-800',
       offline: 'bg-gray-700 text-gray-400 border-gray-600'
     }

     return (
       <span className={`px-2 py-0.5 text-xs rounded border ${styles[status]}`}>
         {status}
       </span>
     )
   }

   function XIcon({ className }: { className?: string }): JSX.Element {
     return (
       <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
         <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
       </svg>
     )
   }
   ```

2. Create index file `src/renderer/src/components/Agents/index.ts`:
   ```typescript
   export { AgentConfigPanel } from './AgentConfigPanel'
   ```

**Verification**: Component renders without TypeScript errors

### Task 2: Update AgentsView to use AgentConfigPanel

**File**: `src/renderer/src/views/AgentsView.tsx`

1. Replace placeholder details panel with AgentConfigPanel:
   ```typescript
   import { AgentConfigPanel } from '../components/Agents'

   // In the component, replace the placeholder:
   {selectedRole && (
     <div className="mt-4">
       <AgentConfigPanel
         role={selectedRole}
         onClose={() => selectRole(null)}
       />
     </div>
   )}
   ```

**Verification**: Clicking agent card shows configuration panel

### Task 3: Add agent config IPC handlers

**File**: `src/main/ipc/agent-config-handlers.ts` (NEW)

1. Create handlers for agent config operations:
   ```typescript
   import { ipcMain } from 'electron'
   import { getStorage } from '../storage'
   import type { AgentConfig, AgentRole } from '@shared/types'
   import { DEFAULT_AGENT_CONFIGS } from '@shared/types'

   const ALL_ROLES: AgentRole[] = ['pm', 'harness', 'developer', 'qa', 'merge']

   /**
    * Load agent configs from storage, falling back to defaults
    */
   async function loadAgentConfigs(): Promise<Record<AgentRole, AgentConfig>> {
     const storage = getStorage()
     const configs = {} as Record<AgentRole, AgentConfig>

     for (const role of ALL_ROLES) {
       try {
         const stored = await storage.loadAgentConfig(role)
         if (stored) {
           configs[role] = stored
         } else {
           configs[role] = { role, ...DEFAULT_AGENT_CONFIGS[role] }
         }
       } catch {
         configs[role] = { role, ...DEFAULT_AGENT_CONFIGS[role] }
       }
     }

     return configs
   }

   /**
    * Save agent config to storage
    */
   async function saveAgentConfig(config: AgentConfig): Promise<void> {
     const storage = getStorage()
     await storage.saveAgentConfig(config)
   }

   export function registerAgentConfigHandlers(): void {
     ipcMain.handle('agent:loadConfigs', async () => {
       return loadAgentConfigs()
     })

     ipcMain.handle('agent:saveConfig', async (_event, config: AgentConfig) => {
       await saveAgentConfig(config)
       return { success: true }
     })

     ipcMain.handle('agent:resetConfig', async (_event, role: AgentRole) => {
       const defaultConfig: AgentConfig = { role, ...DEFAULT_AGENT_CONFIGS[role] }
       await saveAgentConfig(defaultConfig)
       return defaultConfig
     })
   }
   ```

2. Register in `src/main/ipc/index.ts`:
   ```typescript
   import { registerAgentConfigHandlers } from './agent-config-handlers'

   export function registerAllHandlers(): void {
     // ... existing handlers
     registerAgentConfigHandlers()
   }
   ```

**Verification**: IPC handlers registered without errors

### Task 4: Add storage methods for agent configs

**File**: `src/main/storage/storage-service.ts`

1. Add methods for agent config persistence:
   ```typescript
   /**
    * Load agent configuration for a role
    */
   async loadAgentConfig(role: AgentRole): Promise<AgentConfig | null> {
     const configPath = path.join(this.projectRoot, '.dagent', 'agents.json')
     try {
       const data = await fs.readFile(configPath, 'utf-8')
       const configs = JSON.parse(data) as Record<AgentRole, AgentConfig>
       return configs[role] || null
     } catch {
       return null
     }
   }

   /**
    * Save agent configuration
    */
   async saveAgentConfig(config: AgentConfig): Promise<void> {
     const configPath = path.join(this.projectRoot, '.dagent', 'agents.json')
     let configs: Record<string, AgentConfig> = {}

     try {
       const data = await fs.readFile(configPath, 'utf-8')
       configs = JSON.parse(data)
     } catch {
       // File doesn't exist, start fresh
     }

     configs[config.role] = config
     await fs.writeFile(configPath, JSON.stringify(configs, null, 2))
   }

   /**
    * Load all agent configurations
    */
   async loadAllAgentConfigs(): Promise<Record<AgentRole, AgentConfig> | null> {
     const configPath = path.join(this.projectRoot, '.dagent', 'agents.json')
     try {
       const data = await fs.readFile(configPath, 'utf-8')
       return JSON.parse(data) as Record<AgentRole, AgentConfig>
     } catch {
       return null
     }
   }
   ```

2. Import AgentRole and AgentConfig types at top of file

**Verification**: Can read/write agent configs to .dagent/agents.json

### Task 5: Add preload API for agent config

**File**: `src/preload/index.ts`

1. Add agent config methods to preload API:
   ```typescript
   agentLoadConfigs: (): Promise<Record<AgentRole, AgentConfig>> =>
     ipcRenderer.invoke('agent:loadConfigs'),

   agentSaveConfig: (config: AgentConfig): Promise<{ success: boolean }> =>
     ipcRenderer.invoke('agent:saveConfig', config),

   agentResetConfig: (role: AgentRole): Promise<AgentConfig> =>
     ipcRenderer.invoke('agent:resetConfig', role),
   ```

2. Update ElectronAPI type in `src/preload/index.d.ts`

**Verification**: window.electronAPI has agent methods

### Task 6: Connect agent-store to IPC

**File**: `src/renderer/src/stores/agent-store.ts`

1. Update loadConfigs to use IPC:
   ```typescript
   loadConfigs: async () => {
     set({ isLoading: true, error: null })
     try {
       const configs = await window.electronAPI.agentLoadConfigs()
       set({ configs, isLoading: false })
     } catch (err) {
       set({ error: String(err), isLoading: false })
     }
   },
   ```

2. Update updateConfig to persist:
   ```typescript
   updateConfig: async (role, updates) => {
     const { configs } = get()
     const current = configs[role]
     if (!current) return

     const updated = { ...current, ...updates }

     try {
       await window.electronAPI.agentSaveConfig(updated)
       set({ configs: { ...configs, [role]: updated } })
     } catch (err) {
       // Revert on failure
       console.error('Failed to save agent config:', err)
     }
   },
   ```

**Verification**: Agent configs persist across app restarts

### Task 7: Add runtime status updates from agent pool

**File**: `src/main/ipc/agent-config-handlers.ts`

1. Add handler for getting current agent pool status:
   ```typescript
   import { getAgentPool } from '../agents'

   ipcMain.handle('agent:getRuntimeStatus', async () => {
     const pool = getAgentPool()
     const agents = pool.getAgents()
     const status = pool.getStatus()

     // Map pool agents to runtime status by role
     const runtimeStatus: Record<AgentRole, AgentRuntimeStatus> = {
       pm: { role: 'pm', status: 'offline' },
       harness: { role: 'harness', status: status.hasHarness ? 'idle' : 'offline' },
       developer: { role: 'developer', status: 'offline' },
       qa: { role: 'qa', status: 'offline' },
       merge: { role: 'merge', status: 'offline' }
     }

     // Update based on running agents
     for (const agent of agents) {
       if (agent.status === 'terminated') continue

       // Map old agent types to new roles
       // harness -> harness, task -> developer, merge -> merge
       let role: AgentRole
       if (agent.type === 'harness') role = 'harness'
       else if (agent.type === 'task') role = 'developer'
       else if (agent.type === 'merge') role = 'merge'
       else continue

       runtimeStatus[role] = {
         role,
         status: agent.status === 'busy' ? 'busy' : 'idle',
         currentTaskId: agent.taskId,
         // TODO: Get task title from storage
       }
     }

     return runtimeStatus
   })
   ```

2. Add preload method and store action

**File**: `src/renderer/src/stores/agent-store.ts`

3. Add polling for runtime status:
   ```typescript
   loadRuntimeStatus: async () => {
     try {
       const status = await window.electronAPI.agentGetRuntimeStatus()
       set({ runtimeStatus: status })
     } catch (err) {
       console.error('Failed to load agent runtime status:', err)
     }
   },
   ```

4. In AgentsView, poll status:
   ```typescript
   useEffect(() => {
     loadRuntimeStatus()
     const interval = setInterval(loadRuntimeStatus, 2000) // Poll every 2s
     return () => clearInterval(interval)
   }, [loadRuntimeStatus])
   ```

**Verification**: Agent cards show live status from pool

## Verification Checklist

- [ ] Clicking agent card opens configuration panel
- [ ] Can edit agent name, instructions, permission mode
- [ ] Can toggle agent enabled/disabled
- [ ] Save button saves changes to .dagent/agents.json
- [ ] Changes persist across app restart
- [ ] Agent status indicators update when agents run
- [ ] TypeScript compiles without errors
- [ ] npm run typecheck passes

## Files Changed

**Created:**
- `src/renderer/src/components/Agents/AgentConfigPanel.tsx`
- `src/renderer/src/components/Agents/index.ts`
- `src/main/ipc/agent-config-handlers.ts`

**Modified:**
- `src/renderer/src/views/AgentsView.tsx`
- `src/main/ipc/index.ts`
- `src/main/storage/storage-service.ts`
- `src/preload/index.ts`
- `src/preload/index.d.ts`
- `src/renderer/src/stores/agent-store.ts`
