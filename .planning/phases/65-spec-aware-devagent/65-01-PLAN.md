---
phase: 65-spec-aware-devagent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/dag-engine/task-controller.ts
  - src/main/agents/dev-agent.ts
  - src/main/agents/dev-types.ts
autonomous: true

must_haves:
  truths:
    - "DevAgent receives feature spec as part of task context"
    - "DevAgent can reference spec goals and requirements in execution prompt"
    - "Spec is loaded from FeatureSpecStore before DevAgent execution"
  artifacts:
    - path: "src/main/dag-engine/task-controller.ts"
      provides: "Spec loading and passing to DevAgent"
      contains: "getFeatureSpecStore"
    - path: "src/main/agents/dev-agent.ts"
      provides: "Spec-aware execution prompt building"
      contains: "featureSpec"
    - path: "src/main/agents/dev-types.ts"
      provides: "FeatureSpec field in DevAgentContext"
      contains: "featureSpec"
  key_links:
    - from: "src/main/dag-engine/task-controller.ts"
      to: "src/main/agents/feature-spec-store.ts"
      via: "import getFeatureSpecStore"
      pattern: "getFeatureSpecStore"
    - from: "src/main/dag-engine/task-controller.ts"
      to: "src/main/agents/dev-agent.ts"
      via: "passes spec via context"
      pattern: "featureSpec"
---

<objective>
Enable DevAgent to receive and use the feature specification for broader context.

Purpose: Give DevAgent understanding of full feature goals beyond immediate task, enabling better implementation decisions.
Output: DevAgent receives FeatureSpec and includes it in execution prompts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v2.5-ROADMAP.md

@src/main/dag-engine/task-controller.ts
@src/main/agents/dev-agent.ts
@src/main/agents/dev-types.ts
@src/main/agents/feature-spec-store.ts
@src/main/agents/feature-spec-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add featureSpec to DevAgentContext type</name>
  <files>src/main/agents/dev-types.ts</files>
  <action>
Add optional `featureSpec` field to `DevAgentContext` interface to hold the loaded feature specification.

1. Import `FeatureSpec` type from `./feature-spec-types`
2. Add to `DevAgentContext`:
   ```typescript
   /** Feature specification for broader context (optional) */
   featureSpec?: FeatureSpec
   ```

This allows DevAgent to receive the spec without breaking existing code (field is optional).
  </action>
  <verify>npm run build passes with no type errors</verify>
  <done>DevAgentContext includes optional featureSpec field</done>
</task>

<task type="auto">
  <name>Task 2: Load and pass spec in TaskController</name>
  <files>src/main/dag-engine/task-controller.ts</files>
  <action>
Modify TaskController to load the feature spec and pass it to DevAgent.

1. Add imports at top:
   ```typescript
   import { getFeatureSpecStore } from '../agents/feature-spec-store'
   import type { FeatureSpec } from '../agents/feature-spec-types'
   ```

2. Add `featureSpec` field to TaskController class:
   ```typescript
   private featureSpec: FeatureSpec | null = null
   ```

3. In `start()` method, after loading TaskPlan and before entering iteration loop, load the feature spec:
   ```typescript
   // Load feature spec for DevAgent context
   const specStore = getFeatureSpecStore(this.projectRoot)
   this.featureSpec = await specStore.loadSpec(this.state.featureId)
   ```

4. In `spawnDevAgent()` method, when calling `agent.initialize()` and `agent.initializeForIteration()`:
   - Pass the featureSpec as an additional parameter

Note: DevAgent.initialize() and initializeForIteration() will need to accept the spec parameter (Task 3).
  </action>
  <verify>npm run build passes</verify>
  <done>TaskController loads spec and prepares to pass to DevAgent</done>
</task>

<task type="auto">
  <name>Task 3: Update DevAgent to accept and use spec</name>
  <files>src/main/agents/dev-agent.ts</files>
  <action>
Modify DevAgent to accept feature spec and include it in execution prompts.

1. Add import for FeatureSpec type:
   ```typescript
   import type { FeatureSpec } from './feature-spec-types'
   ```

2. Update `initialize()` method signature to accept optional featureSpec:
   ```typescript
   async initialize(
     task: Task,
     graph: DAGGraph,
     claudeMd?: string,
     featureGoal?: string,
     featureSpec?: FeatureSpec
   ): Promise<boolean>
   ```

3. Update `initializeForIteration()` method signature similarly:
   ```typescript
   async initializeForIteration(
     task: Task,
     graph: DAGGraph,
     worktreePath: string,
     claudeMd?: string,
     featureGoal?: string,
     featureSpec?: FeatureSpec
   ): Promise<boolean>
   ```

4. In `loadContext()` method, add featureSpec to context object:
   ```typescript
   this.state.context = {
     claudeMd: claudeMd || null,
     featureGoal: featureGoal || null,
     featureSpec: featureSpec || null,  // Add this
     taskTitle: task.title,
     ...
   }
   ```

5. In `buildExecutionPrompt()` method, add feature spec section after feature goal:
   ```typescript
   if (context.featureSpec) {
     parts.push('## Feature Specification')
     parts.push('This task is part of a larger feature. Keep these goals in mind:')
     parts.push('')

     if (context.featureSpec.goals.length > 0) {
       parts.push('### Goals')
       for (const goal of context.featureSpec.goals) {
         parts.push(`- ${goal}`)
       }
       parts.push('')
     }

     if (context.featureSpec.requirements.length > 0) {
       parts.push('### Requirements')
       for (const req of context.featureSpec.requirements) {
         const status = req.completed ? '✓' : '○'
         parts.push(`- ${status} ${req.id}: ${req.description}`)
       }
       parts.push('')
     }

     if (context.featureSpec.constraints.length > 0) {
       parts.push('### Constraints')
       for (const constraint of context.featureSpec.constraints) {
         parts.push(`- ${constraint}`)
       }
       parts.push('')
     }
   }
   ```

This gives DevAgent full awareness of the feature context while implementing individual tasks.
  </action>
  <verify>npm run build passes</verify>
  <done>DevAgent accepts spec and includes it in prompts</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds
- [ ] DevAgentContext type includes featureSpec field
- [ ] TaskController loads spec from store
- [ ] DevAgent.initialize() and initializeForIteration() accept spec parameter
- [ ] buildExecutionPrompt() includes spec sections when available
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- DevAgent can receive and display feature spec in execution context
</success_criteria>

<output>
After completion, create `.planning/phases/65-spec-aware-devagent/65-01-SUMMARY.md`
</output>
