---
phase: 41-request-manager
plan: 01
type: execute
---

<objective>
Create RequestManager class with priority queue for Claude SDK requests.

Purpose: Centralize all API request management to control concurrency (default: 3) with priority-based queueing.
Output: RequestManager class with enqueue(), priority queue, and configurable max concurrent requests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v2.0-ROADMAP.md

**Key source files:**
@src/main/agent/types.ts
@src/main/agent/agent-service.ts

**Priority levels (highest first):**
| Priority | Source | Rationale |
|----------|--------|-----------|
| P0 | PM Agent | Human is waiting |
| P1 | Harness responding to Merge | Unblock fastest |
| P2 | Merge Agent | Unblock dependents |
| P3 | QA Agent | Validate before merge |
| P4 | Harness responding to Dev | |
| P5 | Dev Agent | New work |
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create request types</name>
  <files>src/main/agent/request-types.ts</files>
  <action>
Create TypeScript types for the request queue system:

1. **RequestPriority enum** with values:
   - PM = 0 (highest - human waiting)
   - HARNESS_MERGE = 1 (unblock fastest)
   - MERGE = 2 (unblock dependents)
   - QA = 3 (validate before merge)
   - HARNESS_DEV = 4
   - DEV = 5 (lowest - new work)

2. **QueuedRequest interface**:
   - id: string (unique request ID)
   - priority: RequestPriority
   - agentId: string (e.g., 'pm', 'dev-task1', 'qa-task2', 'merge-task3')
   - taskId?: string (optional - for task-specific agents)
   - execute: () => AsyncIterable<AgentStreamEvent> (the actual SDK call)
   - resolve: (value: void) => void (promise resolution)
   - reject: (error: Error) => void (promise rejection)
   - enqueuedAt: number (timestamp for FIFO within priority)

3. **RequestManagerConfig interface**:
   - maxConcurrent: number (default: 3)

Export all types.
  </action>
  <verify>TypeScript compiles without errors: npx tsc --noEmit</verify>
  <done>request-types.ts exists with RequestPriority enum, QueuedRequest interface, RequestManagerConfig interface</done>
</task>

<task type="auto">
  <name>Task 2: Implement RequestManager class</name>
  <files>src/main/agent/request-manager.ts</files>
  <action>
Create RequestManager class that manages concurrent API requests with priority queue:

1. **Private state**:
   - queue: QueuedRequest[] (sorted by priority, then enqueuedAt for FIFO)
   - activeCount: number (current concurrent requests)
   - maxConcurrent: number (from config, default 3)

2. **Constructor**:
   - Accept optional RequestManagerConfig
   - Initialize maxConcurrent (default 3)

3. **enqueue() method**:
   - Signature: `enqueue(priority: RequestPriority, agentId: string, execute: () => AsyncIterable<AgentStreamEvent>, taskId?: string): Promise<AsyncIterable<AgentStreamEvent>>`
   - Create QueuedRequest with unique id (use crypto.randomUUID())
   - Insert into queue sorted by: priority ASC, then enqueuedAt ASC (FIFO within priority)
   - Return a Promise that:
     - If under maxConcurrent: immediately execute and return the async iterable
     - If at capacity: queue the request, resolve when slot available
   - The Promise wraps the async iterable so callers can just `await requestManager.enqueue(...)`

4. **processQueue() method** (private):
   - If activeCount >= maxConcurrent: return (at capacity)
   - If queue empty: return (nothing to process)
   - Shift first request from queue
   - Increment activeCount
   - Execute the request's execute function
   - Wrap the async iterable to decrement activeCount when done/error
   - Call processQueue() again to fill remaining slots

5. **Helper: wrapExecution()** (private):
   - Takes the async iterable from execute()
   - Returns a new async generator that:
     - Yields all events from the original
     - On completion or error: decrement activeCount, call processQueue()

6. **getStatus() method**:
   - Return { activeCount, queueLength: queue.length, maxConcurrent }

Export singleton getter: getRequestManager()
  </action>
  <verify>TypeScript compiles without errors: npx tsc --noEmit</verify>
  <done>RequestManager class with enqueue(), processQueue(), getStatus() methods working correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes without errors
- [ ] request-types.ts exports RequestPriority, QueuedRequest, RequestManagerConfig
- [ ] request-manager.ts exports RequestManager class and getRequestManager()
- [ ] Priority queue maintains correct order (lower priority value = higher precedence)
- [ ] FIFO ordering within same priority level
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- RequestManager can be instantiated and enqueue() returns Promise
- Priority ordering: PM < HARNESS_MERGE < MERGE < QA < HARNESS_DEV < DEV
</success_criteria>

<output>
After completion, create `.planning/phases/41-request-manager/41-01-SUMMARY.md`:

# Phase 41 Plan 01: Request Manager Types and Class Summary

**[Substantive one-liner]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `src/main/agent/request-types.ts` - Description
- `src/main/agent/request-manager.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 41-02-PLAN.md (AgentService integration)
</output>
